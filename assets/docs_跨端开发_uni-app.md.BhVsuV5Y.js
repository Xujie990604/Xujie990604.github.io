import{_ as i,c as e,o as l,ag as t}from"./chunks/framework.BDwTZuFy.js";const c=JSON.parse('{"title":"uni-app","description":"","frontmatter":{},"headers":[],"relativePath":"docs/跨端开发/uni-app.md","filePath":"docs/跨端开发/uni-app.md","lastUpdated":1739863823000}'),n={name:"docs/跨端开发/uni-app.md"};function r(o,a,u,p,d,s){return l(),e("div",null,a[0]||(a[0]=[t('<h1 id="uni-app" tabindex="-1">uni-app <a class="header-anchor" href="#uni-app" aria-label="Permalink to &quot;uni-app&quot;">​</a></h1><h2 id="跨端原理" tabindex="-1">跨端原理 <a class="header-anchor" href="#跨端原理" aria-label="Permalink to &quot;跨端原理&quot;">​</a></h2><ul><li>uni-app 基于 Vue.js 开发，使用统一的开发规范和语法</li><li>uni-app 的跨端实现依赖于编译器和运行时的协同工作。编译器将开发者的代码编译为不同平台的输出物，而每个平台（如 Web、Android、iOS、小程序）都有各自的运行时（runtime）来解析这些输出。运行时内置了大量跨端的 API（如 uni.request、uni.getStorage 等），同时允许开发者调用平台专有 API。</li><li>为了处理不同平台之间的差异，uni-app 提供了条件编译功能</li></ul><h2 id="打包产物" tabindex="-1">打包产物 <a class="header-anchor" href="#打包产物" aria-label="Permalink to &quot;打包产物&quot;">​</a></h2><ul><li>逻辑层的 JS 代码依旧保留，只不过在执行上相比于传统 WEB 技术有一定的优化</li><li>渲染层有两种渲染方式 1. Webview 渲染 2. 原生渲染(nvue)</li><li>一些较底层的操作，通过 uni.* 方法，来调用对应平台的 API</li></ul><h2 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h2><ol><li>JS 的庞大生态</li><li>对于已经掌握 JS、Vue 的前端开发人员来说，学习成本低、门槛低。有丰富的人员储备</li><li>代码热重载，无需编译即可看到效果</li><li>应用热更新、解决问题、发布活动无需发布新版本</li><li>能够支持各个平台的小程序（！核心优势）</li><li>支持鸿蒙平台的开发</li></ol><h2 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h2><ol><li>受限于 WEB 技术栈性能，页面渲染性能和逻辑执行性能，仍是 WEB 的水平</li></ol>',9)]))}const _=i(n,[["render",r]]);export{c as __pageData,_ as default};
