import{_ as n,c as a,o as l,ag as p}from"./chunks/framework.BDwTZuFy.js";const y=JSON.parse('{"title":"渲染器的实现","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Vue/Vue设计与实现/渲染器的实现.md","filePath":"docs/Vue/Vue设计与实现/渲染器的实现.md","lastUpdated":1728633514000}'),e={name:"docs/Vue/Vue设计与实现/渲染器的实现.md"};function o(r,s,c,t,i,b){return l(),a("div",null,s[0]||(s[0]=[p(`<h1 id="渲染器的实现" tabindex="-1">渲染器的实现 <a class="header-anchor" href="#渲染器的实现" aria-label="Permalink to &quot;渲染器的实现&quot;">​</a></h1><ul><li>renderer(渲染器): 渲染器把虚拟 DOM 渲染为特定平台上的真实元素。在浏览器平台上，渲染器会把虚拟 DOM 转化为真实 DOM</li><li>渲染器的精髓都在更新节点的阶段, patch 和 diff 算法</li><li>渲染器被实现为<code>可配置</code>(将特定于平台的 API 进行抽离，允许以配置信息的形式传入渲染器中)的<code>通用渲染器</code>，即可实现渲染到任意目标平台上</li></ul><h2 id="一、虚拟-dom" tabindex="-1">一、虚拟 DOM <a class="header-anchor" href="#一、虚拟-dom" aria-label="Permalink to &quot;一、虚拟 DOM&quot;">​</a></h2><h3 id="_1-1-虚拟-dom" tabindex="-1">1.1 虚拟 DOM <a class="header-anchor" href="#_1-1-虚拟-dom" aria-label="Permalink to &quot;1.1 虚拟 DOM&quot;">​</a></h3><ul><li>本质上就是 JS 对象，对象描述了应该怎样去创建真实的 DOM 结点。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> virtualObj</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  tag: </span><span style="color:#032F62;">&quot;div&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  props: {</span></span>
<span class="line"><span style="color:#24292E;">    class: </span><span style="color:#032F62;">&quot;container&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    onClick: handler,</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">  children: [</span></span>
<span class="line"><span style="color:#24292E;">    {</span></span>
<span class="line"><span style="color:#24292E;">      tag: </span><span style="color:#032F62;">&quot;span&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">      props: {</span></span>
<span class="line"><span style="color:#24292E;">        class: </span><span style="color:#032F62;">&quot;title&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">      },</span></span>
<span class="line"><span style="color:#24292E;">      text: </span><span style="color:#032F62;">&quot;hello word!&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#24292E;">  ],</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_1-2-vue-组件" tabindex="-1">1.2 Vue 组件 <a class="header-anchor" href="#_1-2-vue-组件" aria-label="Permalink to &quot;1.2 Vue 组件&quot;">​</a></h3><blockquote><p>组件就是一组 DOM 元素的封装</p></blockquote><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 使用函数来代表组件(Render 函数)，函数的返回值(虚拟 DOM)就是要渲染的内容</span></span>
<span class="line"><span style="color:#6A737D;">// 执行 Render 函数之后就能得到 VNode</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#6F42C1;"> MyComponent</span><span style="color:#D73A49;"> =</span><span style="color:#D73A49;"> function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    tag: </span><span style="color:#032F62;">&quot;h1&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    props: {</span></span>
<span class="line"><span style="color:#6F42C1;">      onClick</span><span style="color:#24292E;">: () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> handler,</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#24292E;">    children: [</span></span>
<span class="line"><span style="color:#24292E;">      {</span></span>
<span class="line"><span style="color:#24292E;">        tag: </span><span style="color:#032F62;">&quot;span&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">        children: </span><span style="color:#032F62;">&quot;Hello&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">      },</span></span>
<span class="line"><span style="color:#24292E;">    ],</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="二、响应式系统与渲染器" tabindex="-1">二、响应式系统与渲染器 <a class="header-anchor" href="#二、响应式系统与渲染器" aria-label="Permalink to &quot;二、响应式系统与渲染器&quot;">​</a></h2><ul><li>响应式系统和渲染器是解耦的。利用响应式系统的通知能力，自动调用渲染器完成页面的渲染和更新</li></ul><ol><li>对于响应式系统而言: 仅需要关心什么时候要发送通知来更新页面，并不关心页面是如何更新的</li><li>对于渲染器而言: 仅需要在接收到通知后进行页面的渲染和更新，并不关心响应式系统如何实现的通知机制</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#6F42C1;"> id</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;app&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#6F42C1;"> src</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  const { effect, ref } = VueReactivity</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  // 自定义渲染器</span></span>
<span class="line"><span style="color:#24292E;">  function renderer(DOMString, container) {</span></span>
<span class="line"><span style="color:#24292E;">    container.innerHTML </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> DOMString</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  // 响应式数据</span></span>
<span class="line"><span style="color:#24292E;">  const userName = ref(&#39;foo&#39;)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">// 创建一个 effect，当响应式数据发生变化时，会触发 effect 的回调函数</span></span>
<span class="line"><span style="color:#24292E;">  effect(() =&gt; {</span></span>
<span class="line"><span style="color:#6F42C1;">    renderer</span><span style="color:#24292E;">(</span><span style="color:#032F62;">\`&lt;h1&gt;\${</span><span style="color:#24292E;">userName</span><span style="color:#032F62;">.</span><span style="color:#24292E;">value</span><span style="color:#032F62;">}&lt;/h1&gt;\`</span><span style="color:#24292E;">, document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;app&#39;</span><span style="color:#24292E;">))</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#24292E;">    userName.value </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &#39;bar&#39;</span></span>
<span class="line"><span style="color:#24292E;">  }, 3000)</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="三、渲染器的实现" tabindex="-1">三、渲染器的实现 <a class="header-anchor" href="#三、渲染器的实现" aria-label="Permalink to &quot;三、渲染器的实现&quot;">​</a></h2><ul><li>通用渲染器(不依赖于特定平台)：将浏览器的特有 API 与渲染器进行抽离，将操作 DOM 的 API 以配置项的形式传入渲染器，只要传入不同的配置项，就能实现在不同的平台下执行渲染工作</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 在创建 renderer 时传入配置项</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> renderer</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> createRenderer</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#6A737D;">  // 用于创建元素</span></span>
<span class="line"><span style="color:#6F42C1;">  createElement</span><span style="color:#24292E;">(</span><span style="color:#E36209;">tag</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">createElement</span><span style="color:#24292E;">(tag);</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#6A737D;">  // 用于设置元素的文本节点</span></span>
<span class="line"><span style="color:#6F42C1;">  setElementText</span><span style="color:#24292E;">(</span><span style="color:#E36209;">el</span><span style="color:#24292E;">, </span><span style="color:#E36209;">text</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    el.textContent </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> text;</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#6A737D;">  // 用于在给定的 parent 下添加指定元素</span></span>
<span class="line"><span style="color:#6F42C1;">  insert</span><span style="color:#24292E;">(</span><span style="color:#E36209;">el</span><span style="color:#24292E;">, </span><span style="color:#E36209;">parent</span><span style="color:#24292E;">, </span><span style="color:#E36209;">anchor</span><span style="color:#D73A49;"> =</span><span style="color:#005CC5;"> null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    parent.</span><span style="color:#6F42C1;">insertBefore</span><span style="color:#24292E;">(el, anchor);</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="四、页面的首次渲染" tabindex="-1">四、页面的首次渲染 <a class="header-anchor" href="#四、页面的首次渲染" aria-label="Permalink to &quot;四、页面的首次渲染&quot;">​</a></h2><ul><li>页面的首次渲染比较简单，仅需要按照 VNode 的结构创建新的 DOM，并挂载到真实结点上即可</li><li>页面的渲染并不是什么高级的黑魔法，最终也还是调用 <code>DOM API</code> 来创建 DOM 元素</li></ul><h2 id="五、页面的更新" tabindex="-1">五、页面的更新 <a class="header-anchor" href="#五、页面的更新" aria-label="Permalink to &quot;五、页面的更新&quot;">​</a></h2><ul><li>页面更新不是全量更新，而是通过新旧 VNode 的对比，找出本次变化的差异点。这个过程叫做打补丁(patch)</li><li>在执行更新动作之前，先要判断新旧 VNode 的 type 是否相同，如果不一致，那也就没有打补丁的必要了(因为对于不同的元素来说，每个元素都有特有的属性)。需要卸载原来的 DOM，重新渲染新 DOM</li></ul><h2 id="六、diff-算法" tabindex="-1">六、diff 算法 <a class="header-anchor" href="#六、diff-算法" aria-label="Permalink to &quot;六、diff 算法&quot;">​</a></h2><h3 id="_6-1-简单-diff-算法" tabindex="-1">6.1 简单 Diff 算法 <a class="header-anchor" href="#_6-1-简单-diff-算法" aria-label="Permalink to &quot;6.1 简单 Diff 算法&quot;">​</a></h3><blockquote><p>当新旧 VNode 的子节点都是一组节点时，为了以最小的性能开销完成更新操作，需要使用 Diff 算法来对比两组子节点</p></blockquote><h3 id="_6-2-双端-diff-算法" tabindex="-1">6.2 双端 Diff 算法 <a class="header-anchor" href="#_6-2-双端-diff-算法" aria-label="Permalink to &quot;6.2 双端 Diff 算法&quot;">​</a></h3><p>TODO: 根据书籍完善</p><h3 id="_6-3-快速-diff-算法" tabindex="-1">6.3 快速 Diff 算法 <a class="header-anchor" href="#_6-3-快速-diff-算法" aria-label="Permalink to &quot;6.3 快速 Diff 算法&quot;">​</a></h3><p>TODO：根据书籍完善</p>`,27)]))}const d=n(e,[["render",o]]);export{y as __pageData,d as default};
