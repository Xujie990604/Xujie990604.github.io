import{_ as i,c as l,o as n,ag as e}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"盒模型","description":"","frontmatter":{},"headers":[],"relativePath":"docs/HTML+CSS/CSS部分/网页的布局/盒模型.md","filePath":"docs/HTML+CSS/CSS部分/网页的布局/盒模型.md","lastUpdated":1712646874000}'),r={name:"docs/HTML+CSS/CSS部分/网页的布局/盒模型.md"};function t(s,a,o,d,p,h){return n(),l("div",null,a[0]||(a[0]=[e(`<h1 id="盒模型" tabindex="-1">盒模型 <a class="header-anchor" href="#盒模型" aria-label="Permalink to &quot;盒模型&quot;">​</a></h1><h2 id="标准盒模型" tabindex="-1">标准盒模型 <a class="header-anchor" href="#标准盒模型" aria-label="Permalink to &quot;标准盒模型&quot;">​</a></h2><ul><li>box-sizing: content-box; 标准盒模型</li><li>width 和 height 只是 content 内容的大小</li><li>盒子的真实高度还要加上内边距和边框</li><li>内边距的作用是用来控制元素的大小，给元素应用的背景会被设置到 content 和 padding 中</li><li>外边距的作用是用来控制元素之间的距离。</li><li>outline 是用来调试用的，不会影响布局。</li></ul><h2 id="代替盒模型" tabindex="-1">代替盒模型 <a class="header-anchor" href="#代替盒模型" aria-label="Permalink to &quot;代替盒模型&quot;">​</a></h2><ul><li>box-sizing: border-box; 混杂盒模型</li><li>width 和 height 是 content，padding，border 三个内容的大小。</li></ul><h2 id="width-的百分值继承" tabindex="-1">width 的百分值继承 <a class="header-anchor" href="#width-的百分值继承" aria-label="Permalink to &quot;width 的百分值继承&quot;">​</a></h2><ul><li>无论是标准盒模型还是怪异盒模型</li><li>盒模型中(无论是 width height 还是 padding margin )使用百分数的时候，都是相对于真实的 content 区域的 width 和 height 大小。</li><li>如果在标准盒模型中就是 width 和 height 的大小，如果在怪异盒模型中，那就是 width 和 height 减去 padding 和 border。</li></ul><h2 id="匿名盒子" tabindex="-1">匿名盒子 <a class="header-anchor" href="#匿名盒子" aria-label="Permalink to &quot;匿名盒子&quot;">​</a></h2><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">some text</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;xujie&lt;/</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>尽管 some text 没有明确的被在某个元素里面，但是还是会生成一个匿名块盒子。</li><li>开发者无法通过 css 来控制他们，能继承的属性会从父元素继承，不能继承的属性是默认值。</li><li>关键是理解，(你在屏幕上看到的一切都会从属于某个盒子!!!!!!)。</li></ul><h2 id="外边距折叠" tabindex="-1">外边距折叠 <a class="header-anchor" href="#外边距折叠" aria-label="Permalink to &quot;外边距折叠&quot;">​</a></h2><h3 id="margin-合并" tabindex="-1">margin 合并 <a class="header-anchor" href="#margin-合并" aria-label="Permalink to &quot;margin 合并&quot;">​</a></h3><ul><li>两个具有边距的元素上下相邻，两个盒子之间的边距大小是最大的那个单个边距大小。</li></ul><h3 id="margin-collapsing-margin塌陷" tabindex="-1">Margin collapsing(margin塌陷) <a class="header-anchor" href="#margin-collapsing-margin塌陷" aria-label="Permalink to &quot;Margin collapsing(margin塌陷)&quot;">​</a></h3><ul><li>普通文档流中父子块级元素，如果父元素和子元素之间没有内边距和边框分割外边距(也就是说父子元素的外边距直接接触到了一起)，子元素的上边距就会和父元素的上边距重合，</li><li>以他们两个中间最大上边距为准，与距离他们最近的盒子隔开。</li><li>解决方式，父级元素触发 bfc,父元素设置 padding-top 或者 border-top</li></ul><h3 id="外边距折叠的理解" tabindex="-1">外边距折叠的理解 <a class="header-anchor" href="#外边距折叠的理解" aria-label="Permalink to &quot;外边距折叠的理解&quot;">​</a></h3><ul><li>发生的条件</li></ul><ol><li>外边距折叠只发生在文档的常规文本流中的块级盒子的垂直方向上，行内盒子，浮动盒子，绝对定位的盒子不会发生外边距折叠。</li><li>只要是常规文档中的盒子，外边距直接接触了(不论是兄弟元素还是父子元素，甚至是自己的上边距和下边距直接接触)都会发生外边距折叠</li></ol><ul><li>外边距折叠的必要性</li></ul><ol><li>因为外边距折叠的存在，无数的空段落也只会占用一小块的空间。</li></ol><h2 id="零散" tabindex="-1">零散 <a class="header-anchor" href="#零散" aria-label="Permalink to &quot;零散&quot;">​</a></h2><ul><li>body 有个默认的 margin 8px</li><li>块盒的所有属性都受到尊重， 内联盒则不行(必须 display:inline-block)</li></ul><h2 id="padding-margin" tabindex="-1">padding margin <a class="header-anchor" href="#padding-margin" aria-label="Permalink to &quot;padding margin&quot;">​</a></h2><ul><li>padding 和 margin 使用百分比数值时，是基于包含块的宽度来计算，一般来说包含块就是父元素，也有例外。</li></ul><ol><li>margin为4个时，margin:上 右 下 左;（为顺时针方向）</li><li>margin为3个时，margin:上 左=右 下;</li><li>margin为2个时，margin:上=下 左=右;</li><li>margin为1个时，margin:上=右=下=左;</li></ol><h2 id="负边距" tabindex="-1">负边距 <a class="header-anchor" href="#负边距" aria-label="Permalink to &quot;负边距&quot;">​</a></h2><ul><li><p>在文档流中，元素的最终边界是由 margin 来决定的，margin 为负的时候相当于元素的边界往里面收。</p></li><li><p>设置负值的话, border 以内的东西不会变小，元素的视觉效果还是那么大，只不过元素在文档流中的实际大小发生了变化。</p></li><li><p>左边或上边的负边距会把元素自身向左或者向上拉，盖住其旁边的元素。</p></li><li><p>右边或下边的负边距会把相邻元素向左或者向上拉，盖住设置了负边距的元素。</p></li><li><p>(可视区域不会变).而与浮动方向相同的负边距会在该方向上把浮动的元素向外平移</p></li><li><p>自身覆盖其他元素。在浮动的元素上，与浮动方向相反的负边距会导致元素被其他元素覆盖。</p></li><li><p>给未声明宽度的(非浮动块级元素)使用负边距时，左右负边距会向外拉伸元素，导致元素扩张，有可能盖住相邻元素。</p></li></ul>`,27)]))}const g=i(r,[["render",t]]);export{u as __pageData,g as default};
