import{_ as p,c as e,o,ag as a,j as n,a as l,t as r}from"./chunks/framework.BDwTZuFy.js";const m=JSON.parse('{"title":"响应式数据","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Vue/Vue官方文档解读/响应式数据.md","filePath":"docs/Vue/Vue官方文档解读/响应式数据.md","lastUpdated":1728661374000}'),c={name:"docs/Vue/Vue官方文档解读/响应式数据.md"};function t(i,s,y,b,u,E){return o(),e("div",null,[s[3]||(s[3]=a(`<h1 id="响应式数据" tabindex="-1">响应式数据 <a class="header-anchor" href="#响应式数据" aria-label="Permalink to &quot;响应式数据&quot;">​</a></h1><ul><li>Vue 能够跟踪对响应式对象属性的访问与更改操作(对 Proxy 的更改和访问会被 Vue 跟踪到， 对 obj 的更改和访问不会被 Vue 跟踪到)</li><li>在 Vue3 中，状态都是 <code>默认</code>、<code>深层响应式</code> 的</li></ul><blockquote><p>Vue 社区观点，默认使用 ref，并在需要对事物分组时使用 reactive</p></blockquote><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 一、用 ref</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> foo</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> ref</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> bar</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> ref</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">]);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  // 直接使用未分组的数据，需要 .value</span></span>
<span class="line"><span style="color:#24292E;">  foo.value</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  bar.value.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">2000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 二、分组时使用 reactive</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 2.1 分组使用</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> state</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> reactive</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">  foo: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  bar: [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">],</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  state.foo</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  state.bar.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">2000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 2.2 reactive 整体替换</span></span>
<span class="line"><span style="color:#6A737D;">// 既然是分组，那么在实际使用中并不应该出现 \`state = {...}\` 的情况, 所以 reactive 不能整体替换的缺点也就消失了</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 2.3  解构使用</span></span>
<span class="line"><span style="color:#6A737D;">// 想要解构使用时，一律使用 toRefs()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> state</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> reactive</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">  foo: </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">  bar: </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">]),</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> { foo, bar } </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> toRefs</span><span style="color:#24292E;">(state);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  foo.value</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  bar.value.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">2000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 2.4 和组合式函数搭配使用</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 三、第三方库的数据使用 shallowRef</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 3.1 更好的性能</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 3.2 在整体替换时，能触发 Vue 的响应式</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br></div></div><h2 id="一、ref" tabindex="-1">一、ref() <a class="header-anchor" href="#一、ref" aria-label="Permalink to &quot;一、ref()&quot;">​</a></h2><ul><li>reactive() 不能为 string, number, boolean 类型声明响应式，是因为 js 中没有给这三种值引用数据类型</li><li>ref() 将传入参数的值包装为一个带 .value 属性的 ref 对象(将一个基本类型的值变成引用类型的值之后，就可以把这个属性赋值，解构，或者是当做函数的参数传递了)</li><li>之前觉得 ref 的 .value 是额外的负担，但是网上有一些说法 .value 能清楚的标识出哪些是响应式变量，哪些是普通 JS 变量</li><li>ref 不仅仅是<code>实现原始值的响应式方案</code>，还用来<code>解决响应式丢失问题</code></li></ul><h3 id="_1-1-ref-的使用" tabindex="-1">1.1 ref 的使用 <a class="header-anchor" href="#_1-1-ref-的使用" aria-label="Permalink to &quot;1.1 ref 的使用&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 1. 对象整个替换时，仍能保持响应式</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> state</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> ref</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">  foo: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  bar: [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">],</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  state.value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    foo: </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    bar: [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">],</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 2. ref 和 解构用法搭配</span></span>
<span class="line"><span style="color:#6A737D;">// 2.1 ref() 整个对象时，解构也不是很友好</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> state</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> ref</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">  foo: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  bar: [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">],</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> { foo, bar } </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> state.value;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  foo</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 原始数据类型值： 已经失去响应式</span></span>
<span class="line"><span style="color:#24292E;">  bar.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 引用数据类型值： 仍保留响应式</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 2.2 将 ref() 分组到普通的 JS 对象中，解构不会丢失响应式，但是 state 对象本身无响应性</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> state</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  foo: </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">  bar: </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">]),</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> { foo, bar } </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> state;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  foo.value</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// foo 和 state.foo 会保持同步</span></span>
<span class="line"><span style="color:#24292E;">  bar.value.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// bar 和 state.bar 会保持同步</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 3. 解构时使用 ref 或者 refs</span></span>
<span class="line"><span style="color:#6A737D;">// ! 这种写法，数据既能整个替换，又能解构使用。属于比较全能的用法</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> state</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> ref</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">  foo: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  bar: [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">],</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> { foo, bar } </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> toRefs</span><span style="color:#24292E;">(state.value);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  foo.value</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// foo 和 state.foo 会保持同步</span></span>
<span class="line"><span style="color:#24292E;">  bar.value.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// bar 和 state.bar 会保持同步</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br></div></div><h3 id="_1-2-解包" tabindex="-1">1.2 解包 <a class="header-anchor" href="#_1-2-解包" aria-label="Permalink to &quot;1.2 解包&quot;">​</a></h3>`,9)),n("ul",null,[n("li",null,[s[0]||(s[0]=l("模板解包：当 ref 在模板中作为")),s[1]||(s[1]=n("code",null,"顶层属性",-1)),l('(如果一个属性并不是顶层属性，可以使用解构的方式解出来)被访问时，它们会被自动"解包"，所以不需要使用 .value(若只是想展示数据那么无论是不是顶层对象都不需要.value, 只是说在'+r()+"语法中想把属性当做表达式计算时，只有顶层属性不需要加 .value)",1)]),s[2]||(s[2]=n("li",null,"非模版解包：当一个 ref 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现得和一般的属性一样(不需要使用 .value 来取值), 当 ref 被嵌套在响应式数组中时，不会被解包",-1))]),s[4]||(s[4]=a(`<h2 id="二、reactive" tabindex="-1">二、reactive() <a class="header-anchor" href="#二、reactive" aria-label="Permalink to &quot;二、reactive()&quot;">​</a></h2><ul><li>仅对<code>引用类型</code>有效(对象，数组，Set，Map)等。(string, number, boolean)等<code>原始类型</code>无效，Proxy 是基于<code>属性的访问</code>进行响应式跟踪的。所以只能对引用类型进行跟踪。</li></ul><h3 id="_2-1-reactive-的使用" tabindex="-1">2.1 reactive 的使用 <a class="header-anchor" href="#_2-1-reactive-的使用" aria-label="Permalink to &quot;2.1 reactive 的使用&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 1. 整个替换时，会失去响应式</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> state </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> reactive</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">  foo: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  bar: [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">],</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  state </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    foo: </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    bar: [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">],</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 2. 解构、将属性传递给函数时，原始数值类型值时，会失去响应式</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> state </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> reactive</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">  foo: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  bar: [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">],</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> { foo, bar } </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> state;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  foo</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 原始数据类型值： 已经失去响应式</span></span>
<span class="line"><span style="color:#24292E;">  bar.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 引用数据类型值： 仍保留响应式</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 3. 解构时使用 toRef 或者 toRefs</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> state </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> reactive</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">  foo: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  bar: [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">],</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> { foo, bar } </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> toRefs</span><span style="color:#24292E;">(state);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  foo.value</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// foo 和 state.foo 会保持同步</span></span>
<span class="line"><span style="color:#24292E;">  bar.value.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// bar 和 state.bar 会保持同步</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><h2 id="三、shallowref" tabindex="-1">三、shallowRef() <a class="header-anchor" href="#三、shallowref" aria-label="Permalink to &quot;三、shallowRef()&quot;">​</a></h2><h2 id="四、toref-torefs" tabindex="-1">四、toRef toRefs() <a class="header-anchor" href="#四、toref-torefs" aria-label="Permalink to &quot;四、toRef toRefs()&quot;">​</a></h2><p>TODO: 原理 TODO：实际应用</p>`,7))])}const f=p(c,[["render",t]]);export{m as __pageData,f as default};
