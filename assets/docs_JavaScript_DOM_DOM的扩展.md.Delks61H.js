import{_ as a,c as t,o as l,ag as i}from"./chunks/framework.BDwTZuFy.js";const m=JSON.parse('{"title":"DOM的扩展","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/DOM/DOM的扩展.md","filePath":"docs/JavaScript/DOM/DOM的扩展.md","lastUpdated":1712646874000}'),r={name:"docs/JavaScript/DOM/DOM的扩展.md"};function o(n,e,d,c,s,u){return l(),t("div",null,e[0]||(e[0]=[i('<h1 id="dom的扩展" tabindex="-1">DOM的扩展 <a class="header-anchor" href="#dom的扩展" aria-label="Permalink to &quot;DOM的扩展&quot;">​</a></h1><h2 id="焦点管理" tabindex="-1">焦点管理 <a class="header-anchor" href="#焦点管理" aria-label="Permalink to &quot;焦点管理&quot;">​</a></h2><ul><li>document.activeElement 属性 这个属性会引用当前获得焦点的元素，文档刚加载完时保留的是 body 的引用，文档加载时值为 null。</li><li>document.hasFocus() 方法 返回布尔值，该文档是否有焦点</li><li>获得焦点的方式：页面加载，用户输入和调用 Element.focus() 方法</li></ul><h2 id="readystate-属性" tabindex="-1">readyState 属性 <a class="header-anchor" href="#readystate-属性" aria-label="Permalink to &quot;readyState 属性&quot;">​</a></h2><ul><li>document.readyState 属性有两个值，指示文档是否已经加载完毕</li><li>正在加载文档时 loading</li><li>已经加载完文档 complete</li></ul><h2 id="兼容模式" tabindex="-1">兼容模式 <a class="header-anchor" href="#兼容模式" aria-label="Permalink to &quot;兼容模式&quot;">​</a></h2><ul><li>document.compatMode 属性有两个值</li><li>在标准模式下 CSS1Compat</li><li>混杂模式下 BackCompat</li></ul><h2 id="innertext-outertext" tabindex="-1">innerText outerText <a class="header-anchor" href="#innertext-outertext" aria-label="Permalink to &quot;innerText outerText&quot;">​</a></h2><ul><li>innerText 属性在读取时会读取元素的文档树中的所有文本</li><li>innerText 属性在设置值的时候，会先删除元素的所有子元素然后把文本插入进去当做文本节点。</li><li>outerText 和 innerText 使用方法差不多，在进行设置时会把元素自身删除，使用文本节点代替。不常用。</li><li>没有被 HTML5 规范收入</li></ul>',9)]))}const _=a(r,[["render",o]]);export{m as __pageData,_ as default};
