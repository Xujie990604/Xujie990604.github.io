import{_ as l,c as t,o as a,ag as i}from"./chunks/framework.BDwTZuFy.js";const p=JSON.parse('{"title":"页面的重绘和重排","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/浏览器渲染页面的过程/重排和重绘.md","filePath":"docs/JavaScript/浏览器渲染页面的过程/重排和重绘.md","lastUpdated":1735478813000}'),o={name:"docs/JavaScript/浏览器渲染页面的过程/重排和重绘.md"};function r(s,e,n,c,d,_){return a(),t("div",null,e[0]||(e[0]=[i('<h1 id="页面的重绘和重排" tabindex="-1">页面的重绘和重排 <a class="header-anchor" href="#页面的重绘和重排" aria-label="Permalink to &quot;页面的重绘和重排&quot;">​</a></h1><ul><li>重排：修改 DOM 引起 DOM 的几何尺寸变化(比如修改元素的宽、高或隐藏元素等)时，浏览器需要重新计算元素的几何属性(其他元素的几何属性和位置也会因此受到影响)，然后再将计算的结果绘制出来。这个过程就是回流(也叫重排)。</li><li>重绘：我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性(比如修改了颜色或背景色)时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式(跳过了上图所示的回流环节)。这个过程叫做重绘。</li><li>因为页面的 js 引擎线程和 GUI 线程是互斥的(不能一边改变 DOM，一边绘制 DOM)，所以重排和重绘的代价是昂贵的。</li></ul><h2 id="一、触发重排的方法" tabindex="-1">一、触发重排的方法 <a class="header-anchor" href="#一、触发重排的方法" aria-label="Permalink to &quot;一、触发重排的方法&quot;">​</a></h2><ul><li>分为两类一种是常见的写重排，一种是读重排</li><li>浏览器已经比较智能了，会在底层做一些优化，会将多个写操作合并在一起，进行批量更新。但是读操作会中断这个过程，从而造成额外的重排!!!!!</li></ul><ol><li>offsetTop offsetLeft scrollTop scrollLeft clientLeft clientHeight getComputedStyle() currentStyle()。这些属性虽然都是查看一些东西，但是浏览器为了保证数值的正确，会重新构建页面，然后返回最新的数值。</li><li>DOM.style = &quot;xxx&quot; 通过 style 来设置属性</li><li>添加或者删除可见的 DOM 元素。</li></ol><h2 id="二、-能够进行优化的方法" tabindex="-1">二、 能够进行优化的方法 <a class="header-anchor" href="#二、-能够进行优化的方法" aria-label="Permalink to &quot;二、 能够进行优化的方法&quot;">​</a></h2><ol><li>JS 层面的事情，JS 自己去处理，处理好了，再来找 DOM 打报告(Vue 使用了类似的原理来减少 DOM 操作)</li><li>多次 DOM.style = &quot;xxx&quot; 这种操作放在一起，浏览器会有策略合并改动之后再去重排(重绘)</li><li>一个需要有复杂变动的元素，在变动前设置 display：none 等变动结束之后再还原，这样只会触发两次重绘重排</li><li>一个经常会变动的动画，position 属性设为 absolute 或 fixed ，让它脱离文档流，因为浏览器绘制是按照图层来绘制的，当它自己拥有独立的图层时，每次绘制只涉及它自己，减少绘制量。(这个图层的概念应该就和 CSS 中的 层叠上下文 概念一致)(并不是说只要是重排就把整个页面全部重新绘制，分为全局重排和局部重排)(将复杂动画脱离文档流就是尽可能地让动画部分进行局部重排。不要影响到其他无关元素)</li></ol><p>TODO：学习浏览器的 Performance 便签，让读者真正看到重排，重绘的发现，以及使用优化方案后，重排，重绘的减少。并且附带上真实的数据情况 TODO：学习 CSS 文档流，层级绘制的概念。验证一下 DOM 脱离的文档流之后，是不是真的进行单独图层的绘制，而不必要绘制整个页面</p>',8)]))}const f=l(o,[["render",r]]);export{p as __pageData,f as default};
