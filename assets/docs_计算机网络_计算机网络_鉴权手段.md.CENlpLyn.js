import{_ as s,c as o,o as l,ag as e}from"./chunks/framework.BDwTZuFy.js";const h=JSON.parse('{"title":"鉴权手段","description":"","frontmatter":{},"headers":[],"relativePath":"docs/计算机网络/计算机网络/鉴权手段.md","filePath":"docs/计算机网络/计算机网络/鉴权手段.md","lastUpdated":1758679193000}'),n={name:"docs/计算机网络/计算机网络/鉴权手段.md"};function i(t,a,r,p,c,d){return l(),o("div",null,a[0]||(a[0]=[e(`<h1 id="鉴权手段" tabindex="-1">鉴权手段 <a class="header-anchor" href="#鉴权手段" aria-label="Permalink to &quot;鉴权手段&quot;">​</a></h1><h2 id="一、session-cookie-经典方案" tabindex="-1">一、Session + Cookie(经典方案) <a class="header-anchor" href="#一、session-cookie-经典方案" aria-label="Permalink to &quot;一、Session + Cookie(经典方案)&quot;">​</a></h2><ul><li>传统的、<code>有状态</code> 的认证方式</li></ul><h3 id="_1-1工作流程" tabindex="-1">1.1工作流程 <a class="header-anchor" href="#_1-1工作流程" aria-label="Permalink to &quot;1.1工作流程&quot;">​</a></h3><ol><li>登录: 浏览器提交用户名和密码到后端。</li><li>验证: 后端验证凭证，验证成功后，在服务器内存或数据库（如 Redis）中创建一个 Session 对象，用于存储用户信息。这个 Session 有一个唯一的 ID，即 Session ID。</li><li>种下 Cookie: 后端通过 Set-Cookie HTTP 响应头，将这个 Session ID 发送给浏览器。</li><li>自动携带: 浏览器会自动保存这个 Cookie。在后续的每一次请求中，浏览器都会自动将这个 Cookie 附加在 HTTP 请求头中发送给后端。</li><li>身份识别: 后端收到请求后，从 Cookie 中读取 Session ID，然后根据这个 ID 找到对应的 Session 对象，从而得知当前请求是哪个用户发来的。</li></ol><h3 id="_1-2优点" tabindex="-1">1.2优点 <a class="header-anchor" href="#_1-2优点" aria-label="Permalink to &quot;1.2优点&quot;">​</a></h3><ol><li>机制简单, 浏览器支持良好，能自动处理 Cookie 的发送</li></ol><h3 id="_1-3缺点" tabindex="-1">1.3缺点 <a class="header-anchor" href="#_1-3缺点" aria-label="Permalink to &quot;1.3缺点&quot;">​</a></h3><ol><li>移动端支持不佳，Cookie 在移动端的支持较差，且容易被拦截。</li><li>有状态，难以扩展：每个用户的 Session 信息都需要存储在服务端，当用户量巨大时，对服务器内存/数据库是巨大开销。在分布式/集群部署时，需要处理 Session 同步或共享问题。</li><li>CSRF风险</li></ol><h2 id="二、jwt" tabindex="-1">二、JWT <a class="header-anchor" href="#二、jwt" aria-label="Permalink to &quot;二、JWT&quot;">​</a></h2><ul><li>JWT 的全称是 JSON Web Token</li><li>理论上如果被其他人拿到了 JWT，他就可以伪造请求。所以使用 HTTPS 通信信道加密来保证 JWT 的安全性。</li></ul><h3 id="_2-1-jwt结构" tabindex="-1">2.1 JWT结构 <a class="header-anchor" href="#_2-1-jwt结构" aria-label="Permalink to &quot;2.1 JWT结构&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// Header: 包含 JWT 的类型和加密算法</span></span>
<span class="line"><span style="color:#24292E;">{ </span><span style="color:#032F62;">&quot;alg&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;HS256&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;typ&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;JWT&quot;</span><span style="color:#24292E;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Payload: 包含 JWT 的数据</span></span>
<span class="line"><span style="color:#24292E;">{ </span><span style="color:#032F62;">&quot;sub&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;1234567890&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;name&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;John Doe&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;iat&quot;</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">1516239022</span><span style="color:#24292E;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Signature: 包含 JWT 的签名</span></span>
<span class="line"><span style="color:#6F42C1;">HMACSHA256</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">base64UrlEncode</span><span style="color:#24292E;">(header) </span><span style="color:#D73A49;">+</span><span style="color:#032F62;"> &quot;.&quot;</span><span style="color:#D73A49;"> +</span><span style="color:#6F42C1;"> base64UrlEncode</span><span style="color:#24292E;">(payload), secret)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_2-2-工作流程" tabindex="-1">2.2 工作流程 <a class="header-anchor" href="#_2-2-工作流程" aria-label="Permalink to &quot;2.2 工作流程&quot;">​</a></h3><ol><li>登录: 用户提交用户名密码。</li><li>签发 Token: 后端验证成功后，生成一个包含用户标识和过期时间的 JWT，用服务器密钥进行签名，然后将整个 JWT 字符串返回给前端。</li><li>前端存储: 前端（JS）收到 JWT后，手动将其存储在某个地方，常见的是 localStorage、sessionStorage 或 HttpOnly Cookie。</li><li>手动携带: 在后续的每一次 API 请求中，前端都需要手动将 JWT 放在 HTTP 请求头的 Authorization 字段中，通常以 Bearer <code>&lt;token&gt;</code> 的形式。</li><li>身份识别: 后端收到请求后，从 Authorization 头中取出 JWT，用同一个密钥验证其签名是否有效。如果签名有效，后端就完全信任 Payload 中的信息，从而识别用户身份。</li></ol><h3 id="_2-3-优点" tabindex="-1">2.3 优点 <a class="header-anchor" href="#_2-3-优点" aria-label="Permalink to &quot;2.3 优点&quot;">​</a></h3><ol><li>无状态，易于扩展: 服务器不需要存储任何 Session 信息，每次请求都是自包含的。极利于分布式部署和水平扩展。</li><li>跨平台/跨域友好: Token 可以轻松地在 Web、移动 App、微服务之间传递。</li><li>功能强大: Payload 可以携带一些非敏感的业务数据（如角色），避免了额外查询。</li></ol><h3 id="_2-4-缺点" tabindex="-1">2.4 缺点 <a class="header-anchor" href="#_2-4-缺点" aria-label="Permalink to &quot;2.4 缺点&quot;">​</a></h3><ol><li>令牌吊销困难: 由于无状态，一旦签发，令牌在过期前就一直有效。</li></ol>`,19)]))}const b=s(n,[["render",i]]);export{h as __pageData,b as default};
