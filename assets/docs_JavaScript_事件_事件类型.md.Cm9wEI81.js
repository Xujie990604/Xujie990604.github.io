import{_ as a,c as l,o,ag as i}from"./chunks/framework.BDwTZuFy.js";const m=JSON.parse('{"title":"事件类型","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/事件/事件类型.md","filePath":"docs/JavaScript/事件/事件类型.md","lastUpdated":1712646874000}'),r={name:"docs/JavaScript/事件/事件类型.md"};function t(u,e,n,s,d,h){return o(),l("div",null,e[0]||(e[0]=[i('<h1 id="事件类型" tabindex="-1">事件类型 <a class="header-anchor" href="#事件类型" aria-label="Permalink to &quot;事件类型&quot;">​</a></h1><h2 id="ui事件" tabindex="-1">UI事件 <a class="header-anchor" href="#ui事件" aria-label="Permalink to &quot;UI事件&quot;">​</a></h2><h3 id="load事件" tabindex="-1">load事件 <a class="header-anchor" href="#load事件" aria-label="Permalink to &quot;load事件&quot;">​</a></h3><ul><li>当页面完全加载完毕之后(包括所有的图像，js文件，css外部文件)就会触发window中的load事件。</li><li>可以通过js的方式来绑定load事件，也可以直接把事件写在<code>&lt;body&gt;</code>元素上当做特性。</li><li>一般来说在window上的任何事件都能在<code>&lt;body&gt;</code>通过特性来实现。因为在HTML中无法访问window元素，但是还是建议使用js的方式来绑定load事件。</li><li>图像也可以用来绑定load事件。重要的是在指定src之前绑定事件，只要是设置了src就会下载。</li><li><code>&lt;script&gt;</code>也可以用来绑定load事件。src和事件的顺序不重要，设置了src并添加到文档中才会下载。</li></ul><h3 id="unload事件" tabindex="-1">unload事件 <a class="header-anchor" href="#unload事件" aria-label="Permalink to &quot;unload事件&quot;">​</a></h3><ul><li>在页面完全被卸载之后触发</li><li>使用这个事件的最多情况是清除引用。</li><li>注意事件是在页面被卸载之后触发的，所以在此时进行元素和样式的访问就会错误。</li></ul><h3 id="resize事件" tabindex="-1">resize事件 <a class="header-anchor" href="#resize事件" aria-label="Permalink to &quot;resize事件&quot;">​</a></h3><ul><li>在当浏览器的窗口被调整到一个新的高度或者宽度时，触发。</li><li>浏览器窗口在最大化或者最小化也会触发resize事件。</li><li>不同的浏览器有不同的触发机制，有的会随着窗口的变化不断的触发，所以尽量不要再resize事件中填写大量的计算代码。</li></ul><h3 id="scroll事件" tabindex="-1">scroll事件 <a class="header-anchor" href="#scroll事件" aria-label="Permalink to &quot;scroll事件&quot;">​</a></h3><ul><li>scroll事件是在window对象上发生的，但是它实际表示的是页面中元素的变化。</li><li>与resize事件类似，也会在滚动期间被重复触发，注意保持事件中的代码尽量简洁。</li></ul><h2 id="焦点事件" tabindex="-1">焦点事件 <a class="header-anchor" href="#焦点事件" aria-label="Permalink to &quot;焦点事件&quot;">​</a></h2><ul><li><p>配合着document.hasFocus()方法，和document.activeElement属性配合使用，能够知晓用户在页面上的行踪</p></li><li><p>blur在元素失去焦点的时候触发，这个事件不会冒泡。</p></li><li><p>focus事件在元素获得焦点的时候就会触发，这个事件不会冒泡</p></li><li><p>focusin事件在元素获得焦点的时候触发，这个事件冒泡；</p></li><li><p>focusout事件在元素失去焦点的时候触发，这个事件冒泡；</p></li></ul><h2 id="鼠标事件与滚轮事件" tabindex="-1">鼠标事件与滚轮事件 <a class="header-anchor" href="#鼠标事件与滚轮事件" aria-label="Permalink to &quot;鼠标事件与滚轮事件&quot;">​</a></h2><h3 id="click" tabindex="-1">click <a class="header-anchor" href="#click" aria-label="Permalink to &quot;click&quot;">​</a></h3><ul><li>鼠标点击完成的完整过程 会在mousedown 和 mouseup全部触发之后触发。</li><li>在用户点击住鼠标按钮或者回车键触发。</li></ul><h3 id="dblclick" tabindex="-1">dblclick <a class="header-anchor" href="#dblclick" aria-label="Permalink to &quot;dblclick&quot;">​</a></h3><ul><li>双击事件</li></ul><h3 id="mousedown" tabindex="-1">mousedown <a class="header-anchor" href="#mousedown" aria-label="Permalink to &quot;mousedown&quot;">​</a></h3><ul><li>鼠标点击下去的一瞬间</li></ul><h3 id="mouseup" tabindex="-1">mouseup <a class="header-anchor" href="#mouseup" aria-label="Permalink to &quot;mouseup&quot;">​</a></h3><ul><li>鼠标点击下去了抬起来那一瞬间</li></ul><h3 id="mouseover" tabindex="-1">mouseover <a class="header-anchor" href="#mouseover" aria-label="Permalink to &quot;mouseover&quot;">​</a></h3><ul><li>待定 支持冒泡</li></ul><h3 id="mouseout" tabindex="-1">mouseout <a class="header-anchor" href="#mouseout" aria-label="Permalink to &quot;mouseout&quot;">​</a></h3><ul><li>待定</li></ul><h3 id="onmouseenter" tabindex="-1">onmouseenter <a class="header-anchor" href="#onmouseenter" aria-label="Permalink to &quot;onmouseenter&quot;">​</a></h3><ul><li>鼠标移到内容区 不支持事件冒泡</li></ul><h3 id="onmouseleave" tabindex="-1">onmouseleave <a class="header-anchor" href="#onmouseleave" aria-label="Permalink to &quot;onmouseleave&quot;">​</a></h3><ul><li>鼠标移出内容区 不冒泡</li></ul><h3 id="onmousemove" tabindex="-1">onmousemove <a class="header-anchor" href="#onmousemove" aria-label="Permalink to &quot;onmousemove&quot;">​</a></h3><ul><li>在目标元素里鼠标坐标变化一次就执行一次函数</li></ul><h3 id="contextmenu" tabindex="-1">contextmenu <a class="header-anchor" href="#contextmenu" aria-label="Permalink to &quot;contextmenu&quot;">​</a></h3><ul><li>右键取消菜单(不用来监听右键)</li></ul><h3 id="判断左右键" tabindex="-1">判断左右键 <a class="header-anchor" href="#判断左右键" aria-label="Permalink to &quot;判断左右键&quot;">​</a></h3><ul><li>mousedown mouseup事件的event对象的button属性里面存在三个值，0表示主鼠标键，1表示鼠标滚轮，2表示次鼠标按钮。</li></ul><p>根据e.button来判断左右键(能识别左右键 )</p><p>w3c标准规定：click事件只能监听左键，只能通过onmousedown onmouseup 来判断鼠标键</p><h2 id="键盘事件" tabindex="-1">键盘事件 <a class="header-anchor" href="#键盘事件" aria-label="Permalink to &quot;键盘事件&quot;">​</a></h2><h3 id="keydown" tabindex="-1">keydown <a class="header-anchor" href="#keydown" aria-label="Permalink to &quot;keydown&quot;">​</a></h3><ul><li>当用户按下键盘上的任意键时触发。按住不放的话，会重复触发。</li><li>keydown能监听所有按键 event对象上有keyCode属性。按键对应的数字值。</li></ul><h3 id="keypress" tabindex="-1">keypress <a class="header-anchor" href="#keypress" aria-label="Permalink to &quot;keypress&quot;">​</a></h3><ul><li>当用户按下键盘上的(字符键)时触发，按住不放的话，会重复触发。</li><li>keypress只能监听到字符类按键（操作类不行） 有charCode （返回ASCII码，能通过方法返回字符）检测字符类按键很准，能区别大小写</li><li>谨慎使用keypress事件，有些浏览器上的keypress事件也会触发click事件(DOM编程上说的可能过时了)</li></ul><h3 id="keyup" tabindex="-1">keyup <a class="header-anchor" href="#keyup" aria-label="Permalink to &quot;keyup&quot;">​</a></h3><ul><li>在用户释放键盘上的键时触发。</li></ul><h2 id="文本类操作事件" tabindex="-1">文本类操作事件 <a class="header-anchor" href="#文本类操作事件" aria-label="Permalink to &quot;文本类操作事件&quot;">​</a></h2><ul><li>change在input失去焦点并且状态有改变之后，触发。与blur很类似，但是change在输入框内的值未改变的时候并不会触发。</li><li>input在输入框输入的时候实时响应并触发</li></ul>',46)]))}const b=a(r,[["render",t]]);export{m as __pageData,b as default};
