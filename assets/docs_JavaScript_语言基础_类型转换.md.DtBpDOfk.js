import{_ as a,c as n,o as l,ag as e}from"./chunks/framework.BDwTZuFy.js";const b=JSON.parse('{"title":"类型的转换(JS 的糟粕精髓所在)","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/语言基础/类型转换.md","filePath":"docs/JavaScript/语言基础/类型转换.md","lastUpdated":1735478813000}'),o={name:"docs/JavaScript/语言基础/类型转换.md"};function p(r,s,t,i,c,u){return l(),n("div",null,s[0]||(s[0]=[e(`<h1 id="类型的转换-js-的糟粕精髓所在" tabindex="-1">类型的转换(JS 的糟粕精髓所在) <a class="header-anchor" href="#类型的转换-js-的糟粕精髓所在" aria-label="Permalink to &quot;类型的转换(JS 的糟粕精髓所在)&quot;">​</a></h1><ul><li>尽量避免在 JS 中使用隐式类型转换</li><li>使用 === !== 强等于操作符来代替 == !=, 避免隐式类型转换的发生</li></ul><h2 id="一、显式类型转换" tabindex="-1">一、显式类型转换 <a class="header-anchor" href="#一、显式类型转换" aria-label="Permalink to &quot;一、显式类型转换&quot;">​</a></h2><h3 id="_1-1-number-any" tabindex="-1">1.1 Number(any) <a class="header-anchor" href="#_1-1-number-any" aria-label="Permalink to &quot;1.1 Number(any)&quot;">​</a></h3><ul><li>Number() <code>尝试着</code>将<code>任何数据类型</code>转换为<code>数字类型</code>(能转化为数字就转化为数字，无法转化为数字就转化为 NAN)(<code>没有砍断原则</code>)</li></ul><ol><li>null number: 0</li><li>[123] number: 123</li><li>[123, 2334] number: NAN</li><li>obj、function、NAN、undefined 转化完之后是 NAN</li></ol><ul><li>字符串的 number() 转化</li></ul><ol><li>如果只包含数字，那么转化为 10 进制数值，会忽略前导零。</li><li>字符串中包含有效的浮点格式，就转化为浮点数</li><li>如果是十六进制，就转化为 10 进制</li><li>如果字符串是空的就转化为零。</li><li>其他格式全部转化为 NAN</li></ol><h3 id="_1-2-parseint-string-radix" tabindex="-1">1.2 parseInt(string, radix?) <a class="header-anchor" href="#_1-2-parseint-string-radix" aria-label="Permalink to &quot;1.2 parseInt(string, radix?)&quot;">​</a></h3><ol><li>用于把<code>字符串</code>转化为整形数值</li><li>parseInt() 转换时，更多的是看是否符合<code>数值模式</code>，会忽略字符串前面的空格，直至找到第一个非空格字符</li><li>砍断原则: 从数据首位开始看一直到非数字类型截止 例如 100px 转换之后变成 100</li><li>不指定进制的话，意味着让<code>引擎自己决定</code>按照哪种进制解析字符串，所以推荐指定进制</li></ol><h3 id="_1-3-parsefloat-string" tabindex="-1">1.3 parseFloat(string) <a class="header-anchor" href="#_1-3-parsefloat-string" aria-label="Permalink to &quot;1.3 parseFloat(string)&quot;">​</a></h3><ol><li>返回值：浮点数(只会按照十进制进行解析)</li><li>砍断原则: 同上</li><li>只会识别一个小数点，22.45.21返回22.45</li></ol><h3 id="_1-4-string-any" tabindex="-1">1.4 String(any) <a class="header-anchor" href="#_1-4-string-any" aria-label="Permalink to &quot;1.4 String(any)&quot;">​</a></h3><ul><li>String()把数据类型转换为字符串类型</li></ul><h3 id="_1-5-xxx-tostring" tabindex="-1">1.5 xxx.toString() <a class="header-anchor" href="#_1-5-xxx-tostring" aria-label="Permalink to &quot;1.5 xxx.toString()&quot;">​</a></h3><ul><li><code>undefined 和 null 不能用 toString()</code>， 因为这两个没有原型</li><li>num.toString(redix) 把 num 转换为 <code>redix</code> 进制的数字，再转换为字符串</li></ul><h3 id="_1-6-boolean-any" tabindex="-1">1.6 Boolean(any) <a class="header-anchor" href="#_1-6-boolean-any" aria-label="Permalink to &quot;1.6 Boolean(any)&quot;">​</a></h3><ul><li>转换值为 false 的值: <code>false</code> <code>&quot;&quot;</code> <code>0</code> <code>NAN</code> <code>undefined</code> <code>null</code></li></ul><h2 id="二、隐式类型转换" tabindex="-1">二、隐式类型转换 <a class="header-anchor" href="#二、隐式类型转换" aria-label="Permalink to &quot;二、隐式类型转换&quot;">​</a></h2><ol><li>isNAN(&quot;num&quot;) 包含一个隐含的过程 先进行 Number(num) 操作然后再 isNAN(Number(num));</li><li>++/--(自增自减运算符) +/-(一元正负) 都会调用 Number() -*/% 都会调用 Number（）</li><li>&lt; &gt; &lt;= &gt;= 有数字相比较的就会隐式转换为数字</li><li>当加号<code>+</code>两端有一个 string 类型数字时，就会调用 String()</li><li>&amp;&amp; || 与或在决定返回值时是看表达式的布尔值为真或者为假 逻辑非 !(转换为布尔类型，在取反)</li><li>== != 有隐式类型转换、不发生类型转换的 === !==</li></ol><h3 id="_2-1-对象的隐式类型转换-只需要知道有这样一个东西-不需要背规则" tabindex="-1">2.1 对象的隐式类型转换(只需要知道有这样一个东西，不需要背规则) <a class="header-anchor" href="#_2-1-对象的隐式类型转换-只需要知道有这样一个东西-不需要背规则" aria-label="Permalink to &quot;2.1 对象的隐式类型转换(只需要知道有这样一个东西，不需要背规则)&quot;">​</a></h3><ul><li>需要转化为 number 类型</li></ul><ol><li>先调用 obj 的 valueOf() 方法，如果为原始值，则 return, 否则进行第 2 步</li><li>调用 obj 的 toString() 方法，如果为原始值，则 return, 否则第 3 步</li><li>抛出 TypeError 异常</li></ol><ul><li>需要转化为 string 类型</li></ul><ol><li>先调用 obj 的 toString() 方法， 如果为原始值，则 return, 否则进行第 2 步</li><li>调用 obj 的 valueOf() 方法，如果为原始值，则 return, 否则第 3 步</li><li>抛出 TypeError 异常</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#24292E;">[] </span><span style="color:#D73A49;">==</span><span style="color:#005CC5;"> 0</span><span style="color:#6A737D;">    //true</span></span>
<span class="line"><span style="color:#24292E;">[].</span><span style="color:#6F42C1;">valueOf</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 得到空字符串</span></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">==</span><span style="color:#005CC5;"> 0</span><span style="color:#6A737D;">  //成立</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">!</span><span style="color:#24292E;">[] </span><span style="color:#D73A49;">==</span><span style="color:#005CC5;"> 0</span><span style="color:#6A737D;">  //true</span></span>
<span class="line"><span style="color:#6A737D;">//逻辑非，先把表达式转换为布尔值在取反。[]不在那六种转换完为假的数据类型中。所以转换后为false</span></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">false</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">==</span><span style="color:#005CC5;"> 0</span><span style="color:#6A737D;"> //成立</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">[] </span><span style="color:#D73A49;">==</span><span style="color:#D73A49;"> !</span><span style="color:#24292E;">[]  </span><span style="color:#6A737D;">//true</span></span>
<span class="line"><span style="color:#24292E;">[].</span><span style="color:#6F42C1;">valueOf</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">//得到空字符串</span></span>
<span class="line"><span style="color:#6A737D;">//逻辑非，先把表达式转换为布尔值在取反。[]不在那六种转换完为假的数据类型中。所以转换后为false</span></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">==</span><span style="color:#6F42C1;"> Number</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">false</span><span style="color:#24292E;">)  </span><span style="color:#6A737D;">//成立</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">{} </span><span style="color:#D73A49;">==</span><span style="color:#D73A49;"> !</span><span style="color:#24292E;">{}  </span><span style="color:#6A737D;">//false</span></span>
<span class="line"><span style="color:#24292E;">{}.</span><span style="color:#6F42C1;">valueOf</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">//得到字符串[object,Object]</span></span>
<span class="line"><span style="color:#6A737D;">//!{} 先把表达式转换为布尔值在取反。{} 不在那六种转换完为假的数据类型中。所以转换后为false</span></span>
<span class="line"><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">([object,Object]) </span><span style="color:#D73A49;">==</span><span style="color:#6F42C1;"> Number</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">false</span><span style="color:#24292E;">)  </span><span style="color:#6A737D;">//不成立</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">[] </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> [] </span><span style="color:#6A737D;">//false</span></span>
<span class="line"><span style="color:#24292E;">{} </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> {} </span><span style="color:#6A737D;">//false</span></span>
<span class="line"><span style="color:#6A737D;">//引用数据存储在堆里，比较的是地址。所以不成立。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div>`,26)]))}const y=a(o,[["render",p]]);export{b as __pageData,y as default};
