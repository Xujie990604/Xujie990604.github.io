import{_ as e,c as s,o as l,ag as n}from"./chunks/framework.BDwTZuFy.js";const h=JSON.parse('{"title":"Vue 中事件的监听","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Vue/Vue官方文档解读/事件的监听.md","filePath":"docs/Vue/Vue官方文档解读/事件的监听.md","lastUpdated":1734874907000}'),t={name:"docs/Vue/Vue官方文档解读/事件的监听.md"};function o(r,a,i,p,c,d){return l(),s("div",null,a[0]||(a[0]=[n(`<h1 id="vue-中事件的监听" tabindex="-1">Vue 中事件的监听 <a class="header-anchor" href="#vue-中事件的监听" aria-label="Permalink to &quot;Vue 中事件的监听&quot;">​</a></h1><p>内联事件处理器：事件被触发时执行的内联 JavaScript 语句。 方法事件处理器：一个指向组件上定义的方法的属性名或是路径。</p><h2 id="直接在-dom-中监听事件" tabindex="-1">直接在 DOM 中监听事件 <a class="header-anchor" href="#直接在-dom-中监听事件" aria-label="Permalink to &quot;直接在 DOM 中监听事件&quot;">​</a></h2><ul><li>无需再 js 中手动绑定事件，代码可以是纯粹的逻辑，和 DOM 解耦</li><li>当一个视图模型被销毁时，所有的事件处理器都会被自动删除。</li></ul><h2 id="二、参数问题" tabindex="-1">二、参数问题 <a class="header-anchor" href="#二、参数问题" aria-label="Permalink to &quot;二、参数问题&quot;">​</a></h2><h3 id="_2-1-方法事件处理器" tabindex="-1">2.1 方法事件处理器 <a class="header-anchor" href="#_2-1-方法事件处理器" aria-label="Permalink to &quot;2.1 方法事件处理器&quot;">​</a></h3><ol><li>事件函数没有定义形参，在函数体内直接使用 event 就能访问到 event 事件对象</li><li>事件函数只定义了一个形参，在函数体中使用这个形参就是 event 事件对象</li></ol><h3 id="_2-2-内联事件处理器" tabindex="-1">2.2 内联事件处理器 <a class="header-anchor" href="#_2-2-内联事件处理器" aria-label="Permalink to &quot;2.2 内联事件处理器&quot;">​</a></h3><ol><li>在事件函数的实参中，使用 <code>$event</code> 显式的声明</li><li>在事件函数中没有用 <code>$event</code> 显式的定义实参，则不需要在事件函数中定义形参，直接在函数体中使用 event 来访问事件对象。</li></ol><h3 id="_2-3-即需要事件对象又需要自定义参数" tabindex="-1">2.3 即需要事件对象又需要自定义参数 <a class="header-anchor" href="#_2-3-即需要事件对象又需要自定义参数" aria-label="Permalink to &quot;2.3 即需要事件对象又需要自定义参数&quot;">​</a></h3><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 使用特殊的 $event 变量 --&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#6F42C1;"> class</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;header&quot;</span><span style="color:#6F42C1;"> @click</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;btnClick(123, $event)&quot;</span><span style="color:#24292E;">&gt;ViewFirst组件&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">&lt;!-- 使用内联箭头函数--&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#6F42C1;"> class</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;header&quot;</span><span style="color:#6F42C1;"> @click</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;(event) =&gt; btnClick(123, event)&quot;</span><span style="color:#24292E;">&gt;ViewFirst组件&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="native-修饰符" tabindex="-1">.native 修饰符 <a class="header-anchor" href="#native-修饰符" aria-label="Permalink to &quot;.native 修饰符&quot;">​</a></h2><ul><li>组件不能和 DOM 一样直接的添加原生的事件。要加上.native 修饰符</li><li>用来监听组件根元素的原生事件</li></ul>`,13)]))}const b=e(t,[["render",o]]);export{h as __pageData,b as default};
