import{_ as s,c as r,o as n,ag as l}from"./chunks/framework.BDwTZuFy.js";const d=JSON.parse('{"title":"try catch","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/独立知识点/try catch.md","filePath":"docs/JavaScript/独立知识点/try catch.md","lastUpdated":1756718577000}'),e={name:"docs/JavaScript/独立知识点/try catch.md"};function t(o,a,c,p,i,h){return n(),r("div",null,a[0]||(a[0]=[l(`<h1 id="try-catch" tabindex="-1">try catch <a class="header-anchor" href="#try-catch" aria-label="Permalink to &quot;try catch&quot;">​</a></h1><p>TODO： 为什么在 JS 中很少使用，是因为不好用吗？还是因为没有合适的场景</p><ul><li>try catch 块的优点是，当 try 中的代码有警告的话， 代码不会直接死掉而是可以在 catch 中尝试解决这个错误</li><li>还可以使用 throw 来自定义错误</li></ul><h2 id="error-name的六种对应的信息" tabindex="-1">Error.name的六种对应的信息 <a class="header-anchor" href="#error-name的六种对应的信息" aria-label="Permalink to &quot;Error.name的六种对应的信息&quot;">​</a></h2><ol><li>EvalError: eval()的使用和定义不一致</li><li>RangeError： 数值越界</li><li>ReferenceError：非法或不能识别的引用数值</li><li>SyntaxError：发生语法解析错误</li><li>TypeError：操作数类型错误</li><li>URLError：URL处理函数使用不当</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">   ...</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (e) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(e.name </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> e.message);</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;无论有没有错误都会执行&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="throw" tabindex="-1">throw <a class="header-anchor" href="#throw" aria-label="Permalink to &quot;throw&quot;">​</a></h2><p>TODO： throw 的对象不能随意书写，需要写一个错误类，规定好错误对象的类型 TODO： throw 不仅可以在 try catch 中使用，也可以用于接口异常</p><ul><li>throw 错误的时候，可以直接 throw(&quot;...&quot;), 也可以 throw 一个 Error 对象(throw New Error(&quot;...&quot;))</li></ul><h2 id="注意点" tabindex="-1">注意点 <a class="header-anchor" href="#注意点" aria-label="Permalink to &quot;注意点&quot;">​</a></h2><ul><li>try catch 只会对运行时的 error 有效， 如果代码包含语法的错误，try catch 将会无法正常工作</li><li>try 中如果包含了计划要执行的函数， 例如 setTimeout 里面的错误不会被捕捉到(异步的错误不会被捕获到)</li></ul>`,11)]))}const u=s(e,[["render",t]]);export{d as __pageData,u as default};
