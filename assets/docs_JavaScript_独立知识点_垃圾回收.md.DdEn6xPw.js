import{_ as e,c as l,o,ag as i}from"./chunks/framework.BDwTZuFy.js";const _=JSON.parse('{"title":"垃圾回收(GC)","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/独立知识点/垃圾回收.md","filePath":"docs/JavaScript/独立知识点/垃圾回收.md","lastUpdated":1748684767000}'),t={name:"docs/JavaScript/独立知识点/垃圾回收.md"};function d(c,a,r,h,n,s){return o(),l("div",null,a[0]||(a[0]=[i('<h1 id="垃圾回收-gc" tabindex="-1">垃圾回收(GC) <a class="header-anchor" href="#垃圾回收-gc" aria-label="Permalink to &quot;垃圾回收(GC)&quot;">​</a></h1><h2 id="一、栈内存和堆内存" tabindex="-1">一、栈内存和堆内存 <a class="header-anchor" href="#一、栈内存和堆内存" aria-label="Permalink to &quot;一、栈内存和堆内存&quot;">​</a></h2><h3 id="_1-1-栈内存" tabindex="-1">1.1 栈内存 <a class="header-anchor" href="#_1-1-栈内存" aria-label="Permalink to &quot;1.1 栈内存&quot;">​</a></h3><ul><li>栈数据结构: 后进先出</li><li>JS 中栈内存：主要用于存储 <code>执行上下文</code>。包括函数调用的参数、局部变量、函数的执行环境</li><li>栈内存特点：栈内存是一段<code>连续的内存空间</code>、分配<code>相对固定大小</code>的内存空间、并由系统自动释放</li><li>栈内存的性能：栈内存的<code>访问</code>和<code>操作</code>速度都<code>非常快</code></li><li>栈空间优化：通过<code>迭代</code>替代递归，或者使用<code>尾递归</code>优化 // TODO: 添加对应内容</li></ul><h3 id="_1-2-堆内存" tabindex="-1">1.2 堆内存 <a class="header-anchor" href="#_1-2-堆内存" aria-label="Permalink to &quot;1.2 堆内存&quot;">​</a></h3><ul><li>JS 中堆内存：主要用于存储<code>复杂对象</code></li><li>堆内存特点：堆内存是一大块内存空间、<code>动态分配</code>内存空间、内存空间<code>不连续</code>、不会自动释放空间</li><li>堆内存的性能：堆内存的访问速度较慢</li><li>闭包引用的变量：当一个局部变量被当前函数之外的其他函数所引用(也就是发生了逃逸），此时这个局部变量就<code>不能随着当前函数的返回而被回收</code>，那么这个变量就必须储存在堆内存中</li></ul><h2 id="二、内存管理的过程" tabindex="-1">二、内存管理的过程 <a class="header-anchor" href="#二、内存管理的过程" aria-label="Permalink to &quot;二、内存管理的过程&quot;">​</a></h2><ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放\\归还</li></ol><ul><li>在 C 等底层语言中，1，2，3都是明确的</li><li>在 JavaScript 等高级语言中，只有 2 是明确的。 1 (在声明变量时系统自动分配内存) 3 (系统使用垃圾回收算法来清除)</li></ul><h2 id="三、垃圾清除算法" tabindex="-1">三、垃圾清除算法 <a class="header-anchor" href="#三、垃圾清除算法" aria-label="Permalink to &quot;三、垃圾清除算法&quot;">​</a></h2><h3 id="_3-1-引用计数垃圾回收" tabindex="-1">3.1 引用计数垃圾回收 <a class="header-anchor" href="#_3-1-引用计数垃圾回收" aria-label="Permalink to &quot;3.1 引用计数垃圾回收&quot;">​</a></h3><ul><li>初级的垃圾收集算法。此算法把 <code>对象是否不再需要</code> 简化定义为 <code>对象有没有其他对象引用到它</code> 。</li><li>如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收</li><li>缺点: 无法解决循环引用问题</li></ul><h3 id="_3-2-标记清除算法" tabindex="-1">3.2 标记清除算法 <a class="header-anchor" href="#_3-2-标记清除算法" aria-label="Permalink to &quot;3.2 标记清除算法&quot;">​</a></h3><ul><li>这个算法把 <code>对象是否不再需要</code> 简化定义为 <code>对象是否可以获得</code>。</li><li>这个算法假定设置一个叫做根(root)的对象(在 Javascript 里，根是 window)。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象…… 。垃圾回收器将找到所有<code>可以获得的对象</code>和收集所有<code>不能获得的对象</code></li><li>缺点：那些无法从根对象查询到的对象都将被清除，但是场景很少</li></ul><h3 id="新生代和老生代" tabindex="-1">新生代和老生代 <a class="header-anchor" href="#新生代和老生代" aria-label="Permalink to &quot;新生代和老生代&quot;">​</a></h3><p>TODO：补充相关概念</p><h2 id="四、优化垃圾的性能" tabindex="-1">四、优化垃圾的性能 <a class="header-anchor" href="#四、优化垃圾的性能" aria-label="Permalink to &quot;四、优化垃圾的性能&quot;">​</a></h2><ol><li>垃圾回收程序会周期性运行，并且开始垃圾回收的时机是不可控的，垃圾回收会明显拖慢渲染速度和渲染帧率</li></ol><h3 id="_4-1-如何配合-v8-来实现更好的-gc" tabindex="-1">4.1 如何配合 V8 来实现更好的 GC <a class="header-anchor" href="#_4-1-如何配合-v8-来实现更好的-gc" aria-label="Permalink to &quot;4.1 如何配合 V8 来实现更好的 GC&quot;">​</a></h3><h4 id="解除引用" tabindex="-1">解除引用 <a class="header-anchor" href="#解除引用" aria-label="Permalink to &quot;解除引用&quot;">​</a></h4><ol><li>执行代码时只保留必要的数据，如果数据不再需要，那么把它设置为 <code>null</code></li><li>注意：解除引用并不会触发垃圾回收程序，只是确保变量能在下一次垃圾回收时被回收</li><li>适用范围：适用于全局变量和全局变量的属性，因为局部变量的值会在超过作用域后被自动解除引用</li></ol><h4 id="使用-const-let" tabindex="-1">使用 const let <a class="header-anchor" href="#使用-const-let" aria-label="Permalink to &quot;使用 const let&quot;">​</a></h4><ol><li>因为这两个都是块级作用域，会让垃圾回收程序尽早的回收</li></ol><h4 id="内存泄露" tabindex="-1">内存泄露 <a class="header-anchor" href="#内存泄露" aria-label="Permalink to &quot;内存泄露&quot;">​</a></h4><ol><li>少声明全局变量，因为除了页面被销毁或者手动设置为 null，全局变量都不会被垃圾回收程序回收</li><li>闭包导致的内存泄露，闭包访问的变量也不会被垃圾回收程序回收</li></ol>',25)]))}const b=e(t,[["render",d]]);export{_ as __pageData,b as default};
