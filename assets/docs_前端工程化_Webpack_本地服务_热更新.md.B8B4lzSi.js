import{_ as a,c as o,o as c,ag as l}from"./chunks/framework.BDwTZuFy.js";const p=JSON.parse('{"title":"本地服务器","description":"","frontmatter":{},"headers":[],"relativePath":"docs/前端工程化/Webpack/本地服务&热更新.md","filePath":"docs/前端工程化/Webpack/本地服务&热更新.md","lastUpdated":1737533611000}'),r={name:"docs/前端工程化/Webpack/本地服务&热更新.md"};function d(t,e,i,s,n,_){return c(),o("div",null,e[0]||(e[0]=[l('<h1 id="本地服务器" tabindex="-1">本地服务器 <a class="header-anchor" href="#本地服务器" aria-label="Permalink to &quot;本地服务器&quot;">​</a></h1><h2 id="webpack-dev-server" tabindex="-1">webpack-dev-server <a class="header-anchor" href="#webpack-dev-server" aria-label="Permalink to &quot;webpack-dev-server&quot;">​</a></h2><ul><li>使用 node 的 express 启动一个本地的 HTTP 服务器，用来展示前端的代码</li><li>使用这个插件编译后的代码，并不会做输出(不会生成 dist 文件夹)，而是把内容放到内存中供 express 读取</li></ul><h3 id="热更新" tabindex="-1">热更新 <a class="header-anchor" href="#热更新" aria-label="Permalink to &quot;热更新&quot;">​</a></h3><ul><li>应用程序运行过程中，替换、添加、删除模块。客户端会自动更新，而<code>无需刷新获取整个页面</code>(热更新过程中应用程序的<code>状态不会丢失</code>)</li><li>原理：客户端和服务端建立了一个 <code>webSocket</code> 连接(适用于即时通信)，文件发生变化时，服务端会通过 webSocket 发送更新信息给客户端</li></ul><h3 id="热更新的流程" tabindex="-1">热更新的流程 <a class="header-anchor" href="#热更新的流程" aria-label="Permalink to &quot;热更新的流程&quot;">​</a></h3><ol><li><code>webpack-dev-server</code> 插件，使用 express 启动本地的 HTTP 服务器</li><li>本地服务器与客户端建立了一个 <code>webSocket</code> 连接</li><li><code>webpack</code> 监听到文件的变化, 重新编译打包。 本地服务器将新版本的 <code>hash</code> 值发送给客户端</li><li>客户端通过 <code>hash</code> 值向服务端请求更新的文件</li><li>服务端返回更新的文件给客户端</li><li>客户端将更新的文件替换掉旧的文件</li></ol>',7)]))}const b=a(r,[["render",d]]);export{p as __pageData,b as default};
