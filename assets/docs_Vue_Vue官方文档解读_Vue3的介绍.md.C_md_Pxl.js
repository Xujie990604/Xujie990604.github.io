import{_ as a,c as t,o,ag as i}from"./chunks/framework.BDwTZuFy.js";const h=JSON.parse('{"title":"Vue3 的介绍","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Vue/Vue官方文档解读/Vue3的介绍.md","filePath":"docs/Vue/Vue官方文档解读/Vue3的介绍.md","lastUpdated":1712646874000}'),l={name:"docs/Vue/Vue官方文档解读/Vue3的介绍.md"};function c(d,e,r,u,s,p){return o(),t("div",null,e[0]||(e[0]=[i('<h1 id="vue3-的介绍" tabindex="-1">Vue3 的介绍 <a class="header-anchor" href="#vue3-的介绍" aria-label="Permalink to &quot;Vue3 的介绍&quot;">​</a></h1><ul><li>Vue 提供了一套<code>声明式</code>的、<code>组件化</code>的编程模型</li></ul><h2 id="vue-的两个核心功能" tabindex="-1">Vue 的两个核心功能 <a class="header-anchor" href="#vue-的两个核心功能" aria-label="Permalink to &quot;Vue 的两个核心功能&quot;">​</a></h2><ul><li>声明式渲染: Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以<code>声明式地描述</code>最终输出的 HTML 和 JavaScript 状态之间的<code>关系</code>。</li><li>响应性: Vue 会<code>自动跟踪</code> JavaScript 状态并在其<code>发生变化时响应式的更新</code> DOM。</li></ul><h2 id="单文件组件" tabindex="-1">单文件组件 <a class="header-anchor" href="#单文件组件" aria-label="Permalink to &quot;单文件组件&quot;">​</a></h2><ul><li>我们可以使用一种类似 HTML 的格式来书写 Vue 组件</li><li>单文件组件(.vue 文件)英文缩写 SFC</li><li>单文件组件中会有一个组件的逻辑，模板，样式</li></ul><h2 id="typescript-相关" tabindex="-1">typescript 相关 <a class="header-anchor" href="#typescript-相关" aria-label="Permalink to &quot;typescript 相关&quot;">​</a></h2><ul><li>Volar 和 Vscode 都会开启服务来支持 TS 语法, 在大型项目中可能存在性能问题，可以进行优化</li><li><code>&lt;template&gt;</code> 中也会支持 TS 语法</li></ul><h2 id="script-setup" tabindex="-1">script setup <a class="header-anchor" href="#script-setup" aria-label="Permalink to &quot;script setup&quot;">​</a></h2><ul><li>能够使用纯 TypeScript 声明 props 和自定义事件。</li><li><code>&lt;script setup&gt;</code> 里面的代码会被编译成组件 setup() 函数的内容。这意味着与普通的 <code>&lt;script&gt;</code> 只在组件被首次引入的时候执行一次不同，<code>&lt;script setup&gt;</code> 中的代码会在 <code>每次组件实例被创建</code> 的时候执行</li><li>当使用 <code>&lt;script setup&gt;</code> 的时候，任何在 <code>&lt;script setup&gt;</code> 声明的顶层的绑定 (包括变量，函数声明，<code>以及 import 导入的内容</code>) 都能在模板中直接使用(因为 <code>&lt;template&gt;</code> 会被编译成, 在 <code>setup()</code> 函数作用域内的 rander() 渲染函数)</li><li>defineProps() 和 defineEmits():为了在声明 props 和 emits 选项时获得完整的类型推导支持，我们可以使用 defineProps 和 defineEmits API，它们将自动地在 <code>&lt;script setup&gt;</code> 中可用</li><li><code>&lt;script setup&gt;</code> 中可以使用顶层 await。结果代码会被编译成 <code>async setup()</code></li></ul><h2 id="自定义指令" tabindex="-1">自定义指令 <a class="header-anchor" href="#自定义指令" aria-label="Permalink to &quot;自定义指令&quot;">​</a></h2><ul><li>自定义指令主要是为了<code>重用涉及普通元素的底层 DOM 访问的逻辑</code>。</li></ul><h2 id="组合式函数" tabindex="-1">组合式函数 <a class="header-anchor" href="#组合式函数" aria-label="Permalink to &quot;组合式函数&quot;">​</a></h2><ul><li>组合式函数(Composables) 是一个利用 Vue 的组合式 API 来封装和复用<code>有状态逻辑</code>的函数。</li><li>推荐在组合式函数中使用 ref 而不是 reactive, 因为 reactive 会在解构的时候失去响应式</li></ul><h2 id="插件" tabindex="-1">插件 <a class="header-anchor" href="#插件" aria-label="Permalink to &quot;插件&quot;">​</a></h2><ol><li>通过 <code>app.component()</code> 和 <code>app.directive()</code> 注册一到多个全局组件或自定义指令。</li><li>通过 <code>app.provide()</code> 使一个资源可被注入进整个应用。</li><li>向 <code>app.config.globalProperties</code> 中添加一些全局实例属性或方法</li></ol><h2 id="模板中受限的全局访问" tabindex="-1">模板中受限的全局访问 <a class="header-anchor" href="#模板中受限的全局访问" aria-label="Permalink to &quot;模板中受限的全局访问&quot;">​</a></h2><ul><li>模板中的表达式将被沙盒化，仅能访问到受限的全局对象，比如 Math Date</li><li>例如用户添加在 window 上的属性并不能直接在模板中使用，除非使用 app.config.globalProperties 显式的添加它们</li></ul><h3 id="依赖注入与全局属性" tabindex="-1">依赖注入与全局属性 <a class="header-anchor" href="#依赖注入与全局属性" aria-label="Permalink to &quot;依赖注入与全局属性&quot;">​</a></h3><ul><li>Vue3 中的全局属性仅作为对于 Vue2 中的 Vue.prototype 的兼容，只推荐在 Vue3 的选项式 API 写法中使用</li><li>Vue3 的组合式 API 写法只能在<code>模板</code>中访问到全局属性，无法在 <code>&lt;script&gt;</code> 中访问全局属性，因此十分不推荐在 Vue3 + 组合式 API 的写法中使用全局属性，而是全面使用<code>依赖注入</code>来代替</li></ul>',20)]))}const V=a(l,[["render",c]]);export{h as __pageData,V as default};
