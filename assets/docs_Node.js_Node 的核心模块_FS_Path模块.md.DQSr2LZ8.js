import{_ as o,c as a,o as d,ag as l}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"FS 文件系统模块","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Node.js/Node 的核心模块/FS&Path模块.md","filePath":"docs/Node.js/Node 的核心模块/FS&Path模块.md","lastUpdated":1738895815000}'),i={name:"docs/Node.js/Node 的核心模块/FS&Path模块.md"};function t(c,e,r,s,n,h){return d(),a("div",null,e[0]||(e[0]=[l('<h1 id="fs-文件系统模块" tabindex="-1">FS 文件系统模块 <a class="header-anchor" href="#fs-文件系统模块" aria-label="Permalink to &quot;FS 文件系统模块&quot;">​</a></h1><h2 id="一、fs-文件系统" tabindex="-1">一、FS 文件系统 <a class="header-anchor" href="#一、fs-文件系统" aria-label="Permalink to &quot;一、FS 文件系统&quot;">​</a></h2><ul><li>fs 模块能够以标准的 <code>POSIX</code> 函数为模型的方式与文件系统进行交互</li><li>所有的文件系统操作都具有 <code>同步</code>，<code>回调</code> 和 <code>基于Promise</code> 这三种形式</li><li><code>同步的API</code> 会阻塞时间循环和下一步的JS执行，直到操作被完成</li><li><code>基于 Promise 的API</code> 操作会返回一个 Promise</li><li><code>回调形式的API</code> 在操作完成之后调用回调函数，但是回调函数的<code>第一个参数始终用于存留异常(node 特色)</code>，无异常的话为 null || undefined。在性能方面 回调函数的版本比 Promise 版本更好</li></ul><h2 id="二、path-路径模块" tabindex="-1">二、Path 路径模块 <a class="header-anchor" href="#二、path-路径模块" aria-label="Permalink to &quot;二、Path 路径模块&quot;">​</a></h2><ul><li>用来处理文件和目录的路径，默认操作因 node 应用的操作系统而异(当处于 window 操作系统，将假定正在使用 window 风格的路径)</li></ul><h3 id="_2-1-路径处理对比" tabindex="-1">2.1 路径处理对比 <a class="header-anchor" href="#_2-1-路径处理对比" aria-label="Permalink to &quot;2.1 路径处理对比&quot;">​</a></h3><ul><li><code>path.join([...paths])</code> 可以接受多个路径，将多个路径拼接成一个规范化的路径, 路径前的 <code>/</code> 只会当做路径分隔符，不会被当做根目录符号来处理(和 resolve 的主要区别)。</li><li><code>path.resolve([...paths])</code> 将路径或路径片段的序列解析为绝对路径。路径前的 <code>/</code> 会被认为是根目录符号，最终返回的形式是一个<code>绝对路径</code>，如果路径解析后不是绝对路径，则使用<code>当前工作目录</code>当做路径前缀。</li><li>&#39;../&#39; 作为参数会抵消一层路径</li></ul><h2 id="三、-路径问题" tabindex="-1">三、 路径问题 <a class="header-anchor" href="#三、-路径问题" aria-label="Permalink to &quot;三、 路径问题&quot;">​</a></h2><ul><li>fs 模块操作文件时，若代码是相对路径。在代码运行时，会以 node 命令所处的目录为基准进行拼接。(在不同的目录启动文件会有不同的基础路径，导致失败)</li><li>使用绝对路径的话，就不会出现路径拼接失败的问题。(绝对路径中一个 / 不行，要加上转义字符 // 代表路径中的分隔符)</li><li><code>__dirname</code> 代表当前文件所处<code>目录</code>的绝对路径, <code>__filename</code> 代表当前文件所处的绝对路径(包含当前文件)，这两个不受执行 node 命令所属路径的影响</li></ul>',9)]))}const P=o(i,[["render",t]]);export{u as __pageData,P as default};
