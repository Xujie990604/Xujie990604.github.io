import{_ as l,c as s,o as e,ag as i}from"./chunks/framework.BDwTZuFy.js";const p=JSON.parse('{"title":"路由","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Vue/Vue router/路由的基础.md","filePath":"docs/Vue/Vue router/路由的基础.md","lastUpdated":1712646874000}'),t={name:"docs/Vue/Vue router/路由的基础.md"};function r(o,a,h,n,c,u){return e(),s("div",null,a[0]||(a[0]=[i(`<h1 id="路由" tabindex="-1">路由 <a class="header-anchor" href="#路由" aria-label="Permalink to &quot;路由&quot;">​</a></h1><ul><li>路由是网络工程里面的术语</li><li>路由就是通过互联网的网络把信息从源地址传输到目的地址的活动</li></ul><h2 id="映射表" tabindex="-1">映射表 <a class="header-anchor" href="#映射表" aria-label="Permalink to &quot;映射表&quot;">​</a></h2><ul><li>路由表的本质上就是一个映射表，决定了数据包的指向。</li></ul><h2 id="前端渲染后端渲染" tabindex="-1">前端渲染后端渲染 <a class="header-anchor" href="#前端渲染后端渲染" aria-label="Permalink to &quot;前端渲染后端渲染&quot;">​</a></h2><h3 id="后端的渲染-服务端渲染" tabindex="-1">后端的渲染(服务端渲染) <a class="header-anchor" href="#后端的渲染-服务端渲染" aria-label="Permalink to &quot;后端的渲染(服务端渲染)&quot;">​</a></h3><ul><li>原来的话后端使用 jsp 写页面，html+css+java java代码就直接从数据库中读取数据，并且将它动态的放在页面上</li><li>以前的网页是没有ajax技术的。整个页面都是重新获取的</li><li>浏览器输入RUL，直接将RUL发送给后端，后端直接返回页面</li><li>后端路由就是由后端处理URL和页面之间的映射关系</li><li>后端渲染直接交给客户端展示的话，有利于SEO的优化。</li><li>结构样式和数据全都糅合在一起，编写和维护都是很恶心的。</li></ul><h3 id="前后端分离的阶段" tabindex="-1">前后端分离的阶段 <a class="header-anchor" href="#前后端分离的阶段" aria-label="Permalink to &quot;前后端分离的阶段&quot;">​</a></h3><ul><li>随着ajax的出现</li><li>后端只负责提供数据，不负责任何页面的功能</li><li>后端就是一个提供API接口的服务器</li><li>在浏览器输入URL的话，去静态服务器下载html+css+js，html和css浏览器能够直接的渲染到页面，然后执行js代码，根据ajax去后端服务器请求数据，然后再根据请求到的数据增删改查DOM和CSS，然后再将新的页面渲染到页面上。</li><li>根据不同的URl下载不同的html+css+js，静态服务器中存在很多套html+css+js</li><li>这个阶段叫做前端渲染</li><li>前后端任务的分离，后端负责数据，前端负责交互和可视化</li></ul><h4 id="单页面-spa-富应用阶段" tabindex="-1">单页面(spa)富应用阶段 <a class="header-anchor" href="#单页面-spa-富应用阶段" aria-label="Permalink to &quot;单页面(spa)富应用阶段&quot;">​</a></h4><ul><li>在前后端分离的基础上加上了一层前端路由</li><li>静态资源服务器上只有一套html+css+js，在获取的时候会一次性获得所有文件，只不过不全部显示</li><li>然后根据不同的URL，从获取的html+css+js中抽离对应的部分(在vue中也就是对应的组件)</li><li>页面和URl的映射关系由前端路由来管理</li><li>改变URL的时候，页面是不进行整体的刷新的(改变URl的时候并不会重新向服务器发起请求)</li></ul><h2 id="history模式和hash模式" tabindex="-1">history模式和hash模式 <a class="header-anchor" href="#history模式和hash模式" aria-label="Permalink to &quot;history模式和hash模式&quot;">​</a></h2><ul><li>Vue 是单页面应用，Vue-Router 存在的意义就在于 --- 改变视图的同时不会向后端发起请求</li></ul><h3 id="如何改变视图但是不向后端发起请求" tabindex="-1">如何改变视图但是不向后端发起请求 <a class="header-anchor" href="#如何改变视图但是不向后端发起请求" aria-label="Permalink to &quot;如何改变视图但是不向后端发起请求&quot;">​</a></h3><h4 id="hash模式" tabindex="-1">hash模式 <a class="header-anchor" href="#hash模式" aria-label="Permalink to &quot;hash模式&quot;">​</a></h4><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6F42C1;">http</span><span style="color:#24292E;">:</span><span style="color:#6A737D;">//160.238.86.82:8003/#/index</span></span>
<span class="line"><span style="color:#24292E;">hash的值为 #</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">index</span></span>
<span class="line"><span style="color:#6F42C1;">特点</span><span style="color:#24292E;">: hash 虽然出现在URL中，但是不会被包含到HTTP请求中。每次向后端发起请求时只会发送 </span><span style="color:#6F42C1;">http</span><span style="color:#24292E;">:</span><span style="color:#6A737D;">//160.238.86.82:8003 这部分</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="history模式" tabindex="-1">history模式 <a class="header-anchor" href="#history模式" aria-label="Permalink to &quot;history模式&quot;">​</a></h4><ul><li>history 是利用的 H5 提供的 API。实现改变 URL 但是浏览器不会立即向后端发送请求</li><li>外形美观方便(但是如果想要完美的使用，需要后端进行配置支持)</li></ul><h5 id="history的弊端" tabindex="-1">history的弊端 <a class="header-anchor" href="#history的弊端" aria-label="Permalink to &quot;history的弊端&quot;">​</a></h5><ul><li>使用 history 模式进行浏览器历史记录栈的前进，后退都没有问题。就怕手动输入URL后回车或者刷新浏览器，因为每次刷新浏览器可是实实在在的去请求服务器。在hash模式下，#后面的内容都不会放到HTTP请求中，所以在多层路由下也没有问题。但是 history 模式就不行。在多层路由的情况下会把整个URL全都放到HTTP请求中(这就是为什么多层路由下刷新页面，通过绝对路径请求的资源会失效)。所以想要用好 history 模式，需要后端的配置。需要后端覆盖前端所有的路由，不然通过刷新请求数据时会找不到对应的资源</li></ul>`,20)]))}const b=l(t,[["render",r]]);export{p as __pageData,b as default};
