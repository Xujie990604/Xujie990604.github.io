import{_ as n,c as a,o as l,ag as p}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"一、Vue 编译器的实现","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Vue/Vue设计与实现/编译器的实现.md","filePath":"docs/Vue/Vue设计与实现/编译器的实现.md","lastUpdated":1737635920000}'),e={name:"docs/Vue/Vue设计与实现/编译器的实现.md"};function o(r,s,c,t,i,b){return l(),a("div",null,s[0]||(s[0]=[p(`<h1 id="一、vue-编译器的实现" tabindex="-1">一、Vue 编译器的实现 <a class="header-anchor" href="#一、vue-编译器的实现" aria-label="Permalink to &quot;一、Vue 编译器的实现&quot;">​</a></h1><h2 id="一、编译" tabindex="-1">一、编译 <a class="header-anchor" href="#一、编译" aria-label="Permalink to &quot;一、编译&quot;">​</a></h2><ul><li>DSL：领域特定语言、不要求图灵完备，只需要满足特定场景下的用途即可</li><li>GPL：通用用途语言、要求图灵完备</li><li>编译器其实只是一段程序，它用来将 <code>一种语言 A</code> 翻译成<code>另一种语言 B</code></li><li>源代码 -&gt; 词法分析 -&gt; 语法分析 -&gt; 语义分析 -&gt; 生成中间代码 -&gt; 优化 -&gt; 目标代码生成 -&gt; 目标代码</li></ul><ol><li>编译前端：词法分析、语法分析、语义分析(通常和目标平台无关，仅分析源代码)</li><li>编译后端：生成中间代码、优化、目标代码生成（通常和目标平台有关）</li></ol><h2 id="二、vue-编译" tabindex="-1">二、Vue 编译 <a class="header-anchor" href="#二、vue-编译" aria-label="Permalink to &quot;二、Vue 编译&quot;">​</a></h2><ul><li>AST: abstract syntax tree 抽象语法树</li><li>有限状态自动机：有限状态 - 有限个状态</li><li>正则表达式的本质就是有限自动机</li><li>Vue.js 模版编译器用来把 Template(视为字符串) 编译成功能相等的 Render 函数(JS 代码)</li><li>Vue.js 模版编译器首先对<code>模板</code>进行词法分析和语法分析，得到<code>模板 AST</code>。接着，将<code>模板 AST</code>转化成 <code>JavaScript AST</code>。最后，根据 <code>JavaScript AST</code> 生成 <code>JavaScript 代码</code></li></ul><h2 id="三、template-与-render" tabindex="-1">三、template 与 render <a class="header-anchor" href="#三、template-与-render" aria-label="Permalink to &quot;三、template 与 render&quot;">​</a></h2><blockquote><p>在绝大多数情况下，<code>Vue 推荐使用模板语法来创建应用</code>。然而在<code>某些使用场景下，我们真的需要用到 JavaScript 完全的编程能力。这时渲染函数就派上用场了</code>。</p></blockquote><h3 id="_3-1-模版语法" tabindex="-1">3.1 模版语法 <a class="header-anchor" href="#_3-1-模版语法" aria-label="Permalink to &quot;3.1 模版语法&quot;">​</a></h3><ol><li>书写方式更贴近实际的 HTML，书写层面更加简单直观。</li><li>灵活性较低，对于复杂的组件，模板不够灵活，难以表达复杂的逻辑</li><li>由于其确定的语法，更容易对模版做静态分析，使得 Vue 编译器能够应用许多编译时优化来提升虚拟 DOM 的性能</li></ol><h3 id="_3-2-render-语法" tabindex="-1">3.2 render 语法 <a class="header-anchor" href="#_3-2-render-语法" aria-label="Permalink to &quot;3.2 render 语法&quot;">​</a></h3><ol><li>渲染函数使用 JavaScript 编写，可以执行任意的 JavaScript 代码，非常适合复杂的逻辑</li><li>但是直接书写 Render 函数在编译层面不会受到 template 同等级别的编译时优化</li></ol><h2 id="三、运行时和编译时" tabindex="-1">三、运行时和编译时 <a class="header-anchor" href="#三、运行时和编译时" aria-label="Permalink to &quot;三、运行时和编译时&quot;">​</a></h2><h3 id="_3-1-编译时" tabindex="-1">3.1 编译时 <a class="header-anchor" href="#_3-1-编译时" aria-label="Permalink to &quot;3.1 编译时&quot;">​</a></h3><ul><li>编译时：在业务代码实际执行之前，框架代码对业务代码进行解析、转化、优化的过程。这个过程通常发生在构建阶段或者应用初始化过程中</li><li>前端框架 Svelte 是编译时框架，会将你的代码编译成体积小，不依赖框架的普通 JS 代码</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6F42C1;">TODO</span><span style="color:#24292E;">: Svelte 框架还没有使用过，目前还没有使用 Svelte 作为代码示例，目前的代码仅用来演示概念</span></span>
<span class="line"><span style="color:#6A737D;">// 一、定义模版</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">template</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt; { text } &lt;</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  let text = &#39;编译时&#39;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">template</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">// 二、编译过程</span></span>
<span class="line"><span style="color:#24292E;">Compiler(template)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">// 三、编译结果</span></span>
<span class="line"><span style="color:#24292E;">const div = document.createElement(&#39;div&#39;)</span></span>
<span class="line"><span style="color:#24292E;">const span = document.createElement(&#39;span&#39;)</span></span>
<span class="line"><span style="color:#24292E;">span.innerText = &#39;编译时&#39;</span></span>
<span class="line"><span style="color:#24292E;">div.appendChild(span)</span></span>
<span class="line"><span style="color:#24292E;">document.body.appendChild(div)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h4 id="编译时-优缺点" tabindex="-1">编译时-优缺点 <a class="header-anchor" href="#编译时-优缺点" aria-label="Permalink to &quot;编译时-优缺点&quot;">​</a></h4><ol><li>性能优化：大部分工作在构建阶段完成。运行时的开销较小，有助于提升运行时性能、首屏渲染速度较快、可以在编译过程中自定义优化方案</li><li>灵活性受限：静态生成的内容缺乏动态交互能力</li></ol><p>TODO: 为啥说纯编译时框架的灵活性受限，找出具体的实例来佐证</p><ol><li>能够使用模版的形式书写代码，结构清晰。易于维护</li></ol><h3 id="_3-2-运行时" tabindex="-1">3.2 运行时 <a class="header-anchor" href="#_3-2-运行时" aria-label="Permalink to &quot;3.2 运行时&quot;">​</a></h3><ul><li>运行时：框架代码于业务代码实际执行时起作用</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 一、定义数据对象</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> text </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &quot;运行时&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> obj</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  tag: </span><span style="color:#032F62;">&quot;div&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  children: [{ tag: </span><span style="color:#032F62;">&quot;span&quot;</span><span style="color:#24292E;">, children: text }],</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 二、框架提供的 Render 函数</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> Render</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">, </span><span style="color:#E36209;">root</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">  const</span><span style="color:#005CC5;"> el</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">createElement</span><span style="color:#24292E;">(obj.tag);</span></span>
<span class="line"><span style="color:#D73A49;">  if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> obj.children </span><span style="color:#D73A49;">===</span><span style="color:#032F62;"> &quot;string&quot;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">    const</span><span style="color:#005CC5;"> text</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">createTextNode</span><span style="color:#24292E;">(obj.children);</span></span>
<span class="line"><span style="color:#24292E;">    el.</span><span style="color:#6F42C1;">appendChild</span><span style="color:#24292E;">(text);</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#D73A49;"> if</span><span style="color:#24292E;"> (obj.children) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 数组，递归调用 Render，使用 el 作为 root 参数</span></span>
<span class="line"><span style="color:#24292E;">    obj.children.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">((</span><span style="color:#E36209;">child</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#6F42C1;"> Render</span><span style="color:#24292E;">(child, el));</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 将元素添加到 root</span></span>
<span class="line"><span style="color:#24292E;">  root.</span><span style="color:#6F42C1;">appendChild</span><span style="color:#24292E;">(el);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 三、代码在浏览器中执行</span></span>
<span class="line"><span style="color:#6F42C1;">Render</span><span style="color:#24292E;">(obj, document.body);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h4 id="运行时-优缺点" tabindex="-1">运行时-优缺点 <a class="header-anchor" href="#运行时-优缺点" aria-label="Permalink to &quot;运行时-优缺点&quot;">​</a></h4><ol><li>免除了编译代码的过程，但是也无法实现编译时优化</li><li>可以在运行过程中加入响应式系统、动态事件处理、组件生命周期等框架内置的功能</li><li>提供的数据对象形式较抽象，不如模板的写法更简洁，不易于维护</li></ol><h3 id="_3-3-运行时-编译时" tabindex="-1">3.3 运行时 + 编译时 <a class="header-anchor" href="#_3-3-运行时-编译时" aria-label="Permalink to &quot;3.3 运行时 + 编译时&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 一、定义模版</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">template</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt; {{ text }} &lt;</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  let text = &#39;运行时 + 编译时&#39;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">template</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">// 二、编译过程</span></span>
<span class="line"><span style="color:#24292E;">Compiler(template)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">// 三、编译结果</span></span>
<span class="line"><span style="color:#24292E;">let text = &quot;运行时 + 编译时&quot;;</span></span>
<span class="line"><span style="color:#24292E;">const obj = {</span></span>
<span class="line"><span style="color:#24292E;">  tag: </span><span style="color:#032F62;">&quot;div&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  children: [{ tag: </span><span style="color:#032F62;">&quot;span&quot;</span><span style="color:#24292E;">, children: text }],</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">// 四、代码在浏览器中执行</span></span>
<span class="line"><span style="color:#24292E;">Render(obj, document.body);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li>Vue 采用的是运行时 + 编译时：使用 template 来编写业务代码， template 会被编译成 Render 函数， Render 函数在运行时执行</li></ul><p>TODO：运行时 + 编译时的优缺点: 运行时更加灵活，便于在执行流程中加入响应式系统、动态事件处理、组件生命周期等框架内置的功能。编译时能使用模版的写法，代码比较简洁。并且在编译过程中能加入优化方案。</p><h2 id="四、编译优化" tabindex="-1">四、编译优化 <a class="header-anchor" href="#四、编译优化" aria-label="Permalink to &quot;四、编译优化&quot;">​</a></h2><blockquote><p>编译优化：编译器将模板编译为渲染函数的过程中，尽可能多地提取关键信息，并以此指导生成最优代码的过程。 优化方向即尽可能地区分<code>静态内容</code>和<code>动态内容</code> Vue 编译器会将<code>编译</code>时得到的关键信息<code>附在它生成的虚拟DOM上</code>，这些信息会通过<code>虚拟DOM传递给渲染器</code>。最终，<code>渲染器会根据这些关键信息</code>执行快捷路径，从而提升<code>运行时性能</code></p></blockquote><h3 id="_4-1-靶向更新" tabindex="-1">4.1 靶向更新 <a class="header-anchor" href="#_4-1-靶向更新" aria-label="Permalink to &quot;4.1 靶向更新&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 唯一可能变动的就是 p 标签文本子节点的内容</span></span>
<span class="line"><span style="color:#6A737D;">// 把不会变动的内容标记为\`静态节点\`，把会更新的内容标记为\`动态节点\`</span></span>
<span class="line"><span style="color:#6A737D;">// 在Diff 对比时会忽略静态节点，仅对比动态节点</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#6F42C1;"> id</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;foo&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">p</span><span style="color:#6F42C1;"> class</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;bar&quot;</span><span style="color:#24292E;">&gt;{{ text }}&lt;/</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 补丁标志：能做到靶向更新。例如，当一个动态节点的补丁为 PatchFlags.TEXT 时，渲染器会只更新文本节点的 textContent 而不是创建新的文本节点。</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> PatchFlags</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  TEXT: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 代表节点有动态的 textContent</span></span>
<span class="line"><span style="color:#24292E;">  CLASS: </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 代表元素有动态的 class 绑定</span></span>
<span class="line"><span style="color:#24292E;">  STYLE: </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#6A737D;">  // 其他……</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_4-2-静态提升" tabindex="-1">4.2 静态提升 <a class="header-anchor" href="#_4-2-静态提升" aria-label="Permalink to &quot;4.2 静态提升&quot;">​</a></h3><ul><li>减少更新时创建虚拟 DOM 带来的性能开销和内存占用</li><li>静态提升是以树为单位的，有些时候虽然整个 DOM 树不是静态的，但是<code>部分节点</code>或者<code>属性</code>是静态的，可以<code>单独把节点或者属性静态提升</code></li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 第一个 p 是纯静态，第二个 p 是动态的</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;static text&lt;/</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;{{ title }}&lt;/</span><span style="color:#22863A;">p</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 不使用静态提升，每次更新 render 重新执行时，\`createVNode(&quot;p&quot;, null, &quot;static text&quot;)\` 语句也需要被创建一次，这是没有必要的</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> render</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#6F42C1;">    openBlock</span><span style="color:#24292E;">(),</span></span>
<span class="line"><span style="color:#6F42C1;">    createBlock</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;div&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, [</span></span>
<span class="line"><span style="color:#6F42C1;">      createVNode</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;p&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;static text&quot;</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#6F42C1;">      createVNode</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;p&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, ctx.title, </span><span style="color:#005CC5;">1</span><span style="color:#6A737D;"> /* TEXT */</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">    ])</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用静态提升</span></span>
<span class="line"><span style="color:#6A737D;">// 把静态节点提升到渲染函数之外</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> hoist1</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> createVNode</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;p&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;text&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> render</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#6F42C1;">    openBlock</span><span style="color:#24292E;">(),</span></span>
<span class="line"><span style="color:#6F42C1;">    createBlock</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;div&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, [</span></span>
<span class="line"><span style="color:#24292E;">      hoist1, </span><span style="color:#6A737D;">// 静态节点引用</span></span>
<span class="line"><span style="color:#6F42C1;">      createVNode</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;p&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, ctx.title, </span><span style="color:#005CC5;">1</span><span style="color:#6A737D;"> /* TEXT */</span><span style="color:#24292E;">),</span></span>
<span class="line"><span style="color:#24292E;">    ])</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h3 id="_4-3-预字符串化" tabindex="-1">4.3 预字符串化 <a class="header-anchor" href="#_4-3-预字符串化" aria-label="Permalink to &quot;4.3 预字符串化&quot;">​</a></h3><ul><li>基于静态提升，将大块的静态内容序列化成字符串。能直接通过 innerHTML 进行设置、减少创建虚拟节点产生的性能开销</li></ul>`,38)]))}const d=n(e,[["render",o]]);export{u as __pageData,d as default};
