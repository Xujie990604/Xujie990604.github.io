import{_ as t,c as l,o as e,ag as i}from"./chunks/framework.BDwTZuFy.js";const r="/assets/0005.BsLSJPVV.png",o="/assets/0006.B27KVVjA.png",s="/assets/0007.BE10iyUV.jpg",P="/assets/0008.DvOkxrNh.png",_=JSON.parse('{"title":"TCP 协议","description":"","frontmatter":{},"headers":[],"relativePath":"docs/计算机网络/计算机网络/TCP IP协议/TCP协议.md","filePath":"docs/计算机网络/计算机网络/TCP IP协议/TCP协议.md","lastUpdated":1712646874000}'),c={name:"docs/计算机网络/计算机网络/TCP IP协议/TCP协议.md"};function n(h,a,T,d,C,p){return e(),l("div",null,a[0]||(a[0]=[i('<h1 id="tcp-协议" tabindex="-1">TCP 协议 <a class="header-anchor" href="#tcp-协议" aria-label="Permalink to &quot;TCP 协议&quot;">​</a></h1><ul><li>TCP 是一种面向连接的，可靠的协议。</li><li>TCP 是明文传输的。因为 HTTP 协议使用的就是 TCP 协议。所以 HTTP 是明文的</li><li>TCP 仅仅支持单播</li><li>TCP 是面向字节流的</li></ul><h2 id="tcp-实现可靠传输的手段" tabindex="-1">TCP 实现可靠传输的手段 <a class="header-anchor" href="#tcp-实现可靠传输的手段" aria-label="Permalink to &quot;TCP 实现可靠传输的手段&quot;">​</a></h2><h3 id="校验和" tabindex="-1">校验和 <a class="header-anchor" href="#校验和" aria-label="Permalink to &quot;校验和&quot;">​</a></h3><ul><li>校验数据是否为有效的</li></ul><h3 id="确认应答" tabindex="-1">确认应答 <a class="header-anchor" href="#确认应答" aria-label="Permalink to &quot;确认应答&quot;">​</a></h3><h3 id="tcp-超时重传" tabindex="-1">TCP 超时重传 <a class="header-anchor" href="#tcp-超时重传" aria-label="Permalink to &quot;TCP 超时重传&quot;">​</a></h3><ul><li>因为情况的复杂性，需要使用科学的算法来计算出合理的 TCP 超时重传时间。</li></ul><h3 id="tcp-流量控制" tabindex="-1">TCP 流量控制 <a class="header-anchor" href="#tcp-流量控制" aria-label="Permalink to &quot;TCP 流量控制&quot;">​</a></h3><ul><li>控制发送方的发送速度，以免发送数据的速度过快，导致接收方来不及全部接收。</li></ul><h3 id="tcp-的拥塞控制" tabindex="-1">TCP 的拥塞控制 <a class="header-anchor" href="#tcp-的拥塞控制" aria-label="Permalink to &quot;TCP 的拥塞控制&quot;">​</a></h3><ul><li>对网络中某一个资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做拥塞。</li><li>四种算法： 慢开始，拥塞避免，快重传，快恢复(拥塞窗口大小的意思就是，一次发送能发送 TCP 报文段的个数)</li></ul><p><img src="'+r+'" alt="拥塞" title="只使用慢开始和拥塞避免"></p><ul><li>在发生重传计时器超时时，有可能是出现了拥塞，也有可能是出现了报文段的丢失，不搞清楚是什么原因发生了重传计时器超时就直接降低拥塞窗口的大小会降低效率。采用<strong>快重传算法</strong>来区别是发生了拥塞还是发生了丢失，可以有效提高传输效率。</li><li>快恢复算法： 当使用快重传算法发现有个人报文段丢失时，不在启动<strong>慢开始算法</strong>，而是启动<strong>快恢复算法</strong>。快恢复算法不会直接把拥塞窗口大小直接改为 1，而是改为当前窗口大小的一半。</li></ul><p><img src="'+o+'" alt="拥塞" title="使用四种算法来进行拥塞控制"></p><h2 id="tcp-的连接建立" tabindex="-1">TCP 的连接建立 <a class="header-anchor" href="#tcp-的连接建立" aria-label="Permalink to &quot;TCP 的连接建立&quot;">​</a></h2><h3 id="使用三报文握手来建立-tcp-连接" tabindex="-1">使用三报文握手来建立 TCP 连接 <a class="header-anchor" href="#使用三报文握手来建立-tcp-连接" aria-label="Permalink to &quot;使用三报文握手来建立 TCP 连接&quot;">​</a></h3><p>同步位 SYN 序号字段 seq 确认位 ACK 确认号字段 ack</p><p><img src="'+s+'" alt="TCP连接建立" title="连接建立"></p><ul><li>使用三次握手来建立 TCP 连接是为了防止已失效的连接请求报文段(在网络中的结点长时间滞留了，延误到连接释放以后的某个时间点才到达服务端)(由于 TCP 的超时重传特性导致)突然又传送到了 TCP 服务器。进而导致错误。</li></ul><h3 id="数据传送" tabindex="-1">数据传送 <a class="header-anchor" href="#数据传送" aria-label="Permalink to &quot;数据传送&quot;">​</a></h3><h3 id="使用四报文挥手来释放-tcp-连接" tabindex="-1">使用四报文挥手来释放 TCP 连接 <a class="header-anchor" href="#使用四报文挥手来释放-tcp-连接" aria-label="Permalink to &quot;使用四报文挥手来释放 TCP 连接&quot;">​</a></h3><p>终止位 FIN</p><p><img src="'+P+'" alt="TCP连接释放" title="连接释放"></p><ul><li>为什么 TCP 客户端在第二次发送完连接释放报文段后仍需要等待 2MSL 的时间后才关闭。是为了防止第二次连接释放报文段丢失后，TCP 服务端认为他发送的第二次连接释放报文段丢失，所以会启动 TCP 超时重传。如果此时客户端已经关闭的话，客户端收不到信息，TCP 服务端就会一直超时重传。等待两个 MSL 时间来确保 此次连接中没有剩余的 TCP 报文段干扰下一次 TCP 连接。</li><li>因为 TCP 是全双工通信的。四次挥手是客户端和服务端分别释放连接的过程。</li><li>每两次挥手其实是一次释放连接的过程。为什么一次释放需要两次挥手。假如客户端想要断开连接。客户端发送了连接释放请求。如果服务端没有回应，客户端并不知道自己的请求已经正确到达了服务端。每次释放时的第一次挥手是请求，第二次挥手是回应请求已经收到。</li><li>前两次的挥手是为了关闭从客户端到服务端的 TCP 连接，两次挥手之后服务器仍然可以给客户端发送少量数据。</li><li>后两次的挥手是为了关闭从服务端到客户端的 TCP 连接，至此 TCP 连接才真正释放。</li></ul>',25)]))}const m=t(c,[["render",n]]);export{_ as __pageData,m as default};
