import{_ as e,c as i,o as a,ag as t}from"./chunks/framework.BDwTZuFy.js";const x=JSON.parse('{"title":"弹性盒子布局","description":"","frontmatter":{},"headers":[],"relativePath":"docs/HTML+CSS/CSS部分/网页的布局/Flex布局.md","filePath":"docs/HTML+CSS/CSS部分/网页的布局/Flex布局.md","lastUpdated":1712646874000}'),r={name:"docs/HTML+CSS/CSS部分/网页的布局/Flex布局.md"};function o(n,l,s,h,d,f){return a(),i("div",null,l[0]||(l[0]=[t('<h1 id="弹性盒子布局" tabindex="-1">弹性盒子布局 <a class="header-anchor" href="#弹性盒子布局" aria-label="Permalink to &quot;弹性盒子布局&quot;">​</a></h1><h2 id="一、容器的属性" tabindex="-1">一、容器的属性 <a class="header-anchor" href="#一、容器的属性" aria-label="Permalink to &quot;一、容器的属性&quot;">​</a></h2><h3 id="_1-1-flex-direction-主轴项目的排列方式" tabindex="-1">1.1 flex-direction(主轴项目的排列方式) <a class="header-anchor" href="#_1-1-flex-direction-主轴项目的排列方式" aria-label="Permalink to &quot;1.1 flex-direction(主轴项目的排列方式)&quot;">​</a></h3><ol><li>(默认值)row 左 → 右</li><li>row-reverse 右 → 左</li><li>column 上 → 下</li><li>column-reverse 下 → 上</li></ol><h3 id="_1-2-flex-wrap-换行" tabindex="-1">1.2 flex-wrap（换行） <a class="header-anchor" href="#_1-2-flex-wrap-换行" aria-label="Permalink to &quot;1.2 flex-wrap（换行）&quot;">​</a></h3><ol><li>(默认值)nowrap:不换行</li><li>wrap：第一行在上</li><li>wrap-reverse：第一行在下</li></ol><h3 id="_1-3-flex-flow" tabindex="-1">1.3 flex-flow <a class="header-anchor" href="#_1-3-flex-flow" aria-label="Permalink to &quot;1.3 flex-flow&quot;">​</a></h3><ul><li>是 flex-direction 和 flex-wrap 的缩写</li></ul><h3 id="_1-4-justify-content-定义项目在主轴上的对齐方式" tabindex="-1">1.4 justify-content(定义项目在主轴上的对齐方式) <a class="header-anchor" href="#_1-4-justify-content-定义项目在主轴上的对齐方式" aria-label="Permalink to &quot;1.4 justify-content(定义项目在主轴上的对齐方式)&quot;">​</a></h3><ol><li>(默认值)flex-start：左对齐</li><li>flex-end：右对齐</li><li>center：居中</li><li>space-between：两端对齐，项目间隔一样</li><li>space-around：每个项目两端的间隔相等</li></ol><h3 id="_1-5-align-items-定义项目在交叉轴方向的排列方式-单行时使用的属性-只有在align-item是默认值的时候-才会与最高项默认对齐-填充满容器。在其他属性的时候会恢复元素默认的大小。" tabindex="-1">1.5 align-items：定义项目在交叉轴方向的排列方式(单行时使用的属性)(只有在align-item是默认值的时候，才会与最高项默认对齐，填充满容器。在其他属性的时候会恢复元素默认的大小。) <a class="header-anchor" href="#_1-5-align-items-定义项目在交叉轴方向的排列方式-单行时使用的属性-只有在align-item是默认值的时候-才会与最高项默认对齐-填充满容器。在其他属性的时候会恢复元素默认的大小。" aria-label="Permalink to &quot;1.5 align-items：定义项目在交叉轴方向的排列方式(单行时使用的属性)(只有在align-item是默认值的时候，才会与最高项默认对齐，填充满容器。在其他属性的时候会恢复元素默认的大小。)&quot;">​</a></h3><ol><li>(默认值)stretch 如果父容器有固定高度那就拉伸填充满父容器，如果父容器没有固定高度，那就和最高的子项一样高。</li><li>flex-start:交叉轴起点对齐</li><li>flex-end:交叉轴终点对齐</li><li>center：居中，保持原有高度</li><li>baseline:项目第一行的文字基线对齐</li></ol><h3 id="_1-6-align-content-定义了多根轴线的对齐方式-和flex-direction的作用很是相似-多行时定义的属性-多行轴线的权重大于单行轴线的权重" tabindex="-1">1.6 align-content(定义了多根轴线的对齐方式,和flex-direction的作用很是相似)(多行时定义的属性)(多行轴线的权重大于单行轴线的权重) <a class="header-anchor" href="#_1-6-align-content-定义了多根轴线的对齐方式-和flex-direction的作用很是相似-多行时定义的属性-多行轴线的权重大于单行轴线的权重" aria-label="Permalink to &quot;1.6 align-content(定义了多根轴线的对齐方式,和flex-direction的作用很是相似)(多行时定义的属性)(多行轴线的权重大于单行轴线的权重)&quot;">​</a></h3><ol><li>(默认值)stretch：轴线占满整个交叉轴,如果父容器有固定高度就拉伸填满父容器</li><li>flex-start:与交叉轴的起点对齐</li><li>flex-end:与交叉轴的终点对齐</li><li>center: 与交叉轴的中点对齐</li><li>space-between:与交叉轴的两端对齐，轴线之间的间隔平分</li><li>space-around:每根轴线两端的间隔都相等</li></ol><h2 id="二、项目的属性" tabindex="-1">二、项目的属性 <a class="header-anchor" href="#二、项目的属性" aria-label="Permalink to &quot;二、项目的属性&quot;">​</a></h2><ul><li>flex 是个缩写：flex-grow flex-shrink flex-basis;</li></ul><h3 id="_2-1-flex-grow" tabindex="-1">2.1 flex-grow <a class="header-anchor" href="#_2-1-flex-grow" aria-label="Permalink to &quot;2.1 flex-grow&quot;">​</a></h3><ul><li>无比例单位, <code>剩余空间</code>的放大比例。在根据 basis 属性设置完之后，把剩余的空间按照比例分配放大。</li></ul><h3 id="_2-2-flex-shrink" tabindex="-1">2.2 flex-shrink <a class="header-anchor" href="#_2-2-flex-shrink" aria-label="Permalink to &quot;2.2 flex-shrink&quot;">​</a></h3><ul><li>缩小比例(溢出空间的缩小比例)</li><li>在根据 basis 属性设置完之后，把多余的空间按照自己的 basis 和 shrink 的乘积系数占总的 basis 和 shrink 的乘积和的比例进行缩小，目的是让大的元素缩小的更多。</li></ul><h3 id="_2-3-flex-basis" tabindex="-1">2.3 flex-basis <a class="header-anchor" href="#_2-3-flex-basis" aria-label="Permalink to &quot;2.3 flex-basis&quot;">​</a></h3><ul><li><p>在放大缩小项目之前的空间大小(基础值)，先按照此项分配空间，然后再根据放大和缩小比例进行调整。</p></li><li><p>auto: 从 width 和 height 那里获得尺寸，如果没有规定那么就根据内容来分配大小。</p></li><li><p>0: 不在这一步获取内容的基础大小，直接到系数那里分配大小。basic 为 0 的话，width 属性的设置也会不起作用。使用 flex 的属性比 width 的优先级要高，(不考虑书写的顺序)。max-width 和 min-width 的优先级比 flex 的优先级要高。</p></li></ul><h3 id="_2-4-flex-简写" tabindex="-1">2.4 flex 简写 <a class="header-anchor" href="#_2-4-flex-简写" aria-label="Permalink to &quot;2.4 flex 简写&quot;">​</a></h3><ol><li>flex默认值：（0 1 auto）</li><li>flex: 1; 代表 flex:1 1 0;</li></ol><h3 id="_2-5-align-self" tabindex="-1">2.5 align-self <a class="header-anchor" href="#_2-5-align-self" aria-label="Permalink to &quot;2.5 align-self&quot;">​</a></h3><ul><li>允许单个项目与其他项目有不一样的对齐方式。可覆盖 align-items 属性。(默认继承父元素)</li></ul><h3 id="_2-6-order" tabindex="-1">2.6 order <a class="header-anchor" href="#_2-6-order" aria-label="Permalink to &quot;2.6 order&quot;">​</a></h3><ul><li>定义项目的排列顺序：数值越小越靠前。默认为 0</li><li>使得内容的显示可以不同于源顺序，这样的好处是不用破坏良好的 html 结构的情况下，有一个更加良好的阅读体验。</li></ul><h2 id="三、flex布局中失效的css属性" tabindex="-1">三、flex布局中失效的css属性 <a class="header-anchor" href="#三、flex布局中失效的css属性" aria-label="Permalink to &quot;三、flex布局中失效的css属性&quot;">​</a></h2><ol><li>float</li><li>clear</li><li>column</li><li>vertical-align</li></ol><h2 id="四、flex-的特点" tabindex="-1">四、flex 的特点 <a class="header-anchor" href="#四、flex-的特点" aria-label="Permalink to &quot;四、flex 的特点&quot;">​</a></h2><ul><li>图片视频等带有自己的宽高比的对象，作为伸缩项的时候会有问题，解决方案是给这些元素添加一个包装元素。</li><li>flex 的可伸缩项也会有一个隐形的最小的宽度，不会比内容区更小，为了精准控制最好给项加一个 min-width 来规范</li><li>flex 的元素可以直接设置 z-index 属性。创建新的堆叠上下文，不需要使用定位属性。</li><li>行内元素设置为弹性盒子需要设置 display 为 inline-flex</li><li>在 flex 的多行布局中，设置了同样的比例系数 <code>flex: 1;</code>，如果最后一行只有一个元素的话，就会占满一行，很不美观，所以可以通过 <code>max-width</code> 属性来限制每个子项目的最大宽度</li></ul>',32)]))}const u=e(r,[["render",o]]);export{x as __pageData,u as default};
