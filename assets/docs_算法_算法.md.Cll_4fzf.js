import{_ as l,c as e,o as i,ag as t}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"算法","description":"","frontmatter":{},"headers":[],"relativePath":"docs/算法/算法.md","filePath":"docs/算法/算法.md","lastUpdated":1712646874000}'),o={name:"docs/算法/算法.md"};function r(d,a,n,s,h,c){return i(),e("div",null,a[0]||(a[0]=[t('<h1 id="算法" tabindex="-1">算法 <a class="header-anchor" href="#算法" aria-label="Permalink to &quot;算法&quot;">​</a></h1><h2 id="分治法" tabindex="-1">分治法 <a class="header-anchor" href="#分治法" aria-label="Permalink to &quot;分治法&quot;">​</a></h2><ol><li>分解原问题为多个子问题</li><li>解决子问题，用返回解决子问题的方式递归算法</li><li>组合这些子问题的解决方式，得到原问题的解</li></ol><h2 id="动态规划" tabindex="-1">动态规划 <a class="header-anchor" href="#动态规划" aria-label="Permalink to &quot;动态规划&quot;">​</a></h2><ul><li>动态规划是一种将复杂问题分解成更小的子问题来解决的优化技术</li><li>动态规划和分治法是不同的方法，分治法是把问题分解成相互独立的子问题，然后组合他们的答案。动态规划是将问题分解成互相依赖的子问题</li></ul><ol><li>定义子问题</li><li>实现要反复执行来解决子问题的部分(递归的方式)</li><li>识别并求解出基线问题</li></ol><h2 id="贪心算法" tabindex="-1">贪心算法 <a class="header-anchor" href="#贪心算法" aria-label="Permalink to &quot;贪心算法&quot;">​</a></h2><ul><li>遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择(当前最好的解)从而达到全局的最优解</li></ul><h2 id="回溯算法" tabindex="-1">回溯算法 <a class="header-anchor" href="#回溯算法" aria-label="Permalink to &quot;回溯算法&quot;">​</a></h2><ul><li>回溯是一种渐进式寻找并构建问题解决方式的策略，我们从一个可能的动作开始并试着用这个动作解决问题，如果不能解决就回溯并选择另一个动作直到将问题解决。</li></ul>',10)]))}const m=l(o,[["render",r]]);export{u as __pageData,m as default};
