import{_ as e,c as l,o as i,ag as t}from"./chunks/framework.BDwTZuFy.js";const b=JSON.parse('{"title":"类","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Dart/面向对象/类.md","filePath":"docs/Dart/面向对象/类.md","lastUpdated":1748272804000}'),r={name:"docs/Dart/面向对象/类.md"};function o(h,a,d,n,s,c){return i(),l("div",null,a[0]||(a[0]=[t('<h1 id="类" tabindex="-1">类 <a class="header-anchor" href="#类" aria-label="Permalink to &quot;类&quot;">​</a></h1><ul><li>Dart 是一种<code>面向对象</code>的语言，具有<code>类</code>和<code>基于混入的继承</code></li><li>Dart 的 new 关键字是可省略的</li></ul><h2 id="实例变量" tabindex="-1">实例变量 <a class="header-anchor" href="#实例变量" aria-label="Permalink to &quot;实例变量&quot;">​</a></h2><ol><li>所有的实例变量都会生成一个隐式的 getter 方法</li><li>非 final 实例变量和 late final(没有初始值预定项)的实例变量都会隐式生成一个 setter 方法</li></ol><h2 id="类变量和方法" tabindex="-1">类变量和方法 <a class="header-anchor" href="#类变量和方法" aria-label="Permalink to &quot;类变量和方法&quot;">​</a></h2><ul><li>使用 static 关键字来实现<code>类范围</code>的变量和方法。</li></ul><h3 id="静态变量" tabindex="-1">静态变量 <a class="header-anchor" href="#静态变量" aria-label="Permalink to &quot;静态变量&quot;">​</a></h3><ul><li>静态变量在使用前不会被初始化</li></ul><h3 id="静态方法" tabindex="-1">静态方法 <a class="header-anchor" href="#静态方法" aria-label="Permalink to &quot;静态方法&quot;">​</a></h3><ul><li>静态方法不在实例上操作，因此无法访问 this</li></ul><h2 id="实例变量初始化" tabindex="-1">实例变量初始化 <a class="header-anchor" href="#实例变量初始化" aria-label="Permalink to &quot;实例变量初始化&quot;">​</a></h2><ol><li>声明时初始化实例变量</li><li>使用初始化形参</li><li>使用初始化列表</li></ol><h2 id="构造函数继承" tabindex="-1">构造函数继承 <a class="header-anchor" href="#构造函数继承" aria-label="Permalink to &quot;构造函数继承&quot;">​</a></h2><p>TODO：待补充</p><h2 id="混入" tabindex="-1">混入 <a class="header-anchor" href="#混入" aria-label="Permalink to &quot;混入&quot;">​</a></h2><ul><li>混入是一种定义可以在多个类层次结构中重用代码的方法。它们旨在批量提供成员实现。</li><li>minix 定义混入，使用 with 关键字消费混入</li></ul><h2 id="类的修饰符" tabindex="-1">类的修饰符 <a class="header-anchor" href="#类的修饰符" aria-label="Permalink to &quot;类的修饰符&quot;">​</a></h2><h3 id="abstract" tabindex="-1">abstract <a class="header-anchor" href="#abstract" aria-label="Permalink to &quot;abstract&quot;">​</a></h3><ul><li>抽象类不能实例化</li><li>继承自抽象类之后，必须实现抽象类的抽象方法</li></ul><h3 id="base" tabindex="-1">base <a class="header-anchor" href="#base" aria-label="Permalink to &quot;base&quot;">​</a></h3><h3 id="interface" tabindex="-1">interface <a class="header-anchor" href="#interface" aria-label="Permalink to &quot;interface&quot;">​</a></h3><ul><li>定义接口</li></ul><h3 id="final" tabindex="-1">final <a class="header-anchor" href="#final" aria-label="Permalink to &quot;final&quot;">​</a></h3><ul><li>关闭类型层次结构</li></ul><h3 id="sealed" tabindex="-1">sealed <a class="header-anchor" href="#sealed" aria-label="Permalink to &quot;sealed&quot;">​</a></h3><h2 id="隐式接口" tabindex="-1">隐式接口 <a class="header-anchor" href="#隐式接口" aria-label="Permalink to &quot;隐式接口&quot;">​</a></h2><ul><li>默认所有的类都是隐式接口</li><li>Dart 支持单继承</li><li>当将一个类作为接口使用时，那么实现这个接口的类，必须实现这个接口中的所有方法</li></ul><h2 id="类属性-类方法" tabindex="-1">类属性 &amp; 类方法 <a class="header-anchor" href="#类属性-类方法" aria-label="Permalink to &quot;类属性 &amp; 类方法&quot;">​</a></h2><ul><li>使用 static 关键字定义类属性&amp;类方法</li></ul>',29)]))}const f=e(r,[["render",o]]);export{b as __pageData,f as default};
