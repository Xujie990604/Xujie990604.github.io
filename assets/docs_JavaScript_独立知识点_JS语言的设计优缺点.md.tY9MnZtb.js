import{_ as s,c as n,o as e,ag as l}from"./chunks/framework.BDwTZuFy.js";const b=JSON.parse('{"title":"JS","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/独立知识点/JS语言的设计优缺点.md","filePath":"docs/JavaScript/独立知识点/JS语言的设计优缺点.md","lastUpdated":1748684767000}'),t={name:"docs/JavaScript/独立知识点/JS语言的设计优缺点.md"};function i(r,a,p,o,c,d){return e(),n("div",null,a[0]||(a[0]=[l(`<h1 id="js" tabindex="-1">JS <a class="header-anchor" href="#js" aria-label="Permalink to &quot;JS&quot;">​</a></h1><ul><li>将精力放在一门语言的优美特性上，忘记一门语言中鸡肋和糟糕的特性。十分重要</li></ul><h2 id="一、语法" tabindex="-1">一、语法 <a class="header-anchor" href="#一、语法" aria-label="Permalink to &quot;一、语法&quot;">​</a></h2><h3 id="_1-1-语法优点" tabindex="-1">1.1 语法优点 <a class="header-anchor" href="#_1-1-语法优点" aria-label="Permalink to &quot;1.1 语法优点&quot;">​</a></h3><ul><li>|| &amp;&amp; 短路运算符的特点</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// \`||\` 用于变量赋值</span></span>
<span class="line"><span style="color:#6A737D;">// 只要 device.count 的值转化为布尔值为 false 就会返回 &#39;- -&#39; 占位符</span></span>
<span class="line"><span style="color:#6A737D;">// 布尔值为 false: undefined null 0 false &quot;&quot; NaN</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> deviceCount </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> device.count </span><span style="color:#D73A49;">||</span><span style="color:#032F62;"> &quot;- -&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 可能 device.count 为 0 时并不想显示 &#39;- -&#39;</span></span>
<span class="line"><span style="color:#6A737D;">// 可以使用 \`??\` 进行改进, 只有 device.count 为 undefined 或者 null 时才返回 &#39;- -&#39;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> deviceCount </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> device.count </span><span style="color:#D73A49;">??</span><span style="color:#032F62;"> &quot;- -&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//  &amp;&amp; 用于避免在 undefined 上读取数据报错</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (user </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> user.info) {</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> userName </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> user.info.name;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用 \`?.\` 进行优化</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> userName </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> user?.info?.name;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li>str1 + str2 能十分方便的拼接字符串</li></ul><h3 id="_1-2-语法缺点" tabindex="-1">1.2 语法缺点 <a class="header-anchor" href="#_1-2-语法缺点" aria-label="Permalink to &quot;1.2 语法缺点&quot;">​</a></h3><ul><li>数值的隐式类型转换(包括但不限于 undefined == null、1 == &#39;1&#39;、[] == 0), JS 糟粕的精髓所在 -------- 使用 === 代替 ==</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6F42C1;">TODO</span><span style="color:#24292E;">: 网上去搜那个很离谱的东西;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// TS 是不是就禁止了一些涉及到隐形类型转换的操作 ， 比如 数字不能和字母相加</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>typeof (Array | Object | null) === &#39;object&#39; ----------- 使用 instanceof 来判断数组或对象</li><li>typeof 未定义变量、未初始化变量 的返回值都是 undefined ------- 变量在声明时一定要初始化一个值，这样在 typeof 返回 undefined 时才能明确这是变量未声明。</li><li>弱类型和过度的容错导致 JS 代码很容易写出各种隐患 ---------- 使用一个良好的统一的代码编写风格</li><li>基于全局变量的编程模型 ---------- 会导致变量名之间的互相冲突和大型程序的难以维护(使用 ES6 的 module)</li><li>不声明变量就可以使用，并且会被添加到全局变量中</li><li>没有块级作用域，变量可以重复声明，变量声明会自动提升 ------- 使用 let, const</li><li>NAN === NAN， +0 -0 ---------- 使用 Object.is()</li><li>with() eval() ------- 不要使用</li><li>if for 后面不加代码块时写单行语句不会报错 ------ 不要这样做</li></ul><h2 id="对象优点" tabindex="-1">对象优点 <a class="header-anchor" href="#对象优点" aria-label="Permalink to &quot;对象优点&quot;">​</a></h2><ul><li>灵活的创建对象的方式: 对象字面量表示法 -------- JSON 设计的灵感之源</li><li>使用 [] 语法进行对象属性的检索和设置</li><li>基于原型的继承方式, 可以直接继承其他对象的属性, 通过委托的方式来访问原型上的属性</li><li>JS 中对象是没有类型的(class-free)</li><li>通过给基本构造函数的 Prototype 添加方法，能够大大提高语言的表现力。由于原型继承的本质，新的方法会被立刻添加到所有的实例上，哪怕实例是在方法的创建之前被创建的。</li><li>数字，字符串，布尔值得益于包装类，可以拥有方法</li></ul><h2 id="对象缺点" tabindex="-1">对象缺点 <a class="header-anchor" href="#对象缺点" aria-label="Permalink to &quot;对象缺点&quot;">​</a></h2><ul><li>使用 for in 遍历对象时，会输出原型上的属性。 ----- 可以改用 Object.values() 来遍历对象</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>对象属性的顺序是不固定的 ----- map 实例会维护插入的顺序</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 按照顺序进行遍历</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>伪类(构造函数长得像类，但其实是函数)会误导 JS 程序员编写过于复杂的层次结构。许多复杂的类层次结构产生的原因是静态类型检查的约束，但是 JS 中并不存在静态类型检查。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// JS 中并不具有完整的面向对象编程特性</span></span>
<span class="line"><span style="color:#6A737D;">// JS 天生是鸭子类型的，很多情况能轻松做到 Java 做不到的事情，因为无需搞那么麻烦</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>永远不要使用 new Boolean() new Number() new String() 来显视的声明基本类型包装类</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 显式使用包装类时，带来的一些匪夷所思问题</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="函数优点" tabindex="-1">函数优点 <a class="header-anchor" href="#函数优点" aria-label="Permalink to &quot;函数优点&quot;">​</a></h2><ul><li>JS 中的函数是一等公民, 函数可以当做值来使用</li><li>函数的闭包是 JS 强大表现力的根基(模块化，实现私有变量(闭包能实现信息隐蔽)，记忆函数(能避免很多重复计算，用于优化 阶乘 和 Fibonacci 数列))</li><li>arguments 使得函数可以接受任意个参数</li><li>使用回调函数的形式来进行异步的事件响应</li></ul><h2 id="函数缺点" tabindex="-1">函数缺点 <a class="header-anchor" href="#函数缺点" aria-label="Permalink to &quot;函数缺点&quot;">​</a></h2><ul><li>函数的 this 指向设计错误，导致对象的方法中的函数无法按照预期使用 this ------ 使用箭头函数或 that 来解决</li></ul><h2 id="数组优点" tabindex="-1">数组优点 <a class="header-anchor" href="#数组优点" aria-label="Permalink to &quot;数组优点&quot;">​</a></h2><ul><li>使用方便的数组自变量方式创建</li><li>并不是真正的数组结构，而是特殊的对象。数组能够拥有一套自己的方法和 length 属性，数组不存在上界</li><li>数组中的元素并不要求是相同的类型</li></ul><h2 id="数组缺点" tabindex="-1">数组缺点 <a class="header-anchor" href="#数组缺点" aria-label="Permalink to &quot;数组缺点&quot;">​</a></h2><ul><li>查询速度会比真正的数组结构慢</li></ul><h3 id="_3-1-new-array-令人困惑" tabindex="-1">3.1 new Array() 令人困惑 <a class="header-anchor" href="#_3-1-new-array-令人困惑" aria-label="Permalink to &quot;3.1 new Array() 令人困惑&quot;">​</a></h3><ul><li>使用 <code>new Array(3)</code> 声明数组时，无法区分是想要长度为 3 还是仅包含一个数值 3</li><li>使用 ES6 的 <code>Array.of()</code> 解决这个问题</li></ul><table tabindex="0"><thead><tr><th style="text-align:center;">参数</th><th style="text-align:center;">结果</th></tr></thead><tbody><tr><td style="text-align:center;">new Array()</td><td style="text-align:center;">[]</td></tr><tr><td style="text-align:center;">Array.of()</td><td style="text-align:center;">[]</td></tr><tr><td style="text-align:center;">new Array(3) <code>!注意结果</code></td><td style="text-align:center;">[undefined, undefined, undefined]</td></tr><tr><td style="text-align:center;">Array.of(3)</td><td style="text-align:center;">[3]</td></tr><tr><td style="text-align:center;">new Array(3, 11, 8)</td><td style="text-align:center;">[3, 11, 8]</td></tr><tr><td style="text-align:center;">Array.of(3, 11, 8)</td><td style="text-align:center;">[3, 11, 8]</td></tr></tbody></table>`,33)]))}const h=s(t,[["render",i]]);export{b as __pageData,h as default};
