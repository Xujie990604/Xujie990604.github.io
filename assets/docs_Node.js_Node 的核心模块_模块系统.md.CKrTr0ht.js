import{_ as n,c as a,o as l,ag as e}from"./chunks/framework.BDwTZuFy.js";const m=JSON.parse('{"title":"CommonJs规范(在node中使用)","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Node.js/Node 的核心模块/模块系统.md","filePath":"docs/Node.js/Node 的核心模块/模块系统.md","lastUpdated":1712646874000}'),o={name:"docs/Node.js/Node 的核心模块/模块系统.md"};function p(r,s,c,t,i,d){return l(),a("div",null,s[0]||(s[0]=[e(`<h1 id="commonjs规范-在node中使用" tabindex="-1">CommonJs规范(在node中使用) <a class="header-anchor" href="#commonjs规范-在node中使用" aria-label="Permalink to &quot;CommonJs规范(在node中使用)&quot;">​</a></h1><h2 id="一、commonjs的特点" tabindex="-1">一、CommonJs的特点 <a class="header-anchor" href="#一、commonjs的特点" aria-label="Permalink to &quot;一、CommonJs的特点&quot;">​</a></h2><ul><li>commonJS 规范是同步的加载</li></ul><ol><li>会出现浏览器假死的现象</li><li>因为是同步的加载，就可以完全被当做同步代码来使用</li><li>运行时导入(和 ES6 module 进行区分)( require 可以定义在 if 语句中)</li></ol><ul><li>无论一个模块在 require 中被引用了多次，模块只会被加载一次。</li><li>CSS 模块加载的时候，不必使用变量接受。JS 模块使用变量接受是因为有时候需要在程序的某处被调用，或者被添加参数调用。而 CSS 只要被加载之后就能起作用了。</li><li>加载一个模块的时候，即使没有公共的接口，也会执行模块体中的代码。</li><li>在 Node 中一个文件就是一个模块，每个文件模块都是一个对象</li><li>Node 中 commonJS 的 <code>本质</code> 就是 <code>对象的引用赋值</code> (导入模块拿到的就是导出模块的 <code>module.exports</code> 对象的 <code>引用地址</code> )</li><li>多个模块之间相互引用时，模块的加载顺序: 将模块的互相引用看成一个图的结构，加载顺序就是图的深度优先遍历</li></ul><h3 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 导出多个值</span></span>
<span class="line"><span style="color:#005CC5;">module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    name,</span></span>
<span class="line"><span style="color:#24292E;">    phone</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 导出多个值</span></span>
<span class="line"><span style="color:#005CC5;">module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#24292E;">.a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name;</span></span>
<span class="line"><span style="color:#005CC5;">module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#24292E;">.b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> phone;</span></span>
<span class="line"><span style="color:#6A737D;">// 导出单个值</span></span>
<span class="line"><span style="color:#005CC5;">module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#D73A49;"> =</span><span style="color:#032F62;"> &quot;xujie&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 用变量接收</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> module </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;./tool.js&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6A737D;">// 使用解构赋值接收</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> { name, phone } </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;./tool.js&quot;</span><span style="color:#24292E;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="module-exports-和-exports-的区别" tabindex="-1">module.exports 和 exports 的区别 <a class="header-anchor" href="#module-exports-和-exports-的区别" aria-label="Permalink to &quot;module.exports 和 exports 的区别&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">//  module.exports 才是真正被导出的东西</span></span>
<span class="line"><span style="color:#005CC5;">module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">  ...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 额外声明了一个 exports 对象，exports 的引用指向 module.exports 的堆内存</span></span>
<span class="line"><span style="color:#6A737D;">// 目的是为了同 commonJS 规范一致(commonJS 规定要用 exports 语句导出内容)</span></span>
<span class="line"><span style="color:#005CC5;">exports</span><span style="color:#D73A49;"> =</span><span style="color:#005CC5;"> module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 这样使用是没有问题的，因为操作的是同一个堆内存</span></span>
<span class="line"><span style="color:#005CC5;">exports</span><span style="color:#24292E;">.a </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &#39;xu&#39;</span></span>
<span class="line"><span style="color:#005CC5;">exports</span><span style="color:#24292E;">.b </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &#39;jie&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 不可以这样使用，改变了 exports 对象对应的堆内存地址，exports 将和 module.exports 失去关系</span></span>
<span class="line"><span style="color:#6A737D;">// 最终导出的是 module.exports 堆内存数据，而不是 exports 的堆内存数据</span></span>
<span class="line"><span style="color:#005CC5;">exports</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  a,</span></span>
<span class="line"><span style="color:#24292E;">  b</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="二、node-的模块" tabindex="-1">二、node 的模块 <a class="header-anchor" href="#二、node-的模块" aria-label="Permalink to &quot;二、node 的模块&quot;">​</a></h2><ul><li>核心模块(会被预先放到内存中，加载速度较快) 和 文件模块</li><li>不论是核心模块还是文件模块，require() 方法对相同模块的 <code>二次加载</code> 都一律采用 <code>缓存优先</code> 的方式，这是 <code>第一优先级</code> 的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。</li><li>加载顺序： 核心模块(http path 等) &gt; 文件模块(相对路径 &amp; 绝对路径) &gt; 非路径形式文件模块(去 node_modules 中查找)</li><li>node 允许 <code>路径标识符</code> 中省略扩展名 并且依次按照 <code>.js .json .node</code> 进行尝试，如果找不到对应 <code>文件</code> 的话会把 <code>路径标识符</code> 看作一个 <code>目录</code>，然后依次查找目录下的 <code>index.js index.json index.node</code></li><li>找到对应的模块后对模块进行编译。每一个编译成功的模块都会将其文件路径作为索引缓存在 <code>Module._cache</code> 对象上，以提高 <code>二次引入</code> 的性能。</li></ul><h2 id="三、node-的包文件" tabindex="-1">三、node 的包文件 <a class="header-anchor" href="#三、node-的包文件" aria-label="Permalink to &quot;三、node 的包文件&quot;">​</a></h2><ul><li>package.json 包描述文件</li><li>bin 用于存放可执行二进制文件的目录</li><li>lib 用于存放 JS 代码的目录</li><li>npm ls 可以用来分析当前目录下可以引入哪些包</li></ul>`,13)]))}const b=n(o,[["render",p]]);export{m as __pageData,b as default};
