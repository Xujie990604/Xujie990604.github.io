import{_ as n,c as a,o as l,ag as p}from"./chunks/framework.BDwTZuFy.js";const e="/assets/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%B5%81%E7%A8%8B.DbbMnJoR.png",d=JSON.parse('{"title":"Vue 的响应式数据","description":"","frontmatter":{},"headers":[],"relativePath":"docs/技术文档总结/Vue框架/Vue的响应式数据.md","filePath":"docs/技术文档总结/Vue框架/Vue的响应式数据.md","lastUpdated":1728394549000}'),o={name:"docs/技术文档总结/Vue框架/Vue的响应式数据.md"};function r(c,s,t,i,y,b){return l(),a("div",null,s[0]||(s[0]=[p(`<h1 id="vue-的响应式数据" tabindex="-1">Vue 的响应式数据 <a class="header-anchor" href="#vue-的响应式数据" aria-label="Permalink to &quot;Vue 的响应式数据&quot;">​</a></h1><h2 id="一、响应式数据" tabindex="-1">一、响应式数据 <a class="header-anchor" href="#一、响应式数据" aria-label="Permalink to &quot;一、响应式数据&quot;">​</a></h2><ul><li>当数据发生变化时，会自动执行某些动作去更新 DOM 节点(需要明确更新 DOM 的时机，也就是说明需要拦截<code>响应式数据</code>的<code>设置</code>操作，需要明确有哪些 DOM 需要被更新，也就是说明需要拦截<code>响应式数据</code>的<code>读取</code>操作)</li><li><code>Vue2</code> 使用 <code>Object.defineProperty</code> 实现数据代理，<code>Vue3</code> 使用 <code>Proxy</code> 实现数据代理</li></ul><h2 id="二、vue2-的响应式原理" tabindex="-1">二、Vue2 的响应式原理 <a class="header-anchor" href="#二、vue2-的响应式原理" aria-label="Permalink to &quot;二、Vue2 的响应式原理&quot;">​</a></h2><h3 id="_2-1-observer-类" tabindex="-1">2.1 Observer 类 <a class="header-anchor" href="#_2-1-observer-类" aria-label="Permalink to &quot;2.1 Observer 类&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> defineReactive</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">, </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, </span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 每个 key 值对应的依赖，存储在 dep 实例中</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> dep </span><span style="color:#D73A49;">=</span><span style="color:#D73A49;"> new</span><span style="color:#6F42C1;"> Dep</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  Object.</span><span style="color:#6F42C1;">defineProperty</span><span style="color:#24292E;">(obj, key, {</span></span>
<span class="line"><span style="color:#24292E;">    configurable: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    enumerable: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#6F42C1;">    get</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6A737D;">      // 收集依赖</span></span>
<span class="line"><span style="color:#24292E;">      dep.</span><span style="color:#6F42C1;">depend</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#D73A49;">      return</span><span style="color:#24292E;"> value;</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#6F42C1;">    set</span><span style="color:#24292E;">(</span><span style="color:#E36209;">newValue</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newValue;</span></span>
<span class="line"><span style="color:#6A737D;">      // 触发依赖</span></span>
<span class="line"><span style="color:#24292E;">      dep.</span><span style="color:#6F42C1;">notify</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="_2-2-dep-类" tabindex="-1">2.2 Dep 类 <a class="header-anchor" href="#_2-2-dep-类" aria-label="Permalink to &quot;2.2 Dep 类&quot;">​</a></h3><ul><li>可以简化看成是一个用来存储回调函数的数组</li><li>Window.target 是一个全局变量，方便依赖的收集</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 定义一个 dep 类，专门用来管理依赖</span></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#6F42C1;"> Dep</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">  constructor</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#005CC5;">    this</span><span style="color:#24292E;">.subs </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [];</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#6F42C1;">  addSub</span><span style="color:#24292E;">(</span><span style="color:#E36209;">sub</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#005CC5;">    this</span><span style="color:#24292E;">.subs.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(sub);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#6F42C1;">  removeSub</span><span style="color:#24292E;">(</span><span style="color:#E36209;">sub</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6F42C1;">    remove</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.subs, sub);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#6F42C1;">  depend</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">    if</span><span style="color:#24292E;"> (window.target) {</span></span>
<span class="line"><span style="color:#005CC5;">      this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">addSub</span><span style="color:#24292E;">(window.target);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#6A737D;">  // 循环触发 dep 实例中依赖的 update 方法</span></span>
<span class="line"><span style="color:#6F42C1;">  notify</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">    const</span><span style="color:#005CC5;"> subs</span><span style="color:#D73A49;"> =</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.subs.</span><span style="color:#6F42C1;">slice</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">    // 循环的触发所有依赖</span></span>
<span class="line"><span style="color:#D73A49;">    for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> index </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> 0</span><span style="color:#24292E;">; index </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> subs.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">; index</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      subs[i].</span><span style="color:#6F42C1;">update</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="_2-3-watcher-类" tabindex="-1">2.3 Watcher 类 <a class="header-anchor" href="#_2-3-watcher-类" aria-label="Permalink to &quot;2.3 Watcher 类&quot;">​</a></h3><ul><li>watcher 是一个中介的角色，数据发生变化时通知它，然后它再通知其他地方</li><li>三种 watcher: 1. 组件的 render watcher 2. 计算属性 watcher 3. $watcher 对应的 watcher</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#6F42C1;"> Watcher</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">  constructor</span><span style="color:#24292E;">(</span><span style="color:#E36209;">vm</span><span style="color:#24292E;">, </span><span style="color:#E36209;">expOrFn</span><span style="color:#24292E;">, </span><span style="color:#E36209;">callback</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#005CC5;">    this</span><span style="color:#24292E;">.vm </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> vm;</span></span>
<span class="line"><span style="color:#005CC5;">    this</span><span style="color:#24292E;">.callback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> callback;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // 执行 this.getter() ，就可以读取某个属性的值</span></span>
<span class="line"><span style="color:#005CC5;">    this</span><span style="color:#24292E;">.getter </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> parsePath</span><span style="color:#24292E;">(expOrFn);</span></span>
<span class="line"><span style="color:#6A737D;">    // 在实例化一个 watcher 实例的时候，会自动执行 get 方法</span></span>
<span class="line"><span style="color:#005CC5;">    this</span><span style="color:#24292E;">.value </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#6F42C1;">  get</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    window.target </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">    let</span><span style="color:#24292E;"> value </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.getter.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.vm, </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.vm);</span></span>
<span class="line"><span style="color:#24292E;">    window.target </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> undefined</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#24292E;"> value;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#6F42C1;">  update</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">    const</span><span style="color:#005CC5;"> oldValue</span><span style="color:#D73A49;"> =</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.value;</span></span>
<span class="line"><span style="color:#005CC5;">    this</span><span style="color:#24292E;">.value </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#005CC5;">    this</span><span style="color:#24292E;">.callback.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.vm, </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.value, oldValue);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="_2-4-响应式系统的整体流程" tabindex="-1">2.4 响应式系统的整体流程 <a class="header-anchor" href="#_2-4-响应式系统的整体流程" aria-label="Permalink to &quot;2.4 响应式系统的整体流程&quot;">​</a></h3><p><img src="`+e+`" alt="响应式流程"></p><ul><li>(1) 页面初始化时</li></ul><ol><li>Observer 类会附加到每一个 object 上。递归的调用 defineReactive 函数将每一个属性都通过 <code>Object.defineProperty()</code> 进行数据拦截。</li><li>在<code>读取数据</code>时会<code>收集依赖</code>，在<code>修改数据</code>后会<code>触发依赖</code>。</li><li>每一个属性都会拥有一个独立的 Dep 实例</li></ol><ul><li>(2) 页面使用数据时</li></ul><ol><li>使用响应式数据时会<code>实例化</code>一个 Watcher</li><li>在 new Watcher 的过程中会<code>触发依赖收集</code>，从而将 watcher 实例放到响应式属性的 dep 中</li></ol><ul><li>(3) 改变数据后</li></ul><ol><li>改变数据会<code>触发依赖执行</code>，执行当前响应式属性的 dep 数组中的所有 watcher 的 update 方法</li><li>watcher 的回调函数可能是执行<code>组件的 render 函数</code>，也可以是执行<code>用户自定义的回调函数</code></li></ol><h3 id="_2-5-数组的响应式处理" tabindex="-1">2.5 数组的响应式处理 <a class="header-anchor" href="#_2-5-数组的响应式处理" aria-label="Permalink to &quot;2.5 数组的响应式处理&quot;">​</a></h3><ul><li>出于性能和业务场景（大多数情况下是通过方法来改变数组，而非直接操作 key/index 来改变数组）的考虑。数组不会针对每一条数据使用 Object.defineProperty() 进行数据拦截。</li><li>数组的响应式处理为在 <code>get</code> 中<code>收集依赖</code>，在<code>数组方法</code>中<code>触发依赖</code>。</li><li>重写七个可改变数组的方法</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 一、基于 Array.prototype 实现重写数组方法</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> arrayProto</span><span style="color:#D73A49;"> =</span><span style="color:#005CC5;"> Array</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> arrayMethods</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> Object.</span><span style="color:#6F42C1;">create</span><span style="color:#24292E;">(arrayProto)[</span></span>
<span class="line"><span style="color:#24292E;">  (</span><span style="color:#032F62;">&quot;push&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;pop&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;shift&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;unshift&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;splice&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;sort&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;reverse&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">].</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">method</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 1. 借用 Array.prototype 上的方法, 实现原本的功能</span></span>
<span class="line"><span style="color:#6A737D;">  // 2. 在修改数据的同时发送通知</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 二、使用__proto__ 替换响应式数组的原型</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> arr</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> [];</span></span>
<span class="line"><span style="color:#24292E;">arr.</span><span style="color:#005CC5;">__proto__</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> arrayMethods;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="_2-6-vue2-响应式数据的缺陷" tabindex="-1">2.6 Vue2 响应式数据的缺陷 <a class="header-anchor" href="#_2-6-vue2-响应式数据的缺陷" aria-label="Permalink to &quot;2.6 Vue2 响应式数据的缺陷&quot;">​</a></h3><h4 id="_1-缺陷的体现" tabindex="-1">(1) 缺陷的体现 <a class="header-anchor" href="#_1-缺陷的体现" aria-label="Permalink to &quot;(1) 缺陷的体现&quot;">​</a></h4><ol><li>由于 Vue 会在实例初始化的时候对 property 进行 getter/setter 转化。所以只有在一开始就存在 data 中的数据才是响应式的。(比如在组件的 created, beforeCreate 钩子函数中为组件添加一个属性，这个数据不是响应式的数据)</li><li>对象: Object.defineProperty 只能追踪一个属性<code>是否被更改</code>。在一个对象中<code>添加</code>一个新属性，使用 <code>delete 删除</code>一个属性的时候<code>不会触发响应式</code>。</li><li>数组：push()、pop()、shift()、unshift()、splice()、sort()、reverse()称为变更方法，<code>会触发视图更新</code>。数组<code>长度的变化</code>是<code>非响应式</code>的。例如，<code>arr.length = 4</code>。通过<code>索引</code>来直接修改数组中的数据也是<code>非响应式</code>的。例如，<code>arr[2] = &#39;foo&#39;</code></li></ol><h4 id="_2-缺陷的解决方案" tabindex="-1">(2) 缺陷的解决方案 <a class="header-anchor" href="#_2-缺陷的解决方案" aria-label="Permalink to &quot;(2) 缺陷的解决方案&quot;">​</a></h4><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 对象上使用 $set 方法，实际上就是 Vue 手动去调用响应式的方法，手动的将新增的属性变成响应式的</span></span>
<span class="line"><span style="color:#032F62;">\`Vue.set(object, &#39;key&#39;, &#39;value&#39;)\`</span><span style="color:#6A737D;"> // 对象上使用 $delete 方法，实际上就是 Vue 手动的去触发依赖，通知所有使用到该对象的组件去重新渲染</span></span>
<span class="line"><span style="color:#032F62;">\`Vue.delete(object, &#39;key&#39;)\`</span><span style="color:#24292E;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="三、vue3-的响应式原理" tabindex="-1">三、Vue3 的响应式原理 <a class="header-anchor" href="#三、vue3-的响应式原理" aria-label="Permalink to &quot;三、Vue3 的响应式原理&quot;">​</a></h2><h3 id="_3-1-使用-proxy-监听对象的行为" tabindex="-1">3.1 使用 proxy 监听对象的行为 <a class="header-anchor" href="#_3-1-使用-proxy-监听对象的行为" aria-label="Permalink to &quot;3.1 使用 proxy 监听对象的行为&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 一、存储副作用函数的桶</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> bucket</span><span style="color:#D73A49;"> =</span><span style="color:#D73A49;"> new</span><span style="color:#6F42C1;"> Set</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 二、原始数据</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> data</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> { text: </span><span style="color:#032F62;">&quot;hello world&quot;</span><span style="color:#24292E;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 三、对原始数据的代理</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> obj</span><span style="color:#D73A49;"> =</span><span style="color:#D73A49;"> new</span><span style="color:#6F42C1;"> Proxy</span><span style="color:#24292E;">(data, {</span></span>
<span class="line"><span style="color:#6A737D;">  // 拦截读取操作</span></span>
<span class="line"><span style="color:#6F42C1;">  get</span><span style="color:#24292E;">(</span><span style="color:#E36209;">target</span><span style="color:#24292E;">, </span><span style="color:#E36209;">key</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 将副作用函数 effect 添加到存储副作用函数的桶中</span></span>
<span class="line"><span style="color:#24292E;">    bucket.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(effect);</span></span>
<span class="line"><span style="color:#6A737D;">    // 返回属性值</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#24292E;"> target[key];</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#6A737D;">  // 拦截设置操作</span></span>
<span class="line"><span style="color:#6F42C1;">  set</span><span style="color:#24292E;">(</span><span style="color:#E36209;">target</span><span style="color:#24292E;">, </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, </span><span style="color:#E36209;">newVal</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 设置属性值</span></span>
<span class="line"><span style="color:#24292E;">    target[key] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newVal;</span></span>
<span class="line"><span style="color:#6A737D;">    // 把副作用函数从桶里取出并执行</span></span>
<span class="line"><span style="color:#24292E;">    bucket.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">((</span><span style="color:#E36209;">fn</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#6F42C1;"> fn</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#6A737D;">    // 返回 true 代表设置操作成功</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#005CC5;"> true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 四、测试</span></span>
<span class="line"><span style="color:#6A737D;">// 副作用函数</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> effect</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  document.body.innerText </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> obj.text;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 执行副作用函数，触发读取</span></span>
<span class="line"><span style="color:#6F42C1;">effect</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 1 秒后修改响应式数据</span></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  obj.text </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &quot;hello vue3&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h3 id="_4-2-proxy-和-object-defineproperty-对比" tabindex="-1">4.2 Proxy 和 Object.defineProperty() 对比 <a class="header-anchor" href="#_4-2-proxy-和-object-defineproperty-对比" aria-label="Permalink to &quot;4.2 Proxy 和 Object.defineProperty() 对比&quot;">​</a></h3><ol><li>通过 Proxy（代理）能够拦截对象中任意属性的变化, 包括属性值的<code>读写</code>、属性的<code>添加</code>、属性的<code>删除</code>等。</li><li>Vue3 对于响应式数据，不在像 Vue2 那种递归对所有的子数据进行影响是定义。而是在获取到深层数据的时候再去利用 proxy 进一步定义响应式，这对于大量数据的初始化场景来说收益会非常大。</li><li>Proxy 是 ES6 的语法，兼容性较差。不支持 IE 11</li></ol>`,33)]))}const E=n(o,[["render",r]]);export{d as __pageData,E as default};
