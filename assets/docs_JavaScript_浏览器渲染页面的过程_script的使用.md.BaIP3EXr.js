import{_ as c,c as o,o as d,ag as a}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"在 HTML 中使用 javascript","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/浏览器渲染页面的过程/script的使用.md","filePath":"docs/JavaScript/浏览器渲染页面的过程/script的使用.md","lastUpdated":1735478813000}'),t={name:"docs/JavaScript/浏览器渲染页面的过程/script的使用.md"};function i(l,e,r,s,n,p){return d(),o("div",null,e[0]||(e[0]=[a('<h1 id="在-html-中使用-javascript" tabindex="-1">在 HTML 中使用 javascript <a class="header-anchor" href="#在-html-中使用-javascript" aria-label="Permalink to &quot;在 HTML 中使用 javascript&quot;">​</a></h1><h2 id="script-元素" tabindex="-1"><code>&lt;script&gt;</code>元素 <a class="header-anchor" href="#script-元素" aria-label="Permalink to &quot;`&lt;script&gt;`元素&quot;">​</a></h2><h3 id="_1-src-属性" tabindex="-1">1.src 属性 <a class="header-anchor" href="#_1-src-属性" aria-label="Permalink to &quot;1.src 属性&quot;">​</a></h3><ol><li>有 src 属性时，<code>&lt;script&gt;</code> 标签内的代码会被忽略。</li><li>src 也可连接网络上的 JS 文件，下载 JS 文件时不受同源策略的影响</li></ol><h3 id="_2-普通标签" tabindex="-1">2.普通标签 <a class="header-anchor" href="#_2-普通标签" aria-label="Permalink to &quot;2.普通标签&quot;">​</a></h3><ul><li>浏览器在 <code>解析</code> 文档时遇到 <code>&lt;script&gt;</code> 节点：</li></ul><ol><li><code>JS 脚本写在标签内部</code>：会暂时停止 DOM 节点的解析，并开始 JS 代码的执行，等 JS 代码执行完毕后，继续进行 DOM 节点的解析</li><li><code>JS 脚本是外部文件</code>： 会暂时停止 DOM 节点的解析，并立刻开始下载 JS 文件并执行，等 JS 代码执行完毕后，继续进行 DOM 节点的解析(<code>下载</code>和<code>执行</code> JS 外部文件都会阻塞后续 DOM 节点的<code>解析</code>)</li></ol><ul><li>预解析操作：现代浏览器是比较智能的，虽然<code>理论上</code> JS 脚本的下载和执行<code>都会阻塞</code>后续 DOM 节点的解析，但是浏览器会偷偷瞄一眼后面的 <code>script</code> <code>link</code> <code>img</code> 等类型的标签，会提前下载资源，不会傻傻的等非得解析到这些节点才去下载</li><li><code>&lt;script&gt;</code> 本质上也是一个 DOM 节点。浏览器从上至下解析文档。<code>&lt;script&gt;</code> 放在 body 前面就会在页面显示之前下载和执行 JS 文件。(十分不推荐，浏览器窗口显示空白的时间会变长)，一般建议放在 body 标签内部的最后面，这样就会在页面内容都呈现完毕之后再 <code>下载</code> 和 <code>执行</code> JS 文件</li></ul><h3 id="_3-defer-延迟脚本" tabindex="-1">3.defer 延迟脚本 <a class="header-anchor" href="#_3-defer-延迟脚本" aria-label="Permalink to &quot;3.defer 延迟脚本&quot;">​</a></h3><ul><li>浏览器在 <code>解析</code> 文档时遇到带有 defer 属性的 <code>&lt;script&gt;</code> 节点，会开启新线程 <code>立即下载</code> 脚本文件，但是在 <code>文档解析</code> 完成之后才 <code>执行脚本文件</code></li><li>使用这个属性的目的是: 表明脚本在<code>下载时不会影响 DOM 节点的解析</code>，脚本会被延迟到<code>整个页面都解析完毕之后</code>在运行。(<code>页面解析</code>完毕不是<code>页面加载</code>完毕)</li><li>多个设置了 defer 属性的脚本会 <code>按照书写的先后顺序执行</code></li><li>defer 相比较于普通的 script 标签的优点是：JS 文件的<code>下载</code>不会阻塞后续 DOM 的<code>解析</code></li><li>仅适用于加载外部脚本文件，不能把 JS 脚本写在 script 中</li></ul><h3 id="_4-async-异步脚本" tabindex="-1">4.async 异步脚本 <a class="header-anchor" href="#_4-async-异步脚本" aria-label="Permalink to &quot;4.async 异步脚本&quot;">​</a></h3><ul><li>浏览器在 <code>解析</code> 文档时遇到带有 async 属性的 <code>&lt;script&gt;</code> 标签。会开启新线程 <code>立即下载</code> 脚本文件，下载完毕之后立刻执行。</li><li>使用这个属性的目的是: 表明脚本在<code>下载时不会影响 DOM 节点的解析</code>。脚本会在下载完之后立刻执行。(因此建议在异步的脚本中不要包含修改 DOM 的行为, 因为不确定涉及的 DOM 此时有没有被解析到)</li><li>多个设置了 async 属性的脚本 <code>并不会按照书写的先后顺序执行</code>，因此保证多个异步脚本之间互不依赖很重要。</li><li>因为 async 的<code>下载完立刻执行</code>与<code>不会按照书写的先后顺序执行</code>这两个特点，在 WEB 项目中不推荐使用</li><li>仅适用于加载外部脚本文件，不能把 JS 脚本写在 script 中</li></ul><h3 id="_5-动态引入的标签" tabindex="-1">5.动态引入的标签 <a class="header-anchor" href="#_5-动态引入的标签" aria-label="Permalink to &quot;5.动态引入的标签&quot;">​</a></h3><ul><li>使用 <code>document.createElement</code> 创建的 <code>script</code> 标签，默认 <code>async = true defer = false</code></li><li>即使把 <code>async</code> 和 <code>defer</code> 都设置为 <code>false</code>。 动态创建的标签也不会像写在 <code>HTML</code> 文件中的 <code>script</code> 标签(下载和执行都会阻塞后续 DOM 的解析)一样。动态创建的 <code>script</code> 加载过程一定是异步(无法变成同步)</li></ul><h3 id="_6-type" tabindex="-1">6. type <a class="header-anchor" href="#_6-type" aria-label="Permalink to &quot;6. type&quot;">​</a></h3><ul><li>type 为 module 时，代码会被当成 ES6 模块，而且只有这时代码中才能出现 import 和 export 关键字</li></ul><h2 id="noscript" tabindex="-1"><code>&lt;noscript&gt;</code> <a class="header-anchor" href="#noscript" aria-label="Permalink to &quot;```&lt;noscript&gt;```&quot;">​</a></h2><ul><li>标签里面的内容只有特定情况下才会显示</li></ul><ol><li>浏览器不支持脚本</li><li>浏览器支持脚本，但是脚本被禁用</li></ol>',19)]))}const _=c(t,[["render",i]]);export{u as __pageData,_ as default};
