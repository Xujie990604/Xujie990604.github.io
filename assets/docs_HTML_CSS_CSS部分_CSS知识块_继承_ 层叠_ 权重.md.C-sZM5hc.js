import{_ as i,c as a,o as e,ag as t}from"./chunks/framework.BDwTZuFy.js";const _=JSON.parse('{"title":"css的三大特性","description":"","frontmatter":{},"headers":[],"relativePath":"docs/HTML+CSS/CSS部分/CSS知识块/继承+ 层叠+ 权重.md","filePath":"docs/HTML+CSS/CSS部分/CSS知识块/继承+ 层叠+ 权重.md","lastUpdated":1712646874000}'),s={name:"docs/HTML+CSS/CSS部分/CSS知识块/继承+ 层叠+ 权重.md"};function o(r,l,c,n,h,d){return e(),a("div",null,l[0]||(l[0]=[t('<h1 id="css的三大特性" tabindex="-1">css的三大特性 <a class="header-anchor" href="#css的三大特性" aria-label="Permalink to &quot;css的三大特性&quot;">​</a></h1><h2 id="层叠" tabindex="-1">层叠 <a class="header-anchor" href="#层叠" aria-label="Permalink to &quot;层叠&quot;">​</a></h2><ul><li>css 的规则的编写顺序不同，也会导致样式的不一样，层叠样式表的含义就是 css 是一层一层绘制的，<strong>联级：两个相同的特异性规则，排在后面的哪个css样式将会被使用。</strong></li><li>html<code>@import &#39;style.css&#39;;</code>用于把其他的样式表导入主样式表。，需要注意的是，不同的 css 样式文件进行引入的时候，样式文件的引用顺序相当于规则的书写顺序。</li><li>后备 css 属性实现向下兼容。用到的就是 css 的这个特性。</li><li>链接的几个伪类的顺序严格要求也是因为 css 的这个特性。</li></ul><h3 id="简写属性的使用" tabindex="-1">简写属性的使用 <a class="header-anchor" href="#简写属性的使用" aria-label="Permalink to &quot;简写属性的使用&quot;">​</a></h3><ul><li>需要格外的注意，因为简写属性中没有涉及到的属性就会被设置为默认值，在加上 css 的层叠次序这个特性。</li><li>简写属性必须要放置在最前面，然后在使用细分的属性来覆盖前面的简写属性中的单个属性。</li><li>要是简写属性放在个细分属性的后面，细分的属性就会被简写的覆盖。</li></ul><h2 id="css权重-256进制相加" tabindex="-1">css权重： 256进制相加 <a class="header-anchor" href="#css权重-256进制相加" aria-label="Permalink to &quot;css权重： 256进制相加&quot;">​</a></h2><ol><li>！important 无穷大 放置在一条规则的分号前面(color: red !important;)</li><li>行间样式 1000</li><li>id选择器 100</li><li>类选择器|属性|伪类 10</li><li>标签|伪元素 1</li><li>通配符 * 0</li><li>继承 没有权重</li></ol><ul><li>作者样式权重 大于 用户样式权重 大于 浏览器默认样式权重。</li><li>p.header 的 css 权重为 10 + 1.而不是选用最高的 10</li><li>伪类的顺序为:link :visited :hover :focus :active 这是因为他们都是伪类选择器，css 权重一样，当后面的 css 规则成立时。会覆盖前面的样式。</li><li>最好的做法就是从一开始就简化选择符，降低特殊性。使得 css 代码更加的易/维护。更加可控。</li></ul><h2 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h2><ul><li>继承的权重比零还要小，是无。</li></ul><h3 id="常见的可继承属性" tabindex="-1">常见的可继承属性 <a class="header-anchor" href="#常见的可继承属性" aria-label="Permalink to &quot;常见的可继承属性&quot;">​</a></h3><h4 id="字体系列" tabindex="-1">字体系列 <a class="header-anchor" href="#字体系列" aria-label="Permalink to &quot;字体系列&quot;">​</a></h4><ul><li>font 组合字体</li><li>font-family 元素的字体</li><li>font-weight 字体的粗细</li><li>font-size 字体的尺寸 (使用em的时候因为继承的都是数值，会出现多次继承的问题)</li><li>font-style 字体的风格</li></ul><h4 id="文本系列的属性" tabindex="-1">文本系列的属性 <a class="header-anchor" href="#文本系列的属性" aria-label="Permalink to &quot;文本系列的属性&quot;">​</a></h4><ul><li>text-indent 文字的缩进</li><li>text-align 文字水平对齐</li><li>text-shadow 文本阴影</li><li>line-height 行高 (使用带单位的时候继承的是具体的数字，很可能子元素的 font-size 大小已经发生了变化，父元素的 line-height 不是很合适，但是你要是使用无单位数字，就会很银杏，无论子元素的字体变成了多大，行高都是字体大小的倍数)</li><li>color 颜色</li></ul><h3 id="常见的问题" tabindex="-1">常见的问题 <a class="header-anchor" href="#常见的问题" aria-label="Permalink to &quot;常见的问题&quot;">​</a></h3><ul><li>text-align。text-indent 在块级元素中可以被继承，在行级元素中不能被继承。</li><li>a 标签的字体颜色不能继承。因为有默认值</li><li>h1 - h6 的字体大小也不能被继承，因为有默认值</li></ul>',17)]))}const f=i(s,[["render",o]]);export{_ as __pageData,f as default};
