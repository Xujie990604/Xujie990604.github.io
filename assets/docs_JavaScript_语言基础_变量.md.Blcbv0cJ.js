import{_ as l,c as e,o,ag as i}from"./chunks/framework.BDwTZuFy.js";const _=JSON.parse('{"title":"变量","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/语言基础/变量.md","filePath":"docs/JavaScript/语言基础/变量.md","lastUpdated":1735478813000}'),t={name:"docs/JavaScript/语言基础/变量.md"};function r(c,a,n,d,s,h){return o(),e("div",null,a[0]||(a[0]=[i('<h1 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-label="Permalink to &quot;变量&quot;">​</a></h1><ul><li>JavaScript 中的变量是<code>松散类型</code>: 能保存任何类型的数据。</li><li>可以在修改变量的值的同时修改变量的类型, 但是不推荐。</li><li>申请多条变量，使用逗号隔开。 var a = 0, b = 0;</li></ul><h2 id="一、作用域" tabindex="-1">一、作用域 <a class="header-anchor" href="#一、作用域" aria-label="Permalink to &quot;一、作用域&quot;">​</a></h2><ol><li>Global 作用域(全局作用域、window)</li><li>Local 作用域(函数作用域，局部作用域)</li><li>Block 作用域(ES6 新增、块级作用域、let const使用、只有有 <code>{}</code> 就算是新的)</li><li>Script 作用域(ES6 新增、<code>全局的块级作用域</code>、let const 使用)</li></ol><h2 id="二、var" tabindex="-1">二、var <a class="header-anchor" href="#二、var" aria-label="Permalink to &quot;二、var&quot;">​</a></h2><h3 id="_2-1-声明作用域" tabindex="-1">2.1 声明作用域 <a class="header-anchor" href="#_2-1-声明作用域" aria-label="Permalink to &quot;2.1 声明作用域&quot;">​</a></h3><ul><li>使用 var 声明的变量会成为包含它的函数的局部变量</li><li>声明变量时省略 var 操作符，会创建一个全局的变量 <code>!JS设计糟粕</code></li></ul><h3 id="_2-2-声明提升" tabindex="-1">2.2 声明提升 <a class="header-anchor" href="#_2-2-声明提升" aria-label="Permalink to &quot;2.2 声明提升&quot;">​</a></h3><ul><li>使用 var 声明的变量会自动提升到函数作用域顶部</li><li><code>var a = 1;</code> 只有 <code>var a;</code> 会提升 <code>a = 1</code> 不会提升，在声明前访问变量的值为 undefined</li></ul><h2 id="三、let" tabindex="-1">三、let <a class="header-anchor" href="#三、let" aria-label="Permalink to &quot;三、let&quot;">​</a></h2><ol><li>声明作用域: 只在命令所在的块级作用域有效</li><li>不存在变量提升: 在声明之前使用变量会报错。</li><li>暂时性死区: 只要块级作用域内有 let 和 const 命令，不会受到外部全局变量的影响。声明之前就使用会报错。</li><li>不允许重复说明: 不允许在相同的作用域内，重复声明同一个变量。</li></ol><h2 id="四、const" tabindex="-1">四、const <a class="header-anchor" href="#四、const" aria-label="Permalink to &quot;四、const&quot;">​</a></h2><ol><li>const 声明一个只读的常量，值不能改变，一旦声明必须赋值。</li><li>声明作用域: 只在命令所在的块级作用域有效</li><li>没有变量提升，有暂时性死区。</li><li>不可重复声明</li></ol><h3 id="_4-1-const-常量本质" tabindex="-1">4.1 const 常量本质 <a class="header-anchor" href="#_4-1-const-常量本质" aria-label="Permalink to &quot;4.1 const 常量本质&quot;">​</a></h3><ul><li>本质是 const 执行的内存地址不改变，简单类型的值就是常量，复合类型的值保证指针是不变的。</li><li>const 声明的对象可以添加属性。不可以重新赋值新的对象。实质是不改变地址。对象的属性添加不更改地址。</li><li>想要实现整个对象冻结，可以使用 <code>Object.freeze()</code> 方法</li></ul><h3 id="_4-2-const-的性能优点" tabindex="-1">4.2 const 的性能优点 <a class="header-anchor" href="#_4-2-const-的性能优点" aria-label="Permalink to &quot;4.2 const 的性能优点&quot;">​</a></h3><ol><li>V8 引擎在编译 JS 为机器码的过程中，会将变量的值直接嵌入到机器码中，而不是在运行时计算</li><li>由于 const 的不可变性，更有利于 V8 的垃圾回收机制进行处理</li></ol>',17)]))}const b=l(t,[["render",r]]);export{_ as __pageData,b as default};
