import{_ as a,c as l,o as n,ag as e}from"./chunks/framework.BDwTZuFy.js";const o="/assets/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.BwlSFaDh.png",p="/assets/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%9B%BE%E7%A4%BA.DSfEnUM5.png",r="/assets/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%BF%87%E7%A8%8B.C5yGUrae.png",E=JSON.parse('{"title":"JavaScript 事件循环机制","description":"","frontmatter":{},"headers":[],"relativePath":"docs/技术文档总结/JavaScript文档/JavaScript事件循环机制.md","filePath":"docs/技术文档总结/JavaScript文档/JavaScript事件循环机制.md","lastUpdated":1747883909000}'),t={name:"docs/技术文档总结/JavaScript文档/JavaScript事件循环机制.md"};function c(i,s,b,y,h,u){return n(),l("div",null,s[0]||(s[0]=[e('<h1 id="javascript-事件循环机制" tabindex="-1">JavaScript 事件循环机制 <a class="header-anchor" href="#javascript-事件循环机制" aria-label="Permalink to &quot;JavaScript 事件循环机制&quot;">​</a></h1><h2 id="一、进程和线程" tabindex="-1">一、进程和线程 <a class="header-anchor" href="#一、进程和线程" aria-label="Permalink to &quot;一、进程和线程&quot;">​</a></h2><p><img src="'+o+`" alt="进程和线程示意图"></p><h3 id="_1-1-进程" tabindex="-1">1.1 进程 <a class="header-anchor" href="#_1-1-进程" aria-label="Permalink to &quot;1.1 进程&quot;">​</a></h3><p>进程是一个具有一定独立功能的程序在一个数据集合上依次动态执行的过程。是操作系统进行资源分配(内存)和调度(独立运行)的基本单位</p><ol><li>动态性：进程随着程序的执行和运行而动态变化</li><li>独立性：进程与进程之间完全隔离，独立运行。一个进程崩溃不会影响其他进程。</li><li>并发性：多个进程可以在单个处理器上并发执行</li></ol><h3 id="_1-2-线程" tabindex="-1">1.2 线程 <a class="header-anchor" href="#_1-2-线程" aria-label="Permalink to &quot;1.2 线程&quot;">​</a></h3><p>是 CPU 任务调度的基本单位</p><ol><li>轻量级：线程是进程中的一个实体，创建和切换的开销更小</li><li>共享资源：同一进程内的多个线程共享进程的资源</li><li>并发性：同一个进程中的多个线程可以并发执行</li></ol><h3 id="_1-3-区别" tabindex="-1">1.3 区别 <a class="header-anchor" href="#_1-3-区别" aria-label="Permalink to &quot;1.3 区别&quot;">​</a></h3><ol><li>资源占用：进程拥有独立的内存空间和系统资源，而线程共享同一进程中的资源</li><li>开销大小：进程的创建和销毁开销比线程大</li><li>通信方式：进程间通信需要特定的机制，如管道、消息队列等。线程间通信则可以直接通过共享内存进行</li><li>依赖关系：线程依赖于进程存在。进程是线程的容器</li></ol><h2 id="二、浏览器中的进程与线程" tabindex="-1">二、浏览器中的进程与线程 <a class="header-anchor" href="#二、浏览器中的进程与线程" aria-label="Permalink to &quot;二、浏览器中的进程与线程&quot;">​</a></h2><ul><li>浏览器从启动到关闭，至少开启四个进程：<code>browser进程</code> <code>GPU进程</code> <code>网络进程</code> <code>渲染进程</code></li><li>当新增其他标签页时，<code>browser进程</code> <code>GPU进程</code> <code>网络进程</code> 进程可以共用。默认每打开一个标签页，就会开启一个 <code>渲染进程</code></li></ul><h3 id="_2-1-browser-进程" tabindex="-1">2.1 browser 进程 <a class="header-anchor" href="#_2-1-browser-进程" aria-label="Permalink to &quot;2.1 browser 进程&quot;">​</a></h3><p>负责协调、主控，只有一个</p><ol><li>负责控制浏览器除标签页外的界面。如地址栏、书签、前进后退按钮</li><li>负责创建和销毁其他进程</li></ol><h3 id="_2-2-gpu-进程" tabindex="-1">2.2 GPU 进程 <a class="header-anchor" href="#_2-2-gpu-进程" aria-label="Permalink to &quot;2.2 GPU 进程&quot;">​</a></h3><p>负责处理与图形渲染相关的任务</p><ol><li>图形渲染</li><li>动画和过渡</li><li>视频播放和解码等</li></ol><h3 id="_2-3-网络进程" tabindex="-1">2.3 网络进程 <a class="header-anchor" href="#_2-3-网络进程" aria-label="Permalink to &quot;2.3 网络进程&quot;">​</a></h3><p>负责处理与网络相关的任务。它主要负责管理和维护网络连接，以及处理所有的网络请求和响应</p><ol><li>管理网络连接</li><li>处理网络请求和响应</li><li>处理 DNS 解析</li><li>处理缓存</li></ol><h3 id="_2-4-插件进程" tabindex="-1">2.4 插件进程 <a class="header-anchor" href="#_2-4-插件进程" aria-label="Permalink to &quot;2.4 插件进程&quot;">​</a></h3><p>用于处理浏览器插件的进程（每个插件，就会创建一个进程，避免由于其中一个插件进程的崩溃导致整个浏览器崩溃）</p><h3 id="_2-5-渲染进程" tabindex="-1">2.5 渲染进程 <a class="header-anchor" href="#_2-5-渲染进程" aria-label="Permalink to &quot;2.5 渲染进程&quot;">​</a></h3><p>负责将 HTML、CSS 和 JavaScript 转换为可视化的页面。默认情况下，有一个浏览器的 tab 就会创建一个渲染进程。(<code>本文需要介绍的重点</code>)</p><h2 id="三、浏览器中的渲染进程" tabindex="-1">三、浏览器中的渲染进程 <a class="header-anchor" href="#三、浏览器中的渲染进程" aria-label="Permalink to &quot;三、浏览器中的渲染进程&quot;">​</a></h2><p>页面的渲染，JS 的执行，事件的循环，都在这个进程内进行，浏览器的渲染进程是多线程的。</p><p>TODO：AI 查询的结果，说 UI渲染和JS执行不是两个线程，而是都在主线程执行。但是目前文档中说UI渲染和JS执行是两个线程吗，只不过两个线程是互斥的。 TODO：虽然说不影响最终的结论（UI和JS不能同时进行），但是毕竟是核心概念，还是要明确一下。</p><h3 id="_3-1-gui-渲染线程" tabindex="-1">3.1 GUI 渲染线程 <a class="header-anchor" href="#_3-1-gui-渲染线程" aria-label="Permalink to &quot;3.1 GUI 渲染线程&quot;">​</a></h3><ol><li>负责渲染浏览器界面，解析 HTML、CSS。构建 DOM Tree、CSSOM Tree、Render Tree。页面的布局和绘制</li><li>当界面需要重绘（Repaint)或由于某种操作引发回流(reflow)时，该线程也会执行</li><li>GUI 的更新会被保存在一个队列之中，等到 JS 引擎线程空闲时，GUI 线程就会立即执行</li></ol><h3 id="_3-2-js-引擎线程" tabindex="-1">3.2 JS 引擎线程 <a class="header-anchor" href="#_3-2-js-引擎线程" aria-label="Permalink to &quot;3.2 JS 引擎线程&quot;">​</a></h3><ol><li>也称为 JS 内核，负责解析 Javascript 脚本，运行代码。最出名的便数 V8 引擎</li><li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理。</li></ol><h3 id="_3-3-定时器触发线程" tabindex="-1">3.3 定时器触发线程 <a class="header-anchor" href="#_3-3-定时器触发线程" aria-label="Permalink to &quot;3.3 定时器触发线程&quot;">​</a></h3><ol><li>定时器函数: setInterval 与 setTimeout</li><li>浏览器定时计数器并不是由 JS 引擎计数的（因为 JS 引擎是单线程的, 如果该线程处于阻塞状态就会影响记计时的准确）</li><li>当计时完成后，定时器的函数回调(任务)会被添加到事件队列中，等待 JS 引擎空闲后去执行</li></ol><h3 id="_3-4-异步-http-线程" tabindex="-1">3.4 异步 HTTP 线程 <a class="header-anchor" href="#_3-4-异步-http-线程" aria-label="Permalink to &quot;3.4 异步 HTTP 线程&quot;">​</a></h3><ol><li>XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li><li>当检测到 HTTP 请求的状态发生变化后，HTTP 请求的函数回调(任务)会被添加到事件队列中，等待 JS 引擎空闲后去执行</li></ol><h3 id="_3-5-事件触发线程" tabindex="-1">3.5 事件触发线程 <a class="header-anchor" href="#_3-5-事件触发线程" aria-label="Permalink to &quot;3.5 事件触发线程&quot;">​</a></h3><ol><li>用来控制事件循环(Event Loop)的线程</li><li>周期性的检查事件队列中是否存在任务，并主动触发 JS 引擎线程来处理队列中的任务</li></ol><h2 id="四、js-引擎线程和-gui-线程的互斥" tabindex="-1">四、JS 引擎线程和 GUI 线程的互斥 <a class="header-anchor" href="#四、js-引擎线程和-gui-线程的互斥" aria-label="Permalink to &quot;四、JS 引擎线程和 GUI 线程的互斥&quot;">​</a></h2><p>TODO： JS 是单线程的一些注意事项，script 标签放到 body 的末尾</p><ol><li>由于 JavaScript 是可操纵 DOM 的，如果在修改 DOM 的同时渲染界面（即 JS 引擎线程和 GUI 渲染线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JS 引擎为互斥的关系，当 JS 引擎执行时 GUI 线程会被挂起，</li><li>GUI 更新则会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行。(JS 阻塞页面加载的原因)</li></ol><h3 id="_4-1-script-标签放到-body-标签的末尾" tabindex="-1">4.1 script 标签放到 body 标签的末尾 <a class="header-anchor" href="#_4-1-script-标签放到-body-标签的末尾" aria-label="Permalink to &quot;4.1 script 标签放到 body 标签的末尾&quot;">​</a></h3><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#24292E;">&lt;!</span><span style="color:#22863A;">DOCTYPE</span><span style="color:#6F42C1;"> html</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">html</span><span style="color:#6F42C1;"> lang</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;en&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">head</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">meta</span><span style="color:#6F42C1;"> charset</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;UTF-8&quot;</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">meta</span><span style="color:#6F42C1;"> http-equiv</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;X-UA-Compatible&quot;</span><span style="color:#6F42C1;"> content</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;IE=edge&quot;</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">meta</span><span style="color:#6F42C1;"> name</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;viewport&quot;</span><span style="color:#6F42C1;"> content</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;width=device-width, initial-scale=1.0&quot;</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">title</span><span style="color:#24292E;">&gt;Document&lt;/</span><span style="color:#22863A;">title</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;/</span><span style="color:#22863A;">head</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">body</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    ......</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">script</span><span style="color:#6F42C1;"> src</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;../xxx/yyy/zzz.js&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;/</span><span style="color:#22863A;">body</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">html</span><span style="color:#24292E;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ol><li>因为 GUI 线程和 JS 引擎线程是互斥的，所以 JS 代码的加载与执行会阻塞 DOM 的解析与渲染</li><li>为了更好的用户体验(减少白屏的时间，用户能尽早看到页面)。因此需要等到页面的 DOM 标签都解析与渲染完成后，在下载和执行 JS 代码</li></ol><h2 id="五、异步任务与单线程" tabindex="-1">五、异步任务与单线程 <a class="header-anchor" href="#五、异步任务与单线程" aria-label="Permalink to &quot;五、异步任务与单线程&quot;">​</a></h2><h3 id="_5-1-同步任务" tabindex="-1">5.1 同步任务 <a class="header-anchor" href="#_5-1-同步任务" aria-label="Permalink to &quot;5.1 同步任务&quot;">​</a></h3><ol><li>某段程序执行会阻塞其他程序的执行，一定要等上一个任务执行完毕，拿到结果之后，才能执行下一个任务。</li><li>其表现形式为程序的执行顺序依赖程序本身的书写顺序。</li><li>如果在函数 A 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</li></ol><h3 id="_5-2-异步任务" tabindex="-1">5.2 异步任务 <a class="header-anchor" href="#_5-2-异步任务" aria-label="Permalink to &quot;5.2 异步任务&quot;">​</a></h3><ol><li>某段程序执行不会阻塞其他程序的执行，不必等待上一个任务执行完毕，拿到结果，就能执行下一个任务</li><li>其表现形式为程序的执行顺序不依赖本身的书写顺序。</li><li>如果在函数 A 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段(回调函数、通知)得到，那么这个函数就是异步的</li></ol><blockquote><p>单线程的解决方案：因为 JS 引擎是单线程的，所以在处理任务时必然不可能采用同步任务的编程模型。而是采用单线程 + 异步任务的编程模型</p></blockquote><h2 id="六、事件循环机制-event-loop" tabindex="-1">六、事件循环机制(Event Loop) <a class="header-anchor" href="#六、事件循环机制-event-loop" aria-label="Permalink to &quot;六、事件循环机制(Event Loop)&quot;">​</a></h2><h3 id="_6-1-宏任务与微任务" tabindex="-1">6.1 宏任务与微任务 <a class="header-anchor" href="#_6-1-宏任务与微任务" aria-label="Permalink to &quot;6.1 宏任务与微任务&quot;">​</a></h3><h3 id="_1-宏任务" tabindex="-1">(1) 宏任务 <a class="header-anchor" href="#_1-宏任务" aria-label="Permalink to &quot;(1) 宏任务&quot;">​</a></h3><ol><li>script(执行全局的 JS 代码)</li><li>setTimeout、setInterval</li><li>I/O(文件、网络)</li><li>UI 交互事件</li><li>setImmediate(Node.js 环境)</li></ol><h3 id="_2-微任务" tabindex="-1">(2) 微任务 <a class="header-anchor" href="#_2-微任务" aria-label="Permalink to &quot;(2) 微任务&quot;">​</a></h3><ol><li>Promise.then、Promise.catch</li><li>DOM 变化</li><li>process.nextTick(Node.js 环境)</li></ol><h3 id="_6-2-事件循环机制" tabindex="-1">6.2 事件循环机制 <a class="header-anchor" href="#_6-2-事件循环机制" aria-label="Permalink to &quot;6.2 事件循环机制&quot;">​</a></h3><p><img src="`+p+`" alt="事件循环图示"></p><p>图例描述：一次事件循环中最多处理一个宏任务，然后会处理微任务队列中的所有任务， 然后检查 UI 是否需要重新渲染，然后开始下一轮循环</p><ul><li>任务队列：至少具有两个队列，一个宏任务队列，一个微任务队列</li><li>事件循环：是指 JS 引擎线程重复从任务队列中取任务、执行任务的过程。</li></ul><blockquote><p>事件循环的实现至少应该含有一个用于宏任务的队列和一个用于微任务的队列。大部分的实现通常根据任务类型拥有更多的队列，这使得事件循环能够根据任务类型进行优化处理。例如，优先处理键盘和鼠标事件，保证该任务的优先处理</p></blockquote><h4 id="_1-代码示例" tabindex="-1">(1) 代码示例 <a class="header-anchor" href="#_1-代码示例" aria-label="Permalink to &quot;(1) 代码示例&quot;">​</a></h4><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;同步代码1&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;微任务1&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;宏任务1&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#005CC5;">  Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;微任务2&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#005CC5;">  Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;微任务3&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#005CC5;">  Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;微任务4&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;宏任务2&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">500</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;宏任务3&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;同步代码2&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 执行结果</span></span>
<span class="line"><span style="color:#005CC5;">1.</span><span style="color:#24292E;"> 同步代码1</span></span>
<span class="line"><span style="color:#005CC5;">2.</span><span style="color:#24292E;"> 同步代码2</span></span>
<span class="line"><span style="color:#005CC5;">3.</span><span style="color:#24292E;"> 微任务1</span></span>
<span class="line"><span style="color:#005CC5;">4.</span><span style="color:#24292E;"> 宏任务2</span></span>
<span class="line"><span style="color:#005CC5;">5.</span><span style="color:#24292E;"> 宏任务1</span></span>
<span class="line"><span style="color:#005CC5;">6.</span><span style="color:#24292E;"> 微任务2</span></span>
<span class="line"><span style="color:#005CC5;">7.</span><span style="color:#24292E;"> 微任务3</span></span>
<span class="line"><span style="color:#005CC5;">8.</span><span style="color:#24292E;"> 微任务4</span></span>
<span class="line"><span style="color:#005CC5;">9.</span><span style="color:#24292E;"> 宏任务3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p><img src="`+r+'" alt="事件循环过程"></p><h4 id="_2-微任务队列的意义" tabindex="-1">(2）微任务队列的意义 <a class="header-anchor" href="#_2-微任务队列的意义" aria-label="Permalink to &quot;(2）微任务队列的意义&quot;">​</a></h4><ol><li>微任务是<code>更小</code>的任务, 必须在浏览器继续执行其他宏任务之前执行(更轻量、优先级更高)</li><li>能够让浏览器及时处理宏任务中的 DOM 变化，并且可以保证 DOM 变化在浏览器渲染之前完成，如果任务队列只有一个的话，无法将微任务的执行顺序放到下一个宏任务前。</li></ol><h4 id="_3-玩转计时器" tabindex="-1">(3) 玩转计时器 <a class="header-anchor" href="#_3-玩转计时器" aria-label="Permalink to &quot;(3) 玩转计时器&quot;">​</a></h4><ol><li>无法确保计时器延迟的时间：只能控制计时器任务何时被添加到队列，但是无法控制计时器任务何时执行。</li><li>计时器提供了一种<code>异步延迟执行代码片段</code>的能力，我们可以利用计时器的这个特性，使用<code>setTimeout(() =&gt; {}, 0)</code>将长时间运行的任务分解成较小的任务。例如，一次性渲染 2000 条数据，可以分解成 10 个任务，每次只渲染 200 条数据。这样在每个小任务执行完成后，都有机会进行页面渲染，而不必非得等到所有的数据都渲染完成后页面才能进行更新。</li></ol><blockquote><p>浏览器尝试每秒 60 次渲染页面(60 帧，平均每 16ms 渲染一帧), 这意味着在理想状态下，单个任务和该任务附属的所有微任务，都应该在 16ms 内完成。可以恰当利用计时器的特性，来对项目内的长时间任务进行拆分</p></blockquote><h3 id="_6-3-单线程-异步编程模型的优缺点" tabindex="-1">6.3 单线程 + 异步编程模型的优缺点 <a class="header-anchor" href="#_6-3-单线程-异步编程模型的优缺点" aria-label="Permalink to &quot;6.3 单线程 + 异步编程模型的优缺点&quot;">​</a></h3><h4 id="_1-优点" tabindex="-1">(1) 优点 <a class="header-anchor" href="#_1-优点" aria-label="Permalink to &quot;(1) 优点&quot;">​</a></h4><ol><li>适合 I/O 密集型应用，因为允许程序在等到 I/O 完成时继续执行其他任务(非阻塞 I/O)</li><li>简化编程模型，单线程避免了多线程编程中的复杂性。例如，死锁、竞态条件、线程同步等问题</li><li>没有上线程下文切换的开销，在某些场景下可以提供更好的性能</li></ol><h3 id="_2-缺点" tabindex="-1">(2) 缺点 <a class="header-anchor" href="#_2-缺点" aria-label="Permalink to &quot;(2) 缺点&quot;">​</a></h3><ol><li>不适合 CPU 密集型应用，需要长时间计算的任务会阻塞后续任务的执行</li><li>无法充分利用多核 CPU 的优势</li><li>异步代码的逻辑理解和调试更复杂，因为代码的执行顺序并不和代码的书写顺序相同</li></ol>',75)]))}const m=a(t,[["render",c]]);export{E as __pageData,m as default};
