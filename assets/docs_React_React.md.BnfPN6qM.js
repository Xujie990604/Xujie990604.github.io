import{_ as a,c as n,o as l,ag as e}from"./chunks/framework.BDwTZuFy.js";const b=JSON.parse('{"title":"React","description":"","frontmatter":{},"headers":[],"relativePath":"docs/React/React.md","filePath":"docs/React/React.md","lastUpdated":1735478813000}'),p={name:"docs/React/React.md"};function o(t,s,r,c,i,y){return l(),n("div",null,s[0]||(s[0]=[e(`<h1 id="react" tabindex="-1">React <a class="header-anchor" href="#react" aria-label="Permalink to &quot;React&quot;">​</a></h1><ul><li>React 是跨平台的 UI 框架，React 应用程序同样可以渲染到移动设备或者桌面平台，这些平台可能使用不同的 UI 原语</li></ul><h2 id="一、react-组件" tabindex="-1">一、React 组件 <a class="header-anchor" href="#一、react-组件" aria-label="Permalink to &quot;一、React 组件&quot;">​</a></h2><ul><li>React 是由被称为<code>组件</code> 的独立 UI 片段构建而成</li><li>React 组件本质上是可以任意添加标签的 JavaScript 函数。组件名必须以大写字母开头</li><li>React 相比于 Vue 的优势之一是一个文件内能声明多个组件，拆分组件的代价更小</li><li>组件可以渲染其他组件，但是不要嵌套他们的定义。仅在顶层声明组件</li></ul><h2 id="二、jsx-语法" tabindex="-1">二、JSX 语法 <a class="header-anchor" href="#二、jsx-语法" aria-label="Permalink to &quot;二、JSX 语法&quot;">​</a></h2><ul><li>React 组件使用一种叫做 JSX 的语法扩展来表示组件的 UI，JSX 和 HTML 很像，但它更为严格，<code>标签必须闭合</code>，并且一个组件只能返回一个根元素(因为 JSX 会被转化为 JS 对象，一个函数不能返回多个对象)</li><li>因为 JSX 会被转化成 JS，因此 JSX 中的属性命名有限制，大部分属性使用驼峰式命名法(由于历史原因 <code>aria-*</code>, <code>data-*</code> 属性可以使用连字符)，不能包含 <code>-</code> 连字符，不能使用 class 关键字，而应该使用 className</li><li>在 JSX 中通过大括号使用 JavaScript 表达式</li><li>undefined, null, false/true 等不会在 JSX 中渲染任何内容</li><li>JSX 中不允许直接渲染一个对象</li><li>JSX 语句和 return 关键字在同一行时可以省略 <code>()</code>, 不在同一行时需要使用 <code>()</code> 来包括 JSX 的内容</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> Heading</span><span style="color:#24292E;">({ </span><span style="color:#E36209;">level</span><span style="color:#24292E;">, </span><span style="color:#E36209;">children</span><span style="color:#24292E;"> }) {</span></span>
<span class="line"><span style="color:#D73A49;">  const</span><span style="color:#005CC5;"> Heading</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> level;</span></span>
<span class="line"><span style="color:#6A737D;">  // TODO：直接将 level 当做标签名不行，必须要用变量接收一下。为什么？</span></span>
<span class="line"><span style="color:#6A737D;">  // TODO：不是说不能直接将变量作为标签名吗？为啥能成功</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> &lt;</span><span style="color:#005CC5;">Heading</span><span style="color:#24292E;">&gt;{children}&lt;/</span><span style="color:#005CC5;">Heading</span><span style="color:#24292E;">&gt;;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#D73A49;"> default</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> Home</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  const</span><span style="color:#005CC5;"> level</span><span style="color:#D73A49;"> =</span><span style="color:#032F62;"> &quot;h2&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">section</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      {</span><span style="color:#032F62;">/_ TODO： 必须用组件的形式， 直接将 level 当标签名不行 _/</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#005CC5;">Heading</span><span style="color:#6F42C1;"> level</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{level}&gt;我是{level}&lt;/</span><span style="color:#005CC5;">Heading</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/</span><span style="color:#22863A;">section</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_2-1-组件传值" tabindex="-1">2.1 组件传值 <a class="header-anchor" href="#_2-1-组件传值" aria-label="Permalink to &quot;2.1 组件传值&quot;">​</a></h3><ul><li>React 组件使用 props 来进行组件之间的通讯</li><li>父组件传递给子组件的属性，都在一个名为 props 的对象中，为了简化代码，我们可以在子组件函数中直接使用解构赋值的方式拿取具体属性</li><li>即使传递的是 className 这种 DOM 元素上固有的 prop, 也不会自动进行应用。需要手动去指定</li><li>props 是不可变的，当你需要交互性时，你可以设置 state</li><li>Props 是只读的时间快照：每次渲染都会收到新版本的 props</li></ul><h3 id="_2-2-条件渲染" tabindex="-1">2.2 条件渲染 <a class="header-anchor" href="#_2-2-条件渲染" aria-label="Permalink to &quot;2.2 条件渲染&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 使用 if 分支来区分大块的 DOM</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> Item</span><span style="color:#24292E;">({ </span><span style="color:#E36209;">name</span><span style="color:#24292E;">, </span><span style="color:#E36209;">isPacked</span><span style="color:#24292E;"> }) {</span></span>
<span class="line"><span style="color:#D73A49;">  if</span><span style="color:#24292E;"> (isPacked) {</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#24292E;"> &lt;</span><span style="color:#22863A;">li</span><span style="color:#6F42C1;"> className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;item&quot;</span><span style="color:#24292E;">&gt;{name} ✔&lt;/</span><span style="color:#22863A;">li</span><span style="color:#24292E;">&gt;;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#24292E;"> &lt;</span><span style="color:#22863A;">li</span><span style="color:#6F42C1;"> className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;item&quot;</span><span style="color:#24292E;">&gt;{name}&lt;/</span><span style="color:#22863A;">li</span><span style="color:#24292E;">&gt;;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用三目运算符来控制更小快的 DOM</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> Item</span><span style="color:#24292E;">({ </span><span style="color:#E36209;">name</span><span style="color:#24292E;">, </span><span style="color:#E36209;">isPacked</span><span style="color:#24292E;"> }) {</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> &lt;</span><span style="color:#22863A;">li</span><span style="color:#6F42C1;"> className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;item&quot;</span><span style="color:#24292E;">&gt;{isPacked </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> name </span><span style="color:#D73A49;">+</span><span style="color:#032F62;"> &quot;✔&quot;</span><span style="color:#D73A49;"> :</span><span style="color:#24292E;"> name}&lt;/</span><span style="color:#22863A;">li</span><span style="color:#24292E;">&gt;;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用 &amp;&amp; 操作符，表示只有在条件成立时才渲染一些内容</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> Item</span><span style="color:#24292E;">({ </span><span style="color:#E36209;">name</span><span style="color:#24292E;">, </span><span style="color:#E36209;">isPacked</span><span style="color:#24292E;"> }) {</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">li</span><span style="color:#6F42C1;"> className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;item&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      {name}</span></span>
<span class="line"><span style="color:#24292E;">      {isPacked </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#032F62;"> &quot;✔&quot;</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/</span><span style="color:#22863A;">li</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 不在 JSX 中进行条件判断，而是根据条件来操作变量，在 JSX 中直接使用变量</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> Item</span><span style="color:#24292E;">({ </span><span style="color:#E36209;">name</span><span style="color:#24292E;">, </span><span style="color:#E36209;">isPacked</span><span style="color:#24292E;"> }) {</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> itemContent </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name;</span></span>
<span class="line"><span style="color:#D73A49;">  if</span><span style="color:#24292E;"> (isPacked) {</span></span>
<span class="line"><span style="color:#24292E;">    itemContent </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name </span><span style="color:#D73A49;">+</span><span style="color:#032F62;"> &quot;✔&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> &lt;</span><span style="color:#22863A;">li</span><span style="color:#6F42C1;"> className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;item&quot;</span><span style="color:#24292E;">&gt;{itemContent}&lt;/</span><span style="color:#22863A;">li</span><span style="color:#24292E;">&gt;;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h2 id="三、纯函数组件" tabindex="-1">三、纯函数组件 <a class="header-anchor" href="#三、纯函数组件" aria-label="Permalink to &quot;三、纯函数组件&quot;">​</a></h2><ul><li>保持组件的纯粹性，使用纯函数来定义 React 组件来避免一些令人困惑的错误和不可预料的行为</li><li>只负责自己的任务：不会更改在该函数调用前就已经存在的对象或者变量，不会更改函数作用域外的变量</li><li>输入相同，输入相同：给定相同的输入，纯函数总是返回相同的输出</li><li>一般来说，你不应该期待你的组件以任何特定的顺序被渲染。每个组件应该独立</li><li>使用严格模式检测不纯的计算：严格模式下开发，它将会调用每个组件函数两次，严格模式有助于找到这些违反规则的组件</li><li>但某些事物在特定情况下不得不发生变化，被称为副作用，与渲染过程无关。在 React 中副作用通常属于事件处理程序，因此事件处理程序无需是纯函数</li><li>如果你用尽一切办法，仍无法为副作用找到合适的事件处理程序，你还可以调用组件中的 useEffect 方法将其附加到返回的 JSX 中。这会告诉 React 在渲染结束后执行它。然而，这种方法应该是你最后的手段。</li></ul><h3 id="纯函数的好处" tabindex="-1">纯函数的好处 <a class="header-anchor" href="#纯函数的好处" aria-label="Permalink to &quot;纯函数的好处&quot;">​</a></h3><ol><li>你的组件可以在不同的环境下运行 — 例如，在服务器上！由于它们针对相同的输入，总是返回相同的结果，因此一个组件可以满足多个用户请求。</li><li>你可以为那些输入未更改的组件来 跳过渲染，以提高性能。这是安全的做法，因为纯函数总是返回相同的结果，所以可以安全地缓存它们。</li><li>如果在渲染深层组件树的过程中，某些数据发生了变化，React 可以重新开始渲染，而不会浪费时间完成过时的渲染。纯粹性使得它随时可以安全地停止计算。</li></ol><h2 id="四、react-事件" tabindex="-1">四、React 事件 <a class="header-anchor" href="#四、react-事件" aria-label="Permalink to &quot;四、React 事件&quot;">​</a></h2><ul><li>React 中的事件都会传播，需要手动取消冒泡操作</li><li>事件函数是执行副作用的最佳位置，事件处理函数不需要是纯函数</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 事件处理函数的形式</span></span>
<span class="line"><span style="color:#6A737D;">// NOTE: 传递的是事件函数本身，而不是函数的执行结果</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#D73A49;"> default</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> PackingList</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  function</span><span style="color:#6F42C1;"> handleClick</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6F42C1;">    alert</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;被点击&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">button</span><span style="color:#6F42C1;"> onClick</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{handleClick}&gt;BUTTON&lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 内联函数的形式，更加简洁</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#D73A49;"> default</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> PackingList</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">button</span><span style="color:#6F42C1;"> onClick</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#6F42C1;"> alert</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;被点击&quot;</span><span style="color:#24292E;">)}&gt;BUTTON&lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="五、state" tabindex="-1">五、state <a class="header-anchor" href="#五、state" aria-label="Permalink to &quot;五、state&quot;">​</a></h2><h3 id="_5-1-usestate-hook" tabindex="-1">5.1 useState Hook <a class="header-anchor" href="#_5-1-usestate-hook" aria-label="Permalink to &quot;5.1 useState Hook&quot;">​</a></h3><ul><li>useState Hook 提供了两个功能</li></ul><ol><li>State 变量：用于<code>保存渲染间</code>的数据</li><li>State setter 函数：<code>更新变量</code>并<code>触发 React 再次渲染</code>组件</li></ol><p>当调用 useState 时，你是在告诉 React 你想让这个组件记住一些东西(是记住同一组件每次<code>渲染</code>时的状态，多次调用组件函数时，多个组件之间的数据是分离的)</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// Hook: 以 use 开头的函数，只能在组件或者自定义 Hook 的最顶层调用</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { useState } </span><span style="color:#D73A49;">from</span><span style="color:#032F62;"> &quot;react&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#D73A49;"> default</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> PackingList</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  const</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">message</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">setMessage</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> useState</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;点击我&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">  function</span><span style="color:#6F42C1;"> handleClick</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6F42C1;">    setMessage</span><span style="color:#24292E;">(message </span><span style="color:#D73A49;">+</span><span style="color:#032F62;"> &quot;!&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> &lt;</span><span style="color:#22863A;">button</span><span style="color:#6F42C1;"> onClick</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{handleClick}&gt;{message}&lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_5-2-state-如同一张快照" tabindex="-1">5.2 state 如同一张快照 <a class="header-anchor" href="#_5-2-state-如同一张快照" aria-label="Permalink to &quot;5.2 state 如同一张快照&quot;">​</a></h3><ul><li>在 React 内部，为每个组件保存了一个数组，其中每一项都是一个 state 对</li><li>State 是屏幕上组件实例内部的状态：如果你渲染同一个组件两次，每个副本都会有完全隔离的 state</li><li>与 props 不同，state 完全<code>私有于声明它的组件</code>。父组件无法感知和更改子组件的 state</li><li><code>正在渲染</code> 就意味着 React 正在调用你的组件(一个函数)，从该函数返回的 JSX 就像是在某个时间点上 UI 的快照，它的 props、事件处理函数和内部变量都是根据<code>当前渲染时的 state</code> 被计算出来的</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// state 如同一张快照: 一个 state 变量的值永远不会在一次渲染的内部发生变化</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#D73A49;"> default</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> Counter</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  const</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">number</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">setNumber</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> useState</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    &lt;&gt;</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#22863A;">h1</span><span style="color:#24292E;">&gt;{number}&lt;/</span><span style="color:#22863A;">h1</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      {</span><span style="color:#6A737D;">/* 设置 state 只会为 \`下一次渲染\` 变更 state 的值 */</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">      {</span><span style="color:#6A737D;">/* 这个 click 事件，看起来像是对 state 进行了 +3 的操作， 但是实际上三次调用都是将 0 变成 1 */</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#22863A;">button</span></span>
<span class="line"><span style="color:#6F42C1;">        onClick</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">          // state 的值是不可变的， 将 0 加 1 后的结果，是用来给下一次的渲染变更用</span></span>
<span class="line"><span style="color:#6F42C1;">          setNumber</span><span style="color:#24292E;">(number </span><span style="color:#D73A49;">+</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6F42C1;">          setNumber</span><span style="color:#24292E;">(number </span><span style="color:#D73A49;">+</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6F42C1;">          setNumber</span><span style="color:#24292E;">(number </span><span style="color:#D73A49;">+</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        }}</span></span>
<span class="line"><span style="color:#24292E;">      &gt;</span></span>
<span class="line"><span style="color:#24292E;">        +3</span></span>
<span class="line"><span style="color:#24292E;">      &lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/&gt;</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="_5-3-把一系列-state-更新重新加入队列" tabindex="-1">5.3 把一系列 state 更新重新加入队列 <a class="header-anchor" href="#_5-3-把一系列-state-更新重新加入队列" aria-label="Permalink to &quot;5.3 把一系列 state 更新重新加入队列&quot;">​</a></h3><ul><li>React 会等到事件处理函数中的所有代码都运行完毕再处理你的 state 更新</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#D73A49;"> default</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> Counter</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  const</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">number</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">setNumber</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> useState</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    &lt;&gt;</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#22863A;">h1</span><span style="color:#24292E;">&gt;{number}&lt;/</span><span style="color:#22863A;">h1</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#22863A;">button</span></span>
<span class="line"><span style="color:#6F42C1;">        onClick</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">          {</span></span>
<span class="line"><span style="color:#6A737D;">            /* 使用更新函数的形式，用来在下一次渲染之前多次更新同一个 state */</span></span>
<span class="line"><span style="color:#24292E;">          }</span></span>
<span class="line"><span style="color:#6F42C1;">          setNumber</span><span style="color:#24292E;">((</span><span style="color:#E36209;">n</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">+</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6F42C1;">          setNumber</span><span style="color:#24292E;">((</span><span style="color:#E36209;">n</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">+</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6F42C1;">          setNumber</span><span style="color:#24292E;">((</span><span style="color:#E36209;">n</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">+</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        }}</span></span>
<span class="line"><span style="color:#24292E;">      &gt;</span></span>
<span class="line"><span style="color:#24292E;">        +3</span></span>
<span class="line"><span style="color:#24292E;">      &lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/&gt;</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><ul><li><code>setState(n = n + 1)</code> 被称为更新函数，这是在告诉 React 用 state 值来做某事。<code>setState(n + 1)</code> 是在告诉用某值来替换原来的值</li></ul><h3 id="_5-4-更新-state-中的对象" tabindex="-1">5.4 更新 state 中的对象 <a class="header-anchor" href="#_5-4-更新-state-中的对象" aria-label="Permalink to &quot;5.4 更新 state 中的对象&quot;">​</a></h3><ul><li>从技术上来说，可以改变对象自身的内容。但是在 React 中，需要将所有 state 都视为只读的，你需要替换 state 中对象的值，而不是改变它</li><li>对于多层嵌套的 state 对象，可以考虑进行扁平化操作，或者使用 immer 库来简化操作</li><li>React 并不依赖 mutation(Vue2 通过 Proxy 的方式，通过 mutation 来实现响应式 )</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 更新对象的常见方式，使用...扩展运算符</span></span>
<span class="line"><span style="color:#6F42C1;">setPerson</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#D73A49;">  ...</span><span style="color:#24292E;">person, </span><span style="color:#6A737D;">// 复制上一个 person 中的所有字段</span></span>
<span class="line"><span style="color:#24292E;">  firstName: e.target.value, </span><span style="color:#6A737D;">// 但是覆盖 firstName 字段</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_5-5-更新-state-中的数组" tabindex="-1">5.5 更新 state 中的数组 <a class="header-anchor" href="#_5-5-更新-state-中的数组" aria-label="Permalink to &quot;5.5 更新 state 中的数组&quot;">​</a></h3><ul><li>数组同样要视为不可变的， push、pop、splice 等数组方法不能在 React 中使用</li><li>同样可以使用 immer 库来简化数组的操作</li></ul><h2 id="六、渲染过程" tabindex="-1">六、渲染过程 <a class="header-anchor" href="#六、渲染过程" aria-label="Permalink to &quot;六、渲染过程&quot;">​</a></h2><h3 id="_6-1-触发渲染" tabindex="-1">6.1 触发渲染 <a class="header-anchor" href="#_6-1-触发渲染" aria-label="Permalink to &quot;6.1 触发渲染&quot;">​</a></h3><ol><li>组件的<code>初次渲染</code></li><li>组件(或者祖先之一)的 <code>状态发生了改变</code></li></ol><h3 id="_6-2-react-渲染你的组件" tabindex="-1">6.2 React 渲染你的组件 <a class="header-anchor" href="#_6-2-react-渲染你的组件" aria-label="Permalink to &quot;6.2 React 渲染你的组件&quot;">​</a></h3><ol><li>在初次渲染时： React 会调用根组件</li><li>对于后续的渲染， React 会调用内部状态更新触发了渲染的函数组件(递归的去渲染子组件)</li></ol><h3 id="_6-3-react-把更改提交到-dom-上" tabindex="-1">6.3 React 把更改提交到 DOM 上 <a class="header-anchor" href="#_6-3-react-把更改提交到-dom-上" aria-label="Permalink to &quot;6.3 React 把更改提交到 DOM 上&quot;">​</a></h3><ol><li>对于初次渲染， React 会使用 appendChild DOM API 将其创建的所有 DOM 节点放在屏幕上</li><li>对于重渲染，React 将应用最少的必要操作(在渲染时计算) NOTE：应该也是 diff 算法， Vue 和 React 的 diff 算法有何不同</li></ol><h2 id="七、状态管理" tabindex="-1">七、状态管理 <a class="header-anchor" href="#七、状态管理" aria-label="Permalink to &quot;七、状态管理&quot;">​</a></h2><ul><li>React 控制 UI 的方式是声明式的</li><li>在你不明确业务实现时，可以使用尽可能多的 state 来控制页面的 UI，然后在慢慢的进行优化。有哪些 state 是可以合并的(合并为同一个、或者由两个布尔合并为一个有三种情况的 string)，有哪些是互斥的</li><li>一个组件的 state 只有在组件初次渲染时，才会进行初始化。一般情况下不要将 props 使用 state 进行包装，除非你只想把父组件传过来的 props 当做初始化的值。</li></ul><h3 id="_7-1-组件间共享状态" tabindex="-1">7.1 组件间共享状态 <a class="header-anchor" href="#_7-1-组件间共享状态" aria-label="Permalink to &quot;7.1 组件间共享状态&quot;">​</a></h3><ul><li>希望两个组件的状态始终同步，可以把 state 放到共同的父级，被称为<code>状态提升</code></li><li>受控组件：组件的状态受父组件的影响</li><li>非受控组件：组件的状态不受父组件的影响</li></ul><h3 id="_7-2-state-的保留和重置" tabindex="-1">7.2 state 的保留和重置 <a class="header-anchor" href="#_7-2-state-的保留和重置" aria-label="Permalink to &quot;7.2 state 的保留和重置&quot;">​</a></h3><ul><li>state 并不存在于组件内，实际上 state 是由 react 保存的</li><li>只要一个组件还被渲染在 UI 树的相同位置(对 React 来说重要的是组件在 <code>UI 树中的位置</code>,而不是在 <code>JSX 中的位置</code>)，React 就会保留它的 state。 如果它被移除，或者一个不同的组件被渲染在相同的位置，那么 React 就会丢掉它的 state。</li><li>NOTE：和 Vue 的区别，Vue 的状态是保存在组件内部的，即使是在相同位置再次渲染相同的组件，上一个组件的状态也不会被保留。但是 React 的状态是保存的 React 中的，在相同的位置再次渲染相同的组件，上一个组件遗留的状态会被保存下来</li><li>在相同位置渲染组件，但是想重置 state: 1. 将组件渲染在不同的位置 2.使用 key 来重置 state</li></ul><h3 id="_7-3-reducer" tabindex="-1">7.3 Reducer <a class="header-anchor" href="#_7-3-reducer" aria-label="Permalink to &quot;7.3 Reducer&quot;">​</a></h3><ul><li>使用 Reducer 来集中处理数据，分离关注点，使得代码结构更加的清晰</li></ul><h3 id="_7-4-context-深层传递数据" tabindex="-1">7.4 Context 深层传递数据 <a class="header-anchor" href="#_7-4-context-深层传递数据" aria-label="Permalink to &quot;7.4 Context 深层传递数据&quot;">​</a></h3><ul><li>组件通过 useContext(xxx) 来访问上层<code>最近</code>父组件提供的 xxx 的值</li><li>TODO： 和 Vue Inject Provide 的区别</li><li>context 让你可以编写“适应周围环境”的组件</li><li>context 看起来非常诱人，但是这并不代表着 context 是万能的。使用 props 的方式能让开发者更容易了解哪些组件中使用了哪些数据。在使用 context 之前，先试试传递 props 或者将 JSX 作为 children 传递</li></ul><h3 id="_7-5-结合-reducer-和-context" tabindex="-1">7.5 结合 Reducer 和 context <a class="header-anchor" href="#_7-5-结合-reducer-和-context" aria-label="Permalink to &quot;7.5 结合 Reducer 和 context&quot;">​</a></h3><ul><li>把 state 和 dispatch 都放到 context 中，然后在组件树的任何地方使用 context</li><li>可以在当前步骤的基础上进一步进行抽离，将 state, dispatch，JSX 全部放到一个文件中，并自定义一个 hook 进行使用</li></ul><h2 id="八、脱围机制" tabindex="-1">八、脱围机制 <a class="header-anchor" href="#八、脱围机制" aria-label="Permalink to &quot;八、脱围机制&quot;">​</a></h2><h3 id="_8-1-ref" tabindex="-1">8.1 ref <a class="header-anchor" href="#_8-1-ref" aria-label="Permalink to &quot;8.1 ref&quot;">​</a></h3><ul><li>当你希望组件记住某些信息，但是又不想让这些信息触发新的渲染</li><li>可以使用 ref 来操作 DOM</li></ul><h3 id="_8-2-effect" tabindex="-1">8.2 Effect <a class="header-anchor" href="#_8-2-effect" aria-label="Permalink to &quot;8.2 Effect&quot;">​</a></h3><ul><li>等真的需要使用 React 做项目时再学习</li></ul><h3 id="_8-3-自定义-hook" tabindex="-1">8.3 自定义 Hook <a class="header-anchor" href="#_8-3-自定义-hook" aria-label="Permalink to &quot;8.3 自定义 Hook&quot;">​</a></h3><ol><li>代码逻辑复用</li><li>组件内部的代码描述的是想要做什么，而不是怎么做(隐藏背后的逻辑)</li></ol>`,62)]))}const d=a(p,[["render",o]]);export{b as __pageData,d as default};
