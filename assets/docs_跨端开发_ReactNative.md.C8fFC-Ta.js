import{_ as e,c as i,o as t,ag as l}from"./chunks/framework.BDwTZuFy.js";const _=JSON.parse('{"title":"ReactNative","description":"","frontmatter":{},"headers":[],"relativePath":"docs/跨端开发/ReactNative.md","filePath":"docs/跨端开发/ReactNative.md","lastUpdated":1757311724000}'),r={name:"docs/跨端开发/ReactNative.md"};function o(d,a,c,n,h,s){return t(),i("div",null,a[0]||(a[0]=[l('<h1 id="reactnative" tabindex="-1">ReactNative <a class="header-anchor" href="#reactnative" aria-label="Permalink to &quot;ReactNative&quot;">​</a></h1><ul><li>React Native 的设计哲学并非强迫你所有东西都用 JS 写，而是提供一个高效率的基准线，并赋予你随时能“穿透”这层天花板、触及原生性能的能力。</li></ul><h2 id="一、页面渲染" tabindex="-1">一、页面渲染 <a class="header-anchor" href="#一、页面渲染" aria-label="Permalink to &quot;一、页面渲染&quot;">​</a></h2><ul><li>RN 会将 JavaScript 代码中描述的界面组件转化为原生的 UI 组件，比如在 iOS 上转换为 <code>UIKit</code> 组件，在 Android 上转换为 <code>View</code> 体系的组件，利用原生组件的性能和特性来显示界面</li><li>在这一过程中，逻辑代码仍然在 JavaScript 环境中运行，通过 <code>桥接机制</code> 与原生组件进行通信和交互</li><li>依赖于 React 的虚拟 DOM 机制，每次页面发生变化时，都会通过 <code>Bridge</code> 来传递 diff, 然后原生平台根据 diff 来更新、创建、删除 UI 组件</li></ul><h2 id="二、逻辑执行" tabindex="-1">二、逻辑执行 <a class="header-anchor" href="#二、逻辑执行" aria-label="Permalink to &quot;二、逻辑执行&quot;">​</a></h2><ul><li>RN 使用 JS 来编写逻辑和界面代码，运行时代码在 JavaScriptCore(IOS) 或 Hermes(Android) 中执行。</li><li>Hermes 是专门用来在 Android 上运行 JavaScript 代码的引擎，因为它专门针对移动端进行大量优化，所以性能比 V8 更好</li></ul><h2 id="三、优势点" tabindex="-1">三、优势点 <a class="header-anchor" href="#三、优势点" aria-label="Permalink to &quot;三、优势点&quot;">​</a></h2><ol><li>JS 的庞大生态</li><li>对于已经掌握 JS、React 的前端开发人员来说，学习成本低、门槛低。有丰富的人员储备</li><li>混合开发：RN 允许原生应用嵌入 RN 组件，RN 应用也可以嵌入原生组件</li><li>代码热重载，无需编译即可看到效果</li><li>应用热更新、解决问题、发布活动无需发布新版本</li><li>虽然并不完善，但是有适配鸿蒙的方案</li></ol><h2 id="四、缺点" tabindex="-1">四、缺点 <a class="header-anchor" href="#四、缺点" aria-label="Permalink to &quot;四、缺点&quot;">​</a></h2><ol><li>仍然使用 JS 来编写逻辑代码，导致性能还是 JS 脚本语言的水平</li><li>JSX 转化为 原生 UI 组件，并且通过 <code>Bridge</code> 来传递 diff，相比于原生 UI 来说有一定的性能损耗</li></ol><h2 id="五、新旧架构" tabindex="-1">五、新旧架构 <a class="header-anchor" href="#五、新旧架构" aria-label="Permalink to &quot;五、新旧架构&quot;">​</a></h2><h3 id="_5-1-旧架构" tabindex="-1">5.1 旧架构 <a class="header-anchor" href="#_5-1-旧架构" aria-label="Permalink to &quot;5.1 旧架构&quot;">​</a></h3><ul><li>它是一个异步、可序列化的消息传递系统</li></ul><h3 id="_5-2-新架构" tabindex="-1">5.2 新架构 <a class="header-anchor" href="#_5-2-新架构" aria-label="Permalink to &quot;5.2 新架构&quot;">​</a></h3><ul><li>JSI 不是一个消息传递系统，而是一个用 C++ 编写的轻量级通用层。它允许 JavaScript 和 Native 代码直接、同步地相互调用方法。</li></ul><h2 id="六、jsx-native-ui-组件" tabindex="-1">六、JSX -&gt; native UI 组件 <a class="header-anchor" href="#六、jsx-native-ui-组件" aria-label="Permalink to &quot;六、JSX -&gt; native UI 组件&quot;">​</a></h2><ul><li>单纯的 JSX 语法本身，是不足以完全表现出 Native 平台组件所有能力的。</li></ul>',17)]))}const f=e(r,[["render",o]]);export{_ as __pageData,f as default};
