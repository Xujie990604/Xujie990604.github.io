import{_ as n,c as a,o as l,ag as e}from"./chunks/framework.BDwTZuFy.js";const b=JSON.parse('{"title":"Vue 的一些原理类知识","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Vue/Vue相关知识.md/Vue的原理.md","filePath":"docs/Vue/Vue相关知识.md/Vue的原理.md","lastUpdated":1712646874000}'),p={name:"docs/Vue/Vue相关知识.md/Vue的原理.md"};function o(r,s,t,c,i,u){return l(),a("div",null,s[0]||(s[0]=[e(`<h1 id="vue-的一些原理类知识" tabindex="-1">Vue 的一些原理类知识 <a class="header-anchor" href="#vue-的一些原理类知识" aria-label="Permalink to &quot;Vue 的一些原理类知识&quot;">​</a></h1><h2 id="vue-use-plugin" tabindex="-1">Vue.use(plugin) <a class="header-anchor" href="#vue-use-plugin" aria-label="Permalink to &quot;Vue.use(plugin)&quot;">​</a></h2><ul><li>该方法需要在调用 new Vue({})之前被调用</li><li>如果插件是一个对象，这个对象必须有 install 函数</li><li>如果插件是一个函数，它就会被当做 install 方法调用</li><li>Vue.use()之后，Vue 会自动执行插件的 install 方法，来做一些操作</li></ul><h3 id="插件需不需要-vue-use" tabindex="-1">插件需不需要 Vue.use() <a class="header-anchor" href="#插件需不需要-vue-use" aria-label="Permalink to &quot;插件需不需要 Vue.use()&quot;">​</a></h3><ul><li>Vue-router，Vuex，Element-ui 等插件都具有 install 方法，并且插件的运行也都依赖于 install 方法中的操作，所以这些插件需要使用 Vue.use()</li><li>axios 不需要 install 方法也能正常使用，所以 axios 插件不需要使用 Vue.use()</li></ul><h3 id="vue-use-和-install-的具体实现" tabindex="-1">Vue.use()和 install()的具体实现 <a class="header-anchor" href="#vue-use-和-install-的具体实现" aria-label="Permalink to &quot;Vue.use()和 install()的具体实现&quot;">​</a></h3><h4 id="vue-use-内部的具体实现" tabindex="-1">Vue.use()内部的具体实现 <a class="header-anchor" href="#vue-use-内部的具体实现" aria-label="Permalink to &quot;Vue.use()内部的具体实现&quot;">​</a></h4><ol><li>检查插件是否安装，不会重复安装</li><li>没有安装就安装上，并且执行插件的 install 方法，并传入 Vue 实例</li></ol><h4 id="install-函数内部的实现" tabindex="-1">install()函数内部的实现 <a class="header-anchor" href="#install-函数内部的实现" aria-label="Permalink to &quot;install()函数内部的实现&quot;">​</a></h4><ol><li>自定义一些参数()</li></ol><div class="language-JS line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JS</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 自定义一些参数 (Element-ui插件的例子)</span></span>
<span class="line"><span style="color:#6A737D;">// opts是参数，如果我们coder传入这个参数就是用传入的，否则就使用默认的数值</span></span>
<span class="line"><span style="color:#005CC5;">  Vue</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">.$ELEMENT </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    size: opts.size </span><span style="color:#D73A49;">||</span><span style="color:#032F62;"> &#39;&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    zIndex: opts.zIndex </span><span style="color:#D73A49;">||</span><span style="color:#005CC5;"> 2000</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#6A737D;">    // 调用vue.use()时，传入参数。Vue.use()内部又会把参数传给install()方法。</span></span>
<span class="line"><span style="color:#24292E;">  Vue.</span><span style="color:#6F42C1;">use</span><span style="color:#24292E;">(Element, { size: </span><span style="color:#032F62;">&#39;small&#39;</span><span style="color:#24292E;">, zIndex: </span><span style="color:#005CC5;">3000</span><span style="color:#24292E;"> });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="2"><li>在原型上注册一些方法</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 在Vue的原型上直接赋予一个函数，到时候就能直接通过this.$alert()调用ELement-ui内部的函数</span></span>
<span class="line"><span style="color:#005CC5;">Vue</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">.$alert </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> MessageBox.alert;</span></span>
<span class="line"><span style="color:#6A737D;">// 在每个Vue组件上都添加了$router属性，并且是响应式的添加。</span></span>
<span class="line"><span style="color:#24292E;">Object.</span><span style="color:#6F42C1;">defineProperty</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">Vue</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;$router&quot;</span><span style="color:#24292E;">, {</span></span>
<span class="line"><span style="color:#6F42C1;">  get</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">._routerRoot._router;</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="3"><li>注册全局组件</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 注册 &lt;router-view&gt;组件</span></span>
<span class="line"><span style="color:#24292E;">Vue.</span><span style="color:#6F42C1;">component</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;RouterView&quot;</span><span style="color:#24292E;">, View);</span></span>
<span class="line"><span style="color:#6A737D;">// 注册&lt;router-link&gt;组件</span></span>
<span class="line"><span style="color:#24292E;">Vue.</span><span style="color:#6F42C1;">component</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;RouterLink&quot;</span><span style="color:#24292E;">, Link);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="vue-组件的-style-标签中的-scoped-属性" tabindex="-1">Vue 组件的 style 标签中的 scoped 属性 <a class="header-anchor" href="#vue-组件的-style-标签中的-scoped-属性" aria-label="Permalink to &quot;Vue 组件的 style 标签中的 scoped 属性&quot;">​</a></h2><ul><li>当一个 style 标签拥有 scoped 属性时，它的 CSS 样式就只能作用于当前的组件，也就是说，该样式只能适用于 当前组件内出现过 的元素。通过该属性，可以使得组件之间的样式不互相污染。如果一个项目中的所有 style 标签全部加上了 scoped，相当于实现了样式的模块化。</li></ul><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h3><ul><li>给一个组件中的所有 出现在页面上的 dom 添加了一个独一无二的动态属性(同一个组件内的 DOM 添加的动态属性是一样的)，然后，给 CSS 选择器额外添加一个对应的属性选择器来选择该组件中 dom，这种做法使得样式只作用于含有该属性的 dom(组件内部 dom)</li><li>一个 Vue 组件被父组件引用时，子组件最外层 DOM 结构上既有父组件的动态属性，又有子组件的动态属性，这样在父组件和子组件的 scoped style 中都能修改子组件最外层的样式</li></ul><h3 id="scoped-的弊端" tabindex="-1">scoped 的弊端 <a class="header-anchor" href="#scoped-的弊端" aria-label="Permalink to &quot;scoped 的弊端&quot;">​</a></h3><ul><li>在我们自己的 Vue 组件中(组件的 style 带有 scoped 属性)引入第三方的插件时，按照普通的 css 层级去修改第三方插件 内部的 DOM(并不是第三方的组件都不能修改，而是只能修改在当前组件中出现过的 DOM，例如 el-input 的样式可以修改，但是 el-input 内部的 DOM 样式就不能修改了) 不会生效。</li><li>例如在 vue.app 组件中(组件的 style 带有 scoped 属性)引入 element-ui 插件。在带有 scoped 属性的 style 标签中去修改 Element 组件的内部 DOM 的 css 属性不会生效。因为 Vue 只会在当前组件的第一层 DOM 结构上添加那个动态的属性，不会在引用组件的第二层 DOM 上添加动态属性，但是只要是写在带有 scoped 属性的 style 标签中的 css 选择器 都会被加上动态属性。因此会导致最终渲染出来的 css 选择器 和我们想要 控制的 DOM 匹配不上。</li></ul><h3 id="scoped-弊端的解决方案" tabindex="-1">scoped 弊端的解决方案 <a class="header-anchor" href="#scoped-弊端的解决方案" aria-label="Permalink to &quot;scoped 弊端的解决方案&quot;">​</a></h3><ul><li>使用 &gt;&gt;&gt; (普通 css) 击穿符号(或者 ::v-deep(预处理 CSS), /deep/)(在 Vue Cli3 版本以上不可以使用) 指令) 使用穿透符号之后，在穿透符号后面的 CSS 选择器上 不会被加上动态的属性</li></ul><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">/* 使用v-deep语法时前面需要有父选择器 */</span></span>
<span class="line"><span style="color:#6F42C1;">.father</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  ::v-deep.son {</span></span>
<span class="line"><span style="color:#24292E;">    ...;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">/* 使用::v-deep{ } 语法时可以前面没有父选择器 */</span></span>
<span class="line"><span style="color:#24292E;">::</span><span style="color:#22863A;">v-deep</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#005CC5;">son</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    ...;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ul><li>使用两个 style 标签(不要使用这种方案，仅仅用于原理的理解)</li></ul><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">style</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">/* 用于修改第三方库的样式 */</span></span>
<span class="line"><span style="color:#6A737D;">/* 在这里面定义的属性全局样式，如果其他组件内有相同的结构，其他组件的样式会受到影响 */</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">style</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">style</span><span style="color:#24292E;"> scoped lang=&quot;scss&quot;</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#6A737D;">/* 自己的组件内样式 */</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">style</span><span style="color:#D73A49;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>`,26)]))}const y=n(p,[["render",o]]);export{b as __pageData,y as default};
