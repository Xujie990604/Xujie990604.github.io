import{_ as l,c as a,o as e,ag as t}from"./chunks/framework.BDwTZuFy.js";const p=JSON.parse('{"title":"定位","description":"","frontmatter":{},"headers":[],"relativePath":"docs/HTML+CSS/CSS部分/网页的布局/定位.md","filePath":"docs/HTML+CSS/CSS部分/网页的布局/定位.md","lastUpdated":1712646874000}'),o={name:"docs/HTML+CSS/CSS部分/网页的布局/定位.md"};function n(r,i,d,s,u,h){return e(),a("div",null,i[0]||(i[0]=[t('<h1 id="定位" tabindex="-1">定位 <a class="header-anchor" href="#定位" aria-label="Permalink to &quot;定位&quot;">​</a></h1><ul><li>定位允许你从正常的文档流中取出元素，并使他们具有不同的行为</li></ul><h2 id="四种定位值" tabindex="-1">四种定位值 <a class="header-anchor" href="#四种定位值" aria-label="Permalink to &quot;四种定位值&quot;">​</a></h2><h3 id="static" tabindex="-1">static <a class="header-anchor" href="#static" aria-label="Permalink to &quot;static&quot;">​</a></h3><ul><li>不指定 position 的值</li></ul><h3 id="relative-相对定位" tabindex="-1">relative:相对定位 <a class="header-anchor" href="#relative-相对定位" aria-label="Permalink to &quot;relative:相对定位&quot;">​</a></h3><ul><li>占据正常的文档流中</li><li>主要用于创造定位上下文</li></ul><h3 id="absolute-绝对定位" tabindex="-1">absolute：绝对定位 <a class="header-anchor" href="#absolute-绝对定位" aria-label="Permalink to &quot;absolute：绝对定位&quot;">​</a></h3><ul><li>不在正常的文档流布局中，坐在自己的一层</li><li>元素设置为 absolute 之后，默认会把元素内部转换为 inline-block</li></ul><h3 id="fixed-固定定位" tabindex="-1">fixed：固定定位 <a class="header-anchor" href="#fixed-固定定位" aria-label="Permalink to &quot;fixed：固定定位&quot;">​</a></h3><ul><li>固定定位相当于浏览器视口本身</li></ul><h3 id="sticky-粘性定位" tabindex="-1">sticky： 粘性定位 <a class="header-anchor" href="#sticky-粘性定位" aria-label="Permalink to &quot;sticky： 粘性定位&quot;">​</a></h3><ul><li>父级元素有 overflow：scroll,auto,overlay，hidden时，粘性定位会失效。</li><li>粘性定位只在父元素内生效</li><li>父元素的高度不能低于 sticky 元素的高度</li><li>必须指定 top，bottom，left，right 其中之一。否则会处于相对定位(目前自己只知道 top 的效果，left 的效果不知道是什么)</li></ul><p>浮动的定位还是基于正常的文档流，只有改变了文档流的显示。(半脱离，元素会无视它，但是文本能看到)</p><h2 id="包含块" tabindex="-1">包含块 <a class="header-anchor" href="#包含块" aria-label="Permalink to &quot;包含块&quot;">​</a></h2><ul><li>元素的大小和位置通常受包含块的影响，通常包含块是最接近的块级元素的 ！！！内容！！！ 位置</li></ul><ol><li>元素的属性为position：fixed</li></ol><ul><li>则元素的包含块为浏览器窗口。</li></ul><ol><li>元素的属性是position：absolute</li></ol><ul><li>则元素的包含块为最接近的父级元素具有 position 但不能是 static。</li><li>元素的 width 用百分比时需要考虑包含块的 padding。</li><li>如果都没有显示的定义 position，那么元素的包含块是浏览器视口(不是body是(html标签的父级))</li><li>根目录所在的包含块是一个称之为！！！初始包含块！！！的矩形</li></ul><h2 id="偏移量的设置" tabindex="-1">偏移量的设置 <a class="header-anchor" href="#偏移量的设置" aria-label="Permalink to &quot;偏移量的设置&quot;">​</a></h2><ul><li>设置了 position: absolute; 之后，元素会被在内部转化为 inline-block 类型</li><li>元素被设置了 position:absolute; 之后，会以 border 来进行定位而不是 content。</li><li>这个和其他的位置定位不一样，设置的每一个关键字，代表的是元素的那一边的位置，如果设置了对角的关键字(left right)的话，那么就会固定住了子元素在父元素的相对位置。</li><li>设置 left:0;right:0;top:0;bottom:0; 之后，如果自身没有定义宽或者高，就会继承父元素(指的是包含块而不是DOM)的宽高。且内容不能偏移出父级元素的区域,否则会消失。</li></ul><h2 id="z-index的介绍" tabindex="-1">z-index的介绍 <a class="header-anchor" href="#z-index的介绍" aria-label="Permalink to &quot;z-index的介绍&quot;">​</a></h2><ul><li><p>层叠上下文是 HTML 中的一个三维的概念，实际上网页除了x轴，y轴，它还有z轴。z轴往往都是用来设定层的先后顺序的。一个元素在z轴方向上的堆叠顺序，是由层叠上下文和层叠级别这两个因素决定的。</p></li><li><p>同为神奇盒子的父元素如果没有显示的声明 z-index (或者显式的声明为auto)，子元素的 z-index 值小于零的话，子元素就回到父元素的底下。</p></li><li><p>只要是父元素显式的声明了 z-index 的话，无论子元素的 z-index 的值多小，子元素也不会到父元素的底下。 <strong>那些定位的元素想要创建层叠上下文的话，必须要显式的定义 z-index</strong></p></li><li><p>需要 z-index 触发创建层叠上下文 position 值为 relative/absolute/fixed flex 项(父元素 display 为 flex|inline-flex)，注意是子元素，不是父元素创建层叠上下文</p></li><li><p>不需要 z-index 触发创建层叠上下文 元素的透明度 opacity 小于1 transform 不是 none</p></li><li><p>z-Index 只能应用于(神奇盒子) 默认值为auto(auto和0有区别，有些情况下设置auto不会创建层叠上下文)</p></li><li><p>神奇盒子最常见的定位不为 static，元素的 opacity 不为 1, z-Index 不为 auto 的 flex 项(不是声明了flex的元素，是元素的子元素)，元素的 transform 不为 none。</p></li><li><p>对于普通的盒子，(无特殊定义的，inline-block，float)，z-Index 无法影响他们的层叠顺序写在 html 文档后面的块会挡在前面的盒子上面。 float 的盒子会挡在没有 float 的盒子上面，文字等 inline，inline-block 会在 block 的元素上面</p></li><li><p>z-Index 是在自己的父级内的层叠顺序，和伯伯元素的层叠顺序建立在父级和伯伯元素的层叠顺序上。</p></li><li><p>有些特定的元素也会在内部创建自己的堆叠上下文，内部的排序不会受到其他堆叠盒子的影响。</p></li><li><p>具有层叠的顺序的盒子和普通盒子的视轴顺序 HTML &gt; z-Index为负值的盒子 &gt; 块状盒子 &gt; float盒子 &gt; inline,inline-block &gt; z-Index为auto或者0的盒子 &gt; z-Index为正值的盒子</p></li></ul>',24)]))}const x=l(o,[["render",n]]);export{p as __pageData,x as default};
