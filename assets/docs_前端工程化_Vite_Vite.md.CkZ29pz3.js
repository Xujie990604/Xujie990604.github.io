import{_ as a,c as l,o,ag as i}from"./chunks/framework.BDwTZuFy.js";const h=JSON.parse('{"title":"Vite","description":"","frontmatter":{},"headers":[],"relativePath":"docs/前端工程化/Vite/Vite.md","filePath":"docs/前端工程化/Vite/Vite.md","lastUpdated":1757412909000}'),t={name:"docs/前端工程化/Vite/Vite.md"};function s(n,e,d,c,r,p){return o(),l("div",null,e[0]||(e[0]=[i(`<h1 id="vite" tabindex="-1">Vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;Vite&quot;">​</a></h1><ul><li>Vite 预设了场景 <code>WEB</code>, 并且将大部分常见的 WEB 构建需求都直接做成了默认的配置(TS、JSX、CSS、SCSS、LESS、POSTCSS、CSS Modules)</li></ul><h2 id="一、开发阶段" tabindex="-1">一、开发阶段 <a class="header-anchor" href="#一、开发阶段" aria-label="Permalink to &quot;一、开发阶段&quot;">​</a></h2><ul><li>使用 ESBuild 进行转译(使用 GO 语言编写，可以直接转换成机器代码。能够充分利用 CPU 多核的运算)</li><li>真正的<code>按需编译</code>，开发过程中不需要事先打包应用程序，而是在应用程序<code>运行时</code>即时<code>编译和构建</code>。</li></ul><h3 id="_1-1-利用缓存提速" tabindex="-1">1.1 利用缓存提速 <a class="header-anchor" href="#_1-1-利用缓存提速" aria-label="Permalink to &quot;1.1 利用缓存提速&quot;">​</a></h3><ul><li>已<code>预构建的依赖</code>请求使用 <code>HTTP 头 max-age=31536000, immutable</code> 进行<code>强缓存</code>，以提高开发期间页面<code>重新加载的性能</code></li></ul><h3 id="_1-2-仅执行转译" tabindex="-1">1.2 仅执行转译 <a class="header-anchor" href="#_1-2-仅执行转译" aria-label="Permalink to &quot;1.2 仅执行转译&quot;">​</a></h3><ul><li>Vite 仅执行 <code>.ts</code> 的转译工作(使用 ESBuild 将 ts 转成 js)，并<code>不执行</code>类型检查。并假定类型检查已经由 IDE 实现了。</li><li>因为类型检查需要了解<code>整个模块图</code>，这和 Vite 开发阶段 <code>按需编译</code> 的原则相违背。</li><li>同理 Eslint 的静态分析也与 Vite 的工作流程<code>解耦</code></li></ul><h3 id="_1-3-现代浏览器兼容性" tabindex="-1">1.3 现代浏览器兼容性 <a class="header-anchor" href="#_1-3-现代浏览器兼容性" aria-label="Permalink to &quot;1.3 现代浏览器兼容性&quot;">​</a></h3><ul><li>开发阶段的浏览器是必须支持 <code>原生 ES 模块</code>、<code>原生 ES 动态导入</code> 和 <code>import.meta</code> 的，所以也就代表着浏览器支持 ES6 特性，所以开发阶段的 babel 转化工作会省略很多(Vite 开发阶段的产物包含很多 ES6 的语法，例如，箭头函数，解构，模板字符串等)</li></ul><h2 id="二、build-阶段" tabindex="-1">二、build 阶段 <a class="header-anchor" href="#二、build-阶段" aria-label="Permalink to &quot;二、build 阶段&quot;">​</a></h2><ul><li>使用 Rollup 进行打包</li></ul><h2 id="三、index-html" tabindex="-1">三、index.html <a class="header-anchor" href="#三、index-html" aria-label="Permalink to &quot;三、index.html&quot;">​</a></h2><ul><li>index.html 会被 Vite 视为依赖图的一部分</li><li>在开发阶段整个 Vite 项目目录会被视为服务器的根目录，index.html 是入口文件。在 index.html 中可以直接基于 Vite 项目目录的结构进行资源引入</li></ul><h2 id="四、浏览器支持度" tabindex="-1">四、浏览器支持度 <a class="header-anchor" href="#四、浏览器支持度" aria-label="Permalink to &quot;四、浏览器支持度&quot;">​</a></h2><ol><li>开发阶段：Vite 将 <code>esnext</code> 作为转化目标，假设是 <code>现代浏览器</code> 并支持所有最新的 js 和 css 特性，这样在开发阶段就能尽量减少 Vite 的代码转译工作，使得速度更快</li><li>生产构建：支持 <code>原生 ES 模块</code> 、<code>原生 ES 动态导入</code> 和 <code>import.meta</code></li></ol><h2 id="五、静态资源处理" tabindex="-1">五、静态资源处理 <a class="header-anchor" href="#五、静态资源处理" aria-label="Permalink to &quot;五、静态资源处理&quot;">​</a></h2><ul><li>服务时引入一个静态资源会返回解析后的公共路径</li><li>css 中的 url() 以同样的方式处理</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// imgUrl 在开发时会是 /img.png，在生产构建后会是 /assets/img.2d8efhg.png。</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> imgUrl </span><span style="color:#D73A49;">from</span><span style="color:#032F62;"> &quot;./img.png&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hero-img&quot;</span><span style="color:#24292E;">).src </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> imgUrl;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>public 目录的特性和之前保持一致，永远使用根绝对路径引入</li></ul>`,20)]))}const m=a(t,[["render",s]]);export{h as __pageData,m as default};
