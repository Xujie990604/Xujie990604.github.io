import{_ as n,c as a,o as l,ag as p}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"this","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/函数&作用域/this.md","filePath":"docs/JavaScript/函数&作用域/this.md","lastUpdated":1735478813000}'),e={name:"docs/JavaScript/函数&作用域/this.md"};function o(c,s,r,t,i,b){return l(),a("div",null,s[0]||(s[0]=[p(`<h1 id="this" tabindex="-1">this <a class="header-anchor" href="#this" aria-label="Permalink to &quot;this&quot;">​</a></h1><ul><li>注意<code>this是函数内部的自动生成的一个参数</code></li><li>this 永远指向一个对象</li><li>this 指的是函数<code>被调用</code>时(不是定义时)所在的<code>环境</code></li><li>因为在 JS 中函数可以像值一样被传递，所以函数中的 this 指向是不固定的。要看函数被调用时实际所在的 <code>环境</code></li><li>函数预编译过程中 this 指向 windows(起始的时候都是指向 window，后来随着 <code>环境</code> 的改变而改变 this 的指向)</li></ul><h2 id="函数的四种调用模式-绑定模式-环境" tabindex="-1">函数的四种调用模式(绑定模式/环境) <a class="header-anchor" href="#函数的四种调用模式-绑定模式-环境" aria-label="Permalink to &quot;函数的四种调用模式(绑定模式/环境)&quot;">​</a></h2><p>优先级: new 绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p><ol><li>函数调用模式 this =&gt; window</li><li>方法调用模式 this =&gt; obj</li><li>call/apply 调用模式 this =&gt; 传入的参数</li><li>构造器调用模式 this =&gt; 准备生成的实例</li></ol><h2 id="默认绑定-作为普通函数被调用" tabindex="-1">默认绑定: 作为普通函数被调用 <a class="header-anchor" href="#默认绑定-作为普通函数被调用" aria-label="Permalink to &quot;默认绑定: 作为普通函数被调用&quot;">​</a></h2><ul><li>this 指向的是全局对象</li><li>非严格模式下，全局中的函数的 this 指向 window， 严格模式下，全局中的函数的 this 指向 undefined。</li></ul><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> foo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6F42C1;">  baz</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#6F42C1;">    alert</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#24292E;">foo.</span><span style="color:#6F42C1;">baz</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// foo - because baz belongs to the foo object when invoked</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> anotherBaz </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> foo.baz;</span></span>
<span class="line"><span style="color:#6F42C1;">anotherBaz</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// global - because the method anotherBaz() belongs to the global object when invoked, NOT foo</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#24292E;">name </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &quot;window&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> obj</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  name: </span><span style="color:#032F62;">&quot;obj&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#6F42C1;">  a</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#6F42C1;">    test</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#D73A49;">    function</span><span style="color:#6F42C1;"> test</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name);</span></span>
<span class="line"><span style="color:#6A737D;">      // 注意 test() 是作为**函数**被调用的。没有 xxx.test()。所以 this 指向 window</span></span>
<span class="line"><span style="color:#6A737D;">      // 这是 JS 在语言设计上的一个错误，会导致内部函数的 this 指向与预期不符</span></span>
<span class="line"><span style="color:#6A737D;">      // 解决方案： 1. const that = this  2. 使用箭头函数定义内部函数</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name); </span><span style="color:#6A737D;">// a() 是作为 obj 的方法被调用的。this 指向 obj</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#24292E;">obj.</span><span style="color:#6F42C1;">a</span><span style="color:#24292E;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="隐式绑定-作为对象的方法被调用" tabindex="-1">隐式绑定: 作为对象的方法被调用 <a class="header-anchor" href="#隐式绑定-作为对象的方法被调用" aria-label="Permalink to &quot;隐式绑定: 作为对象的方法被调用&quot;">​</a></h2><ul><li>this 指向的是调用方法的对象</li></ul><h2 id="显示绑定-call-apply-bind" tabindex="-1">显示绑定: call/apply/bind <a class="header-anchor" href="#显示绑定-call-apply-bind" aria-label="Permalink to &quot;显示绑定: call/apply/bind&quot;">​</a></h2><ul><li>改变 this 指向(修正 this 的指向)</li><li>obj1.call(obj2, a, b, c)。实现用别人的方法来完成自己的功能。</li><li>apply(obj,[a, b, c])的区别就是传递参数时的不同</li><li>call/apply 的 this 传递 null 时。函数体内的 this 会指向默认的宿主对象，在浏览器中则是 window</li></ul><h3 id="bind" tabindex="-1">bind <a class="header-anchor" href="#bind" aria-label="Permalink to &quot;bind&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> obj</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  name: </span><span style="color:#032F62;">&quot;xujie123&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#6F42C1;">  say</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name);</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> b</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  name: </span><span style="color:#032F62;">&quot;xiaohan&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#6A737D;">//  使用bind生成一个新的函数，这个函数的this值永远的被绑定在了 b这个对象上</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> newSay </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> obj.say.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(b);</span></span>
<span class="line"><span style="color:#6A737D;">// 直接执行bind就相当于每次都执行了一个(使用call改变了this指向的)函数一样</span></span>
<span class="line"><span style="color:#6F42C1;">newSay</span><span style="color:#24292E;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="bind-使用-call-实现" tabindex="-1">bind 使用 call 实现 <a class="header-anchor" href="#bind-使用-call-实现" aria-label="Permalink to &quot;bind 使用 call 实现&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> obj</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  name: </span><span style="color:#032F62;">&quot;xujie123&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#6F42C1;">  say</span><span style="color:#24292E;">(</span><span style="color:#E36209;">a</span><span style="color:#24292E;">, </span><span style="color:#E36209;">b</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> b);</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> b</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  name: </span><span style="color:#032F62;">&quot;xiaohan&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#6A737D;">// 使用call和闭包来实现bind方法</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#6F42C1;"> newSay</span><span style="color:#D73A49;"> =</span><span style="color:#D73A49;"> function</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">...</span><span style="color:#E36209;">arg</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> obj.say.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(obj, </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">arg);</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#6A737D;">// 直接调用方法，函数的this一直指向对象b</span></span>
<span class="line"><span style="color:#6F42C1;">newSay</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;world&quot;</span><span style="color:#24292E;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="new-绑定-在构造函数中" tabindex="-1">new 绑定: 在构造函数中 <a class="header-anchor" href="#new-绑定-在构造函数中" aria-label="Permalink to &quot;new 绑定: 在构造函数中&quot;">​</a></h2><ul><li>使用 new 调用构造函数时，构造函数中的 this，指代的是这个新的实例(新对象)</li></ul>`,19)]))}const d=n(e,[["render",o]]);export{u as __pageData,d as default};
