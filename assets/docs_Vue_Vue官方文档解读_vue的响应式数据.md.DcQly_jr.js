import{_ as n,c as a,o as l,ag as p}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"Vue 的响应式数据","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Vue/Vue官方文档解读/vue的响应式数据.md","filePath":"docs/Vue/Vue官方文档解读/vue的响应式数据.md","lastUpdated":1734874907000}'),e={name:"docs/Vue/Vue官方文档解读/vue的响应式数据.md"};function o(r,s,c,t,i,y){return l(),a("div",null,s[0]||(s[0]=[p(`<h1 id="vue-的响应式数据" tabindex="-1">Vue 的响应式数据 <a class="header-anchor" href="#vue-的响应式数据" aria-label="Permalink to &quot;Vue 的响应式数据&quot;">​</a></h1><ul><li>由于 Vue 会在实例初始化的时候对 property 进行 getter/setter 转化。所以只有在一开始就存在 data 中的数据才是响应式的。(比如在组件的 created, beforeCreate 钩子函数中为组件添加一个属性，这个数据不是响应式的数据)(所有需要响应式的值都要在 data 中声明，即使它目前是一个空值，也要占上位子)</li><li>对于已经创建的实例，Vue 不允许动态的添加 根级别的响应式 property <code>this.$set(object, &#39;key&#39;, value)</code> 也就是说这个 object 参数，不能是 this._data 及以上更高级别的数据</li></ul><h2 id="watcher" tabindex="-1">watcher <a class="header-anchor" href="#watcher" aria-label="Permalink to &quot;watcher&quot;">​</a></h2><ul><li>Vue 中的 watcher 主要分为三种,这三种 watcher 都是使用 class Watcher 实现的</li></ul><ol><li>每个 Vue 组件都有一个渲染 watcher</li><li>计算属性对应着一个 watcher(计算属性的 watcher 中有个 dirty 属性用来标识计算属性是否需要重新计算)</li><li>watch 对应着一个 watcher</li></ol><h2 id="观察者模式" tabindex="-1">观察者模式 <a class="header-anchor" href="#观察者模式" aria-label="Permalink to &quot;观察者模式&quot;">​</a></h2><ul><li>观察者模式是一种处理一对多关系的通知机制</li></ul><ol><li>Observer(被 observer 处理的 data 是被观察者)(被观察者不需要关注观察者的具体行为，职责相对单一，只需要及时通知就可以了): 这里的主要工作是递归地监听对象上的所有属性，在属性值改变的时候，触发相应的 Watcher</li><li>Watcher(观察者借助抽象来实现不同的行为): 当监听的数据值修改时，执行相应的回调函数(回调函数可能是 Vue 自身的视图更新，也可能是用户自定义的回调函数)</li><li>Dep(观察者模式中的事件总线): 链接 Observer 和 Watcher 的桥梁，每一个 Observer 对应一个 Dep，它内部维护一个数组，保存与该 Observer 相关的 Watcher</li></ol><h2 id="vue-响应式数据的缺陷" tabindex="-1">Vue 响应式数据的缺陷 <a class="header-anchor" href="#vue-响应式数据的缺陷" aria-label="Permalink to &quot;Vue 响应式数据的缺陷&quot;">​</a></h2><h3 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h3><ul><li>vue 在构造函数 new Vue() 时，就通过 Object.defineProperty 中的 getter 和 setter 这两个方法，完成了对数据的绑定。所以直接通过 vm.arr[1] = &#39;aa&#39;的方法，无法修改值去触发 vue 中视图的更新，必须还得通过 Object.defineProperty 的方法去改变，而 Vue.$set() 就封装了 js 底层的 Object.defineProperty 方法。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 数组中使用 $set 方法实际上就是 Vue 将操作转化为使用 splice 方法去做</span></span>
<span class="line"><span style="color:#6A737D;">// 因为 Splice 方法会触发响应式，最终也就是触发了响应式</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">$set</span><span style="color:#24292E;">(要修改的数组，索引值，修改后的元素)</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">$set</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lists, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;no one&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 数组中使用 $delete 方法实际上就是 Vue 将操作转化为使用 splice 方法去做</span></span>
<span class="line"><span style="color:#6A737D;">// 因为 Splice 方法会触发响应式，最终也就是触发了响应式</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">$delete</span><span style="color:#24292E;">(要修改的数组，索引值)</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">$set</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lists, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="会触发响应式" tabindex="-1">会触发响应式 <a class="header-anchor" href="#会触发响应式" aria-label="Permalink to &quot;会触发响应式&quot;">​</a></h4><ul><li>push()pop()shift()unshift()splice()sort()reverse()称为变更方法，会触发视图更新</li><li>这些方法会触发 Vue 的数据响应式，是因为 Vue 在原方法的基础上进行加工。</li></ul><h4 id="不会触发响应式" tabindex="-1">不会触发响应式 <a class="header-anchor" href="#不会触发响应式" aria-label="Permalink to &quot;不会触发响应式&quot;">​</a></h4><ul><li>filter(),concat(),slice()非变更方法，并不会丢弃原数组重新进行渲染</li><li>数组长度的变化是非响应式的， <code>arr.length = 4</code></li><li>通过索引来直接修改数组中的数据也是非响应式的 <code>arr[2] = &#39;xujie&#39;</code></li></ul><h3 id="对象" tabindex="-1">对象 <a class="header-anchor" href="#对象" aria-label="Permalink to &quot;对象&quot;">​</a></h3><h4 id="对象不会触发响应式的情况" tabindex="-1">对象不会触发响应式的情况 <a class="header-anchor" href="#对象不会触发响应式的情况" aria-label="Permalink to &quot;对象不会触发响应式的情况&quot;">​</a></h4><ul><li>由于 Object.defineProperty 自身的缺陷，在一个对象中添加一个新属性，使用 delete 删除一个属性的时候不会触发响应式。</li><li>Object.defineProperty 只能追踪一个属性是否被更改</li></ul><h4 id="vue-set-object-key-value" tabindex="-1">Vue.set(object, &#39;key&#39;, &#39;value&#39;) <a class="header-anchor" href="#vue-set-object-key-value" aria-label="Permalink to &quot;Vue.set(object, &#39;key&#39;, &#39;value&#39;)&quot;">​</a></h4><ul><li>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 对象上使用 $set 方法，实际上就是 Vue 手动去调用响应式的方法，手动的将新增的属性变成响应式的</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">$set</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.error, </span><span style="color:#032F62;">&quot;phone&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;手机号不能为空&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 对象上使用 $delete 方法，实际上就是 Vue 手动的去触发依赖，通知所有使用到该对象的组件去重新渲染</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">$delete</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.error, </span><span style="color:#032F62;">&quot;phone&quot;</span><span style="color:#24292E;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="vue-的响应式原理" tabindex="-1">Vue 的响应式原理 <a class="header-anchor" href="#vue-的响应式原理" aria-label="Permalink to &quot;Vue 的响应式原理&quot;">​</a></h2><ul><li><p>Object 在 getter 中收集依赖，在 setter 中触发依赖</p></li><li><p>页面初始化时： Observer 类会附加到每一个 object 上。递归的调用 defineReactive 函数将每一个属性都通过 Object.defineProperty() 进行数据拦截。在读取数据时会收集依赖，在修改数据后会触发依赖。每一个属性都会拥有一个独立的 Dep 实例</p></li><li><p>页面使用数据时：读取数据时会实例化一个 Watcher,在 new Watcher 的过程中会将 watcher 实例赋值给全局的变量(方便 dep 去收集)。然后默认读取一下该属性(读取该属性会触发依赖收集，从而将 watcher 实例放到响应式属性的 dep 中)</p></li><li><p>改变数据后: 改变数据会触发依赖执行，执行当前响应式属性的 dep 数组中的所有 watcher 的 update 方法(update 的回调函数 可能是执行组件的 render 函数，也可以是执行用户自定义的回调函数)</p></li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">    // 定义一个 dep 类，专门用来管理依赖</span></span>
<span class="line"><span style="color:#D73A49;">    class</span><span style="color:#6F42C1;"> Dep</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">      constructor</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#005CC5;">        this</span><span style="color:#24292E;">.subs </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [];</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#6A737D;">      // 在 dep 实例中添加一个依赖</span></span>
<span class="line"><span style="color:#6F42C1;">      addSub</span><span style="color:#24292E;">(</span><span style="color:#E36209;">sub</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#005CC5;">        this</span><span style="color:#24292E;">.subs.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(sub);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#6A737D;">      // 在 dep 实例中移除一个依赖</span></span>
<span class="line"><span style="color:#6F42C1;">      removeSub</span><span style="color:#24292E;">(</span><span style="color:#E36209;">sub</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6F42C1;">        remove</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.subs, sub);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#6A737D;">      // 在依赖添加之前进行一次判断，在依赖不为 undefined 时才会添加</span></span>
<span class="line"><span style="color:#6F42C1;">      depend</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">        if</span><span style="color:#24292E;"> (window.target) {</span></span>
<span class="line"><span style="color:#005CC5;">          this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">addSub</span><span style="color:#24292E;">(window.target);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#6A737D;">      // 循环触发 dep 实例中依赖的 update 方法</span></span>
<span class="line"><span style="color:#6F42C1;">      notify</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6A737D;">        // 返回数组的拷贝</span></span>
<span class="line"><span style="color:#D73A49;">        const</span><span style="color:#005CC5;"> subs</span><span style="color:#D73A49;"> =</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.subs.</span><span style="color:#6F42C1;">slice</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">        // 循环的触发所有依赖</span></span>
<span class="line"><span style="color:#D73A49;">        for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> index </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> 0</span><span style="color:#24292E;">; index </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> subs.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">; index</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">          subs[i].</span><span style="color:#6F42C1;">update</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // 收集的依赖是一个什么东西，起一个名字叫做 watcher</span></span>
<span class="line"><span style="color:#6A737D;">    // 外界通过 watcher 来读取数据, watcher 中 读取数据前将自身赋值给 window.target , 然后读取数据，使得自身当做依赖被收集</span></span>
<span class="line"><span style="color:#6A737D;">    // 数据发生变化时，触发 setter ，在 setter 中通知 watcher，然后 watcher 执行对应的回调函数</span></span>
<span class="line"><span style="color:#D73A49;">    class</span><span style="color:#6F42C1;"> Watcher</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">      // vm 是 引用类型数据(Object, Arr)</span></span>
<span class="line"><span style="color:#6A737D;">      // expOrFn 是需要响应式处理的那个属性 (key值)</span></span>
<span class="line"><span style="color:#6A737D;">      // cb 回调函数(callback)</span></span>
<span class="line"><span style="color:#D73A49;">      constructor</span><span style="color:#24292E;">(</span><span style="color:#E36209;">vm</span><span style="color:#24292E;">, </span><span style="color:#E36209;">expOrFn</span><span style="color:#24292E;">, </span><span style="color:#E36209;">cb</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#005CC5;">        this</span><span style="color:#24292E;">.vm </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> vm;</span></span>
<span class="line"><span style="color:#6A737D;">        // 执行 this.getter() ，就可以读取某个属性的值</span></span>
<span class="line"><span style="color:#005CC5;">        this</span><span style="color:#24292E;">.getter </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> parsePath</span><span style="color:#24292E;">(expOrFn);</span></span>
<span class="line"><span style="color:#005CC5;">        this</span><span style="color:#24292E;">.cb </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cb;</span></span>
<span class="line"><span style="color:#6A737D;">        // 在实例化一个 watcher 实例的时候，会自动执行 get 方法</span></span>
<span class="line"><span style="color:#005CC5;">        this</span><span style="color:#24292E;">.value </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#6A737D;">      // 在执行 get 方法时，将 watcher 实例本身赋值给 window.target</span></span>
<span class="line"><span style="color:#6F42C1;">      get</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        window.target </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">        // 调用 this.getter 方法时 会读取某个属性的值，因为属性做了响应式处理，会把 window.target(也就是watcher实例) 放到 dep 实例中</span></span>
<span class="line"><span style="color:#D73A49;">        let</span><span style="color:#24292E;"> value </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.getter.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.vm, </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.vm)</span></span>
<span class="line"><span style="color:#6A737D;">        // 将依赖插入 dep 实例后，将 window.target 赋值为 undefined</span></span>
<span class="line"><span style="color:#24292E;">        window.target </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> undefined</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">        return</span><span style="color:#24292E;"> value</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#6A737D;">      // 在执行 update 的时候，会执行传进来的回调函数(在 Vue 中这个回调函数的作用就是用来进行视图渲染)</span></span>
<span class="line"><span style="color:#6F42C1;">      update</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">        const</span><span style="color:#005CC5;"> oldValue</span><span style="color:#D73A49;"> =</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.value;</span></span>
<span class="line"><span style="color:#005CC5;">        this</span><span style="color:#24292E;">.value </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#005CC5;">        this</span><span style="color:#24292E;">.cb.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.vm, </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.value, oldValue)</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // Observer 类会附加到每一个被侦测的 Object 上</span></span>
<span class="line"><span style="color:#6A737D;">    // 一但被附加上，Observer 会将 object 的所有属性转换为 getter/setter 的形式</span></span>
<span class="line"><span style="color:#D73A49;">    class</span><span style="color:#6F42C1;"> Observer</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">      constructor</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#005CC5;">        this</span><span style="color:#24292E;">.value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> value</span></span>
<span class="line"><span style="color:#6A737D;">        // 只有当 value 的数据类型 object 时才能执行 walk 方法</span></span>
<span class="line"><span style="color:#D73A49;">        if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">Array.</span><span style="color:#6F42C1;">is</span><span style="color:#24292E;">(value)) {</span></span>
<span class="line"><span style="color:#005CC5;">          this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">walk</span><span style="color:#24292E;">(value)</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#6A737D;">      // 会将 obj 的每一个 key 值都调用一次 defineReactive 方法</span></span>
<span class="line"><span style="color:#6F42C1;">      walk</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">        const</span><span style="color:#005CC5;"> keys</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> Object.</span><span style="color:#6F42C1;">keys</span><span style="color:#24292E;">(obj)</span></span>
<span class="line"><span style="color:#24292E;">        keys.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#E36209;">item</span><span style="color:#D73A49;"> =&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6F42C1;">          defineReactive</span><span style="color:#24292E;">(obj, item, obj[item])</span></span>
<span class="line"><span style="color:#24292E;">        })</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // 如果 value 数据类型为基本数据类型，就把这个属性设置为响应式的</span></span>
<span class="line"><span style="color:#6A737D;">    // 如果 value 数据类型为 Object，就递归的把这个对象的所有属性(包括子属性) 全都转换成响应式的</span></span>
<span class="line"><span style="color:#6A737D;">    // { Object } Obj 引用类型对象</span></span>
<span class="line"><span style="color:#6A737D;">    // { String } key 对象的键值</span></span>
<span class="line"><span style="color:#6A737D;">    // { any }  value  Obj[key]的值</span></span>
<span class="line"><span style="color:#D73A49;">    function</span><span style="color:#6F42C1;"> defineReactive</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">, </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, </span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">      // 如果 value 是一个引用类型的话，通过 Observer 实例来循环的将每一个值都设置为响应式的</span></span>
<span class="line"><span style="color:#D73A49;">      if</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> value </span><span style="color:#D73A49;">===</span><span style="color:#032F62;"> &quot;Object&quot;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">        new</span><span style="color:#6F42C1;"> Observer</span><span style="color:#24292E;">(value)</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#6A737D;">      // 每个 key 值对应的依赖，存储在 dep 实例中</span></span>
<span class="line"><span style="color:#D73A49;">      let</span><span style="color:#24292E;"> dep </span><span style="color:#D73A49;">=</span><span style="color:#D73A49;"> new</span><span style="color:#6F42C1;"> Dep</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      Object.</span><span style="color:#6F42C1;">defineProperty</span><span style="color:#24292E;">(obj, key, {</span></span>
<span class="line"><span style="color:#24292E;">        configurable: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">        enumerable: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#6F42C1;">        get</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6A737D;">          // 收集依赖</span></span>
<span class="line"><span style="color:#24292E;">          dep.</span><span style="color:#6F42C1;">depend</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#D73A49;">          return</span><span style="color:#24292E;"> value;</span></span>
<span class="line"><span style="color:#24292E;">        },</span></span>
<span class="line"><span style="color:#6F42C1;">        set</span><span style="color:#24292E;">(</span><span style="color:#E36209;">newValue</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">          // 如果改变过后的值和之前的值一样，则什么也不做</span></span>
<span class="line"><span style="color:#6A737D;">          // value 变量存储在 defineReactive 函数的作用域中</span></span>
<span class="line"><span style="color:#D73A49;">          if</span><span style="color:#24292E;"> (value </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> newValue) {</span></span>
<span class="line"><span style="color:#D73A49;">            return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">          }</span></span>
<span class="line"><span style="color:#24292E;">          val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newValue;</span></span>
<span class="line"><span style="color:#6A737D;">          // 触发依赖</span></span>
<span class="line"><span style="color:#24292E;">          dep.</span><span style="color:#6F42C1;">notify</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      });</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br></div></div><ul><li>Array 在 getter 中收集依赖，在拦截器(拦截器也是就重写的方法)中触发依赖</li><li>Object.defineProperty 是有监控数组下标变化的能力的，为什么 Vue2 没有采用 Object.defineProperty 拦截器的方式来监听数组变化而是采用了重写部分数组方法的形式主要是为了性能考虑。想要把数组下标值全部变成响应式的就需要给每一个下标都要添加一个 Object.defineProperty 监听器，会增加内存的消耗。数组相对于对象来说一般长度会更长，无疑会更加大内存的压力，并且基于业务场景考量数组的使用大多数是遍历，很少会有单独修改下标值的场景。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> arrayProto</span><span style="color:#D73A49;"> =</span><span style="color:#005CC5;"> Array</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// arrayMethods 这个对象的原型上拥有和 Array 原型上一样的方法和属性</span></span>
<span class="line"><span style="color:#6A737D;">// arrayMethods 对象是拦截器(在这个对象中的方法不仅能实现原有的功能，还能 发送变化通知)</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> arrayMethods</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> Object.</span><span style="color:#6F42C1;">create</span><span style="color:#24292E;">(arrayProto)[</span></span>
<span class="line"><span style="color:#24292E;">  (</span><span style="color:#032F62;">&quot;push&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;pop&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;shift&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;unshift&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;splice&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;sort&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;reverse&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">].</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">method</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 缓存原始方法</span></span>
<span class="line"><span style="color:#D73A49;">  const</span><span style="color:#005CC5;"> original</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> arrayProto[method];</span></span>
<span class="line"><span style="color:#6A737D;">  // 通过 switch 判断如果是 push,unshift，splice等可以新增数组元素的方法</span></span>
<span class="line"><span style="color:#6A737D;">  // 将新增的元素取出来放到 inserted 中</span></span>
<span class="line"><span style="color:#6F42C1;">  def</span><span style="color:#24292E;">(arrayMethods, method, </span><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> mutator</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">...</span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">    const</span><span style="color:#005CC5;"> result</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> original.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, args);</span></span>
<span class="line"><span style="color:#D73A49;">    const</span><span style="color:#005CC5;"> ob</span><span style="color:#D73A49;"> =</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.__ob__;</span></span>
<span class="line"><span style="color:#D73A49;">    let</span><span style="color:#24292E;"> inserted;</span></span>
<span class="line"><span style="color:#D73A49;">    switch</span><span style="color:#24292E;"> (method) {</span></span>
<span class="line"><span style="color:#D73A49;">      case</span><span style="color:#032F62;"> &quot;push&quot;</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#D73A49;">      case</span><span style="color:#032F62;"> &quot;unshift&quot;</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">        inserted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> args;</span></span>
<span class="line"><span style="color:#D73A49;">        break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">      case</span><span style="color:#032F62;"> &quot;splice&quot;</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">        inserted </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> args.</span><span style="color:#6F42C1;">slice</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">        break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">        // 如果检测到数组元素有新增的话，把新增的数据也变成响应式的</span></span>
<span class="line"><span style="color:#D73A49;">        if</span><span style="color:#24292E;"> (inserted) {</span></span>
<span class="line"><span style="color:#24292E;">          ob.dep.</span><span style="color:#6F42C1;">notice</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        ob.dep.</span><span style="color:#6F42C1;">notify</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#D73A49;">        return</span><span style="color:#24292E;"> result;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#24292E;">  Object.</span><span style="color:#6F42C1;">defineProperty</span><span style="color:#24292E;">(arrayMethods, methods, {</span></span>
<span class="line"><span style="color:#6F42C1;">    value</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> mutator</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">...</span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">      // 在拦截器中直接通过 this.__ob__ 来访问 value 上面的 Observer 实例</span></span>
<span class="line"><span style="color:#D73A49;">      const</span><span style="color:#005CC5;"> ob</span><span style="color:#D73A49;"> =</span><span style="color:#005CC5;"> this</span><span style="color:#24292E;">.__ob__;</span></span>
<span class="line"><span style="color:#6A737D;">      // 在拦截器中，检测到数组发生变化时，就会通知依赖数据发生了变化</span></span>
<span class="line"><span style="color:#24292E;">      ob.dep.</span><span style="color:#6F42C1;">notify</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">      // 在调用 arrayMethods 对象中的方法时，实际上调用的还是 Array 原型上面的方法</span></span>
<span class="line"><span style="color:#6A737D;">      // 但是我们可以在这个函数中做一些其他事情，比如 发送变化通知</span></span>
<span class="line"><span style="color:#D73A49;">      return</span><span style="color:#24292E;"> original.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, args);</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#24292E;">    enumerable: </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    writable: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    configurable: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Observer 类会附加到每一个被侦测的 Array 上</span></span>
<span class="line"><span style="color:#6A737D;">// 被侦测的 Array 会被替换原型上的方法，或者直接在自身上添加重写之后的方法</span></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#6F42C1;"> Observer</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">  constructor</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#005CC5;">    this</span><span style="color:#24292E;">.value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> value;</span></span>
<span class="line"><span style="color:#6A737D;">    // Array 类型的数据，在 Observer 中存储依赖列表</span></span>
<span class="line"><span style="color:#6A737D;">    // 因为 Array 在 getter 中收集依赖，在拦截器中触发依赖，所以依赖要保存在一个双方都可以访问到的地方</span></span>
<span class="line"><span style="color:#005CC5;">    this</span><span style="color:#24292E;">.dep </span><span style="color:#D73A49;">=</span><span style="color:#D73A49;"> new</span><span style="color:#6F42C1;"> Dep</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">    // 调用 def 函数用于在 value 上新增一个 __ob__ 属性，这个属性的值就是当前 Observer 实例</span></span>
<span class="line"><span style="color:#6F42C1;">    def</span><span style="color:#24292E;">(value, </span><span style="color:#032F62;">&quot;__ob__&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">    // 只有当 value 的数据类型 Array 时,将上面的拦截器替换 Array 类型数据原有的原型</span></span>
<span class="line"><span style="color:#6A737D;">    // 如果浏览器不支持 __proto__ 的使用，直接粗暴的在 value 为 Array 类型的数值上逐个添加拦截器上的方法</span></span>
<span class="line"><span style="color:#6A737D;">    // (自己身上有的属性就不会去原型上面找，从而实现了方法的覆盖)</span></span>
<span class="line"><span style="color:#D73A49;">    if</span><span style="color:#24292E;"> (Array.</span><span style="color:#6F42C1;">isArray</span><span style="color:#24292E;">(value)) {</span></span>
<span class="line"><span style="color:#005CC5;">      this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">observerArray</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#6A737D;">  // 工具函数，用于循环的将数组中的所有属性都变成响应式的。例如 length 属性</span></span>
<span class="line"><span style="color:#6F42C1;">  observerArray</span><span style="color:#24292E;">(</span><span style="color:#E36209;">items</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">    for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> 0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">L</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> items.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#005CC5;"> L</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6F42C1;">      observe</span><span style="color:#24292E;">(items[i]);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// def 工具函数，用于在 value 上添加 Observer 实例</span></span>
<span class="line"><span style="color:#6A737D;">// 1. 添加完实例之后，在 getter 中可以通过 value.__ob__.dep 来访问 Observer 上面的 dep</span></span>
<span class="line"><span style="color:#6A737D;">// 2. 在拦截器中，可以通过 this.__ob__(在拦截器中 this 就是 value) 来访问 Observer 上面的 dep</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> def</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">, </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, </span><span style="color:#E36209;">val</span><span style="color:#24292E;">, </span><span style="color:#E36209;">enumerable</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  Object.</span><span style="color:#6F42C1;">defineProperty</span><span style="color:#24292E;">(obj, key, {</span></span>
<span class="line"><span style="color:#24292E;">    value: val,</span></span>
<span class="line"><span style="color:#24292E;">    enumerable: </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">enumerable,</span></span>
<span class="line"><span style="color:#24292E;">    writable: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    configurable: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 通过 defineReactive 对数据进行响应式的处理(当前函数只考虑 Array 的场景)</span></span>
<span class="line"><span style="color:#6A737D;">// Array 在 getter 中收集依赖， 在拦截器中触发依赖</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> defineReactive</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">, </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, </span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 通过 Observer 函数将 Array 数据类型的数据上的原生方法进行处理</span></span>
<span class="line"><span style="color:#D73A49;">  if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> (val </span><span style="color:#D73A49;">===</span><span style="color:#032F62;"> &quot;object&quot;</span><span style="color:#24292E;">)) {</span></span>
<span class="line"><span style="color:#D73A49;">    new</span><span style="color:#6F42C1;"> Observer</span><span style="color:#24292E;">(val);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> childOb </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> observe</span><span style="color:#24292E;">(val);</span></span>
<span class="line"><span style="color:#24292E;">  Object.</span><span style="color:#6F42C1;">defineProperty</span><span style="color:#24292E;">(data, key, {</span></span>
<span class="line"><span style="color:#24292E;">    enumerable: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    configurable: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#6F42C1;">    get</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#6A737D;">      // 收集依赖</span></span>
<span class="line"><span style="color:#D73A49;">      if</span><span style="color:#24292E;"> (childOb) {</span></span>
<span class="line"><span style="color:#24292E;">        childOb.dep.</span><span style="color:#6F42C1;">depend</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#D73A49;">      return</span><span style="color:#24292E;"> val;</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 尝试为 value 创建一个 Observer 实例</span></span>
<span class="line"><span style="color:#6A737D;">// 如果 value 已经是响应式数据了，不需要再次创建一个新的 Observer 实例，直接返回已有的实例</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> observe</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">, </span><span style="color:#E36209;">asRootData</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">  if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">isObject</span><span style="color:#24292E;">(value)) {</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> ob;</span></span>
<span class="line"><span style="color:#D73A49;">  if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">hasOwn</span><span style="color:#24292E;">(value, </span><span style="color:#032F62;">&quot;__ob__&quot;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> value.__ob__ </span><span style="color:#D73A49;">instanceof</span><span style="color:#6F42C1;"> Observer</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    ob </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> value.__ob__;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    ob </span><span style="color:#D73A49;">=</span><span style="color:#D73A49;"> new</span><span style="color:#6F42C1;"> Observer</span><span style="color:#24292E;">(value);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> ob;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br></div></div>`,27)]))}const E=n(e,[["render",o]]);export{u as __pageData,E as default};
