import{_ as e,c as o,o as t,ag as r}from"./chunks/framework.BDwTZuFy.js";const p=JSON.parse('{"title":"JS 中的多线程","description":"","frontmatter":{},"headers":[],"relativePath":"docs/技术文档总结/JavaScript文档/JS中的多线程.md","filePath":"docs/技术文档总结/JavaScript文档/JS中的多线程.md","lastUpdated":1747883909000}'),l={name:"docs/技术文档总结/JavaScript文档/JS中的多线程.md"};function i(d,a,s,n,h,c){return t(),o("div",null,a[0]||(a[0]=[r('<h1 id="js-中的多线程" tabindex="-1">JS 中的多线程 <a class="header-anchor" href="#js-中的多线程" aria-label="Permalink to &quot;JS 中的多线程&quot;">​</a></h1><h2 id="一、浏览器中的多线程" tabindex="-1">一、浏览器中的多线程 <a class="header-anchor" href="#一、浏览器中的多线程" aria-label="Permalink to &quot;一、浏览器中的多线程&quot;">​</a></h2><p>概念 + 示例</p><p>webWorker 支持多线程，但是不支持操作 DOM。</p><h2 id="二、node-js-中的多线程" tabindex="-1">二、Node.js 中的多线程 <a class="header-anchor" href="#二、node-js-中的多线程" aria-label="Permalink to &quot;二、Node.js 中的多线程&quot;">​</a></h2><p>概念 + 示例</p><ul><li>利用异步编程的模型来实现</li></ul><p>TODO：将 node 和常规的后端开发服务进行性能对比，对比下 IO 密集应用情况下 Node 不错的性能下限</p><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ol><li>不适合耗费 CPU 密集型应用</li><li>无法利用多核 CPU 的优势</li></ol><h3 id="node-多线程-多进程" tabindex="-1">Node 多线程(多进程) <a class="header-anchor" href="#node-多线程-多进程" aria-label="Permalink to &quot;Node 多线程(多进程)&quot;">​</a></h3><ol><li>Node 中的多线程, 相关的框架和工具</li></ol><h2 id="js-多线程的缺点" tabindex="-1">JS 多线程的缺点 <a class="header-anchor" href="#js-多线程的缺点" aria-label="Permalink to &quot;JS 多线程的缺点&quot;">​</a></h2><ol><li>不是真正的多线程，而是多进程</li><li>更高的切换代价</li></ol><h2 id="wasm-来实现多线程" tabindex="-1">WASM 来实现多线程 <a class="header-anchor" href="#wasm-来实现多线程" aria-label="Permalink to &quot;WASM 来实现多线程&quot;">​</a></h2><p>概念 + 示例</p>',16)]))}const u=e(l,[["render",i]]);export{p as __pageData,u as default};
