import{_ as n,c as a,o as l,ag as e}from"./chunks/framework.BDwTZuFy.js";const b=JSON.parse('{"title":"事件对象","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/事件/事件对象.md","filePath":"docs/JavaScript/事件/事件对象.md","lastUpdated":1712646874000}'),p={name:"docs/JavaScript/事件/事件对象.md"};function o(r,s,c,t,i,u){return l(),a("div",null,s[0]||(s[0]=[e(`<h1 id="事件对象" tabindex="-1">事件对象 <a class="header-anchor" href="#事件对象" aria-label="Permalink to &quot;事件对象&quot;">​</a></h1><h2 id="事件对象的使用" tabindex="-1">事件对象的使用 <a class="header-anchor" href="#事件对象的使用" aria-label="Permalink to &quot;事件对象的使用&quot;">​</a></h2><ul><li>只有在事件处理程序执行的时候，event 对象才会存在，一旦事件处理程序执行完了，event 对象就会销毁。</li></ul><h3 id="通过匿名函数的方式来绑定事件处理程序" tabindex="-1">通过匿名函数的方式来绑定事件处理程序 <a class="header-anchor" href="#通过匿名函数的方式来绑定事件处理程序" aria-label="Permalink to &quot;通过匿名函数的方式来绑定事件处理程序&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> content</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;content&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">content.</span><span style="color:#6F42C1;">onclick</span><span style="color:#D73A49;"> =</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> person</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(event);  </span><span style="color:#6A737D;">//可以在处理程序中直接使用event来访问事件对象</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">content.</span><span style="color:#6F42C1;">onclick</span><span style="color:#D73A49;"> =</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> person</span><span style="color:#24292E;">(</span><span style="color:#E36209;">a</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(a);  </span><span style="color:#6A737D;">//如果要定义形参的话，定义的第一个形参就是事件对象</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">content.</span><span style="color:#6F42C1;">onclick</span><span style="color:#D73A49;"> =</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> person</span><span style="color:#24292E;">(</span><span style="color:#E36209;">a</span><span style="color:#24292E;">,</span><span style="color:#E36209;">b</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(a,b);  </span><span style="color:#6A737D;">//如果定义了两个形参的话，第一个是事件对象，第二个是undefined</span></span>
<span class="line"><span style="color:#6A737D;">    // 因为普通的函数我们想要让它执行的时候，可以直接加上()执行符号执行，并且可以在执行符号内写上我们需要的实参。</span></span>
<span class="line"><span style="color:#6A737D;">    //但是当一个函数被当做事件处理程序时，函数的执行是在触发事件后由系统调用。函数的实参是由系统添加的。系统规定只会传递一个参数，并且这个参数就是事件对象。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="将已声明的函数赋值给-onclick-函数" tabindex="-1">将已声明的函数赋值给 onclick 函数 <a class="header-anchor" href="#将已声明的函数赋值给-onclick-函数" aria-label="Permalink to &quot;将已声明的函数赋值给 onclick 函数&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> person</span><span style="color:#24292E;">(</span><span style="color:#E36209;">a</span><span style="color:#24292E;">,</span><span style="color:#E36209;">b</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(a,b);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// !!!将已经声明的函数赋值给onClick时不要加上执行符号，加上执行符号代表把函数执行的返回值赋值给onClick。不加执行符号的话代表把函数体赋值给onClick</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  content.onclick </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> person;  </span><span style="color:#6A737D;">//event事件对象,undefined</span></span>
<span class="line"><span style="color:#6A737D;">//函数以事件处理程序的形式被系统调用时，系统只会传入一个参数，就是event事件对象,因为系统只传入了一个参数，所以第二个参数为undefined</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">  person</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;数据a&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;数据b&quot;</span><span style="color:#24292E;">)  </span><span style="color:#6A737D;">// 数据a,数据b</span></span>
<span class="line"><span style="color:#6A737D;">// 函数以普通函数的方式被我们调用时，打印的数据根据我们自己传入的实参相匹配</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="使用-arguments-0-来访问-event" tabindex="-1">使用 arguments[0]来访问 event <a class="header-anchor" href="#使用-arguments-0-来访问-event" aria-label="Permalink to &quot;使用 arguments[0]来访问 event&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> person</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">arguments</span><span style="color:#24292E;">[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">], </span><span style="color:#005CC5;">arguments</span><span style="color:#24292E;">[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">content.onclick </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> person; </span><span style="color:#6A737D;">//event事件对象,undefined</span></span>
<span class="line"><span style="color:#6A737D;">//函数以事件处理程序的形式被系统调用时，系统只会传入一个参数，就是event事件对象.并且arguments[0]就是事件对象。因为系统只传入了一个参数，所以第二个参数为undefined。</span></span>
<span class="line"><span style="color:#6F42C1;">person</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;数据a&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;数据b&quot;</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">//数据a,数据b</span></span>
<span class="line"><span style="color:#6A737D;">// 函数以普通函数的方式被我们调用时，打印的数据根据我们自己传入的实参相匹配</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="如何在事件处理函数中传递参数" tabindex="-1">如何在事件处理函数中传递参数 <a class="header-anchor" href="#如何在事件处理函数中传递参数" aria-label="Permalink to &quot;如何在事件处理函数中传递参数&quot;">​</a></h3><ul><li>无法直接在事件处理函数中人为的传递参数，只能通过在时间处理函数中调用其他函数的方式来传递额外的参数</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> doSomething</span><span style="color:#24292E;">(</span><span style="color:#E36209;">name</span><span style="color:#24292E;">, </span><span style="color:#E36209;">age</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    name,</span></span>
<span class="line"><span style="color:#24292E;">    age,</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> person</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  const</span><span style="color:#005CC5;"> obj</span><span style="color:#D73A49;"> =</span><span style="color:#6F42C1;"> doSomething</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;xujie&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;18&quot;</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">//通过执行其他的函数来获取额外的参数</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(obj);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">content.onclick </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> person;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="事件对象内的属性" tabindex="-1">事件对象内的属性 <a class="header-anchor" href="#事件对象内的属性" aria-label="Permalink to &quot;事件对象内的属性&quot;">​</a></h2><ul><li>currentTarget： 对象的 this 始终等于 currentTarget 的值</li><li>target: target 是事件的实际目标</li><li>type: 事件的类型</li><li>preventDefault()方法 用于阻止事件的默认行为</li><li>stopPropagation()方法 用于停止事件在 DOM 层的传播,进一步取消事件的冒泡和捕获</li><li>eventPhase 确定事件处于事件流的那个状态，捕获为 1，正在进行为 2，冒泡为 3。</li></ul><h2 id="事件对象内的参数" tabindex="-1">事件对象内的参数 <a class="header-anchor" href="#事件对象内的参数" aria-label="Permalink to &quot;事件对象内的参数&quot;">​</a></h2><h3 id="screenx-和-screeny" tabindex="-1">screenX 和 screenY <a class="header-anchor" href="#screenx-和-screeny" aria-label="Permalink to &quot;screenX 和 screenY&quot;">​</a></h3><ul><li>参照点：电脑屏幕左上角 screenX：鼠标点击位置相对于电脑屏幕左上角的水平偏移量 screenY：鼠标点击位置相对于电脑屏幕左上角的垂直偏移量</li></ul><h3 id="clientx-和-clienty" tabindex="-1">clientX 和 clientY <a class="header-anchor" href="#clientx-和-clienty" aria-label="Permalink to &quot;clientX 和 clientY&quot;">​</a></h3><ul><li>参照点：浏览器内容区域(视口)左上角 clientX：鼠标点击位置相对于浏览器可视区域的水平偏移量（不会计算水平滚动的距离） clientY：鼠标点击位置相对于浏览器可视区域的垂直偏移量（不会计算垂直滚动条的距离）</li></ul><h3 id="pagex-和-pagey" tabindex="-1">pageX 和 pageY <a class="header-anchor" href="#pagex-和-pagey" aria-label="Permalink to &quot;pageX 和 pageY&quot;">​</a></h3><ul><li>参照点：网页的左上角 pageX：鼠标点击位置相对于网页左上角的水平偏移量，也就是 clientX 加上水平滚动条的距离 pageY：鼠标点击位置相对于网页左上角的垂直平偏移量，也就是 clientY 加上垂直滚动条的距离</li></ul><h3 id="offsetx-和-offsety" tabindex="-1">offsetX 和 offsetY <a class="header-anchor" href="#offsetx-和-offsety" aria-label="Permalink to &quot;offsetX 和 offsetY&quot;">​</a></h3><ul><li>参照点：鼠标点击位置相对于触发事件对象的水平距离 offsetX：鼠标点击位置相对于触发事件对象的水平距离 offsetY：鼠标点击位置相对于触发事件对象的垂直距离</li></ul><h2 id="ie-浏览器的事件对象" tabindex="-1">IE 浏览器的事件对象 <a class="header-anchor" href="#ie-浏览器的事件对象" aria-label="Permalink to &quot;IE 浏览器的事件对象&quot;">​</a></h2><ul><li>高程 p358</li></ul>`,25)]))}const d=n(p,[["render",o]]);export{b as __pageData,d as default};
