import{_ as o,c as a,o as i,ag as l}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"浏览器渲染原理","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/浏览器渲染页面的过程/浏览器渲染原理.md","filePath":"docs/JavaScript/浏览器渲染页面的过程/浏览器渲染原理.md","lastUpdated":1735478813000}'),d={name:"docs/JavaScript/浏览器渲染页面的过程/浏览器渲染原理.md"};function t(c,e,r,s,n,S){return i(),a("div",null,e[0]||(e[0]=[l('<h1 id="浏览器渲染原理" tabindex="-1">浏览器渲染原理 <a class="header-anchor" href="#浏览器渲染原理" aria-label="Permalink to &quot;浏览器渲染原理&quot;">​</a></h1><h2 id="web-的执行分为两个阶段" tabindex="-1">Web 的执行分为两个阶段 <a class="header-anchor" href="#web-的执行分为两个阶段" aria-label="Permalink to &quot;Web 的执行分为两个阶段&quot;">​</a></h2><ol><li><p>页面构建阶段(通过对 HTML 标签的解析，进行 DOM 的构建): 遇到 Script 标签(script 标签也是 HTML 标签的一种)时，执行标签中的 JavaScript 代码(1.JavaScript 代码通过浏览器暴露给JavaScript 引擎的全局对象: window 对象 来操作当前页面中的所有变量，浏览器 API 2.注册事件处理器)</p></li><li><p>事件处理阶段: 按照事件的生成顺序，依赖事件队列来循环的处理事件。</p></li></ol><h3 id="不同环境下的顶层对象" tabindex="-1">不同环境下的顶层对象 <a class="header-anchor" href="#不同环境下的顶层对象" aria-label="Permalink to &quot;不同环境下的顶层对象&quot;">​</a></h3><ol><li>ES5 之前，顶层对象的属性(window)和全局变量是等价的 (变量未声明就使用不报错)(window 对象是当前的浏览器窗口，是当前页面的顶层对象)</li><li>ES6 之后，var 和 function 声明的全局变量依旧是顶层对象(window窗口)的属性，let, const, class 声明的全局变量不再属于 window 对象(在控制台中查看时属于一个叫 script 的对象)</li></ol><h4 id="globalthis-对象-和宿主环境有关" tabindex="-1">globalThis 对象(和宿主环境有关) <a class="header-anchor" href="#globalthis-对象-和宿主环境有关" aria-label="Permalink to &quot;globalThis 对象(和宿主环境有关)&quot;">​</a></h4><ol><li>浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有 window。</li><li>浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有self。</li><li>Node 里面，顶层对象是 global，但其他环境都不支持。</li></ol><p><strong>ES2020在语言标准的层面，引入 globalThis 作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的 this。</strong></p><h2 id="浏览器加载时间线" tabindex="-1">浏览器加载时间线 <a class="header-anchor" href="#浏览器加载时间线" aria-label="Permalink to &quot;浏览器加载时间线&quot;">​</a></h2><ol><li>创建 Document 对象，开始解析 web 页面。这个阶段的 document.readyState = &quot;loading&quot;.</li><li>遇到 link 外部 css，创建线程异步加载，并<code>继续解析文档</code>。(CSS 下载完成后进行 CSS 解析工作)</li><li>遇到 script 外部 js，并且没有设置 async，defer，浏览器下载 JS 文件，并<code>阻塞后续 DOM 结点的解析</code>。等待 JS 下载完成并执行完成该脚本后<code>继续解析文档</code>。</li><li>遇到 script 外部 js，并且设置 async，defer。浏览器创建线程加载，<code>并继续解析文档</code>。(async 属性的脚本，脚本加载完之后立即执行)</li><li>遇到 img 标签的话，先正常解析 dom 结构，然后浏览器异步加载 src，<code>并继续解析文档</code>。</li><li>当文档解析(DomTree完成，但是 img 的图片不一定被加载出来，只是 img 的 DOM 被加载了)完成后，document.readyState = &quot;interactive&quot;.</li><li>当文档解析(DomTree完成)完成后，所有设置 defer 的脚本会按照顺序执行。</li><li>document 对象触发 <code>DOMContentLoaded</code> 事件(<code>文档解析完成</code>)</li><li>当所有 <code>async 的脚本加载完成并执行</code>、<code>img 加载完成</code>、<code>CSS 加载解析完成</code>后。document.readyState = &quot;complete&quot;, window 对象触发 <code>load</code> 事件(<code>文档加载完成</code>)</li><li>从此之后，以异步响应的方式处理用户输入，网络事件等。(由<code>页面构建阶段</code>转为<code>事件驱动阶段</code>)</li></ol><h2 id="js-和-css-对于-dom-解析的阻塞" tabindex="-1">JS 和 CSS 对于 DOM 解析的阻塞 <a class="header-anchor" href="#js-和-css-对于-dom-解析的阻塞" aria-label="Permalink to &quot;JS 和 CSS 对于 DOM 解析的阻塞&quot;">​</a></h2><h3 id="js" tabindex="-1">JS <a class="header-anchor" href="#js" aria-label="Permalink to &quot;JS&quot;">​</a></h3><ul><li>JS 的<code>下载</code>和<code>执行</code>都会阻碍后面 DOM 的<code>解析</code>(因为 JS 可以改变和操作 DOM)</li><li>所以 script 标签推荐写在 body 的最下方， 在 DOM 解析完成之后再下载和执行 JS 文件。以减少页面空白时间</li></ul><h3 id="css" tabindex="-1">CSS <a class="header-anchor" href="#css" aria-label="Permalink to &quot;CSS&quot;">​</a></h3><ul><li>CSS 是由单独的下载线程异步下载的：</li></ul><ol><li><code>link 标签后没有 script 标签</code>：解析 CSS 不会阻塞 DOM 的解析，但是会阻塞页面的渲染(因为 Render Tree = DOM Tree + CSSOM Tree)</li><li><code>link 标签后有 script 标签</code>: 解析 CSS 行为本身并不会阻塞 DOM 的解析，但是 JS 文件执行需要等待 CSS 解析完成，又因为 JS 的执行会阻塞 DOM 的解析，所以解析 CSS 行为会间接的阻塞 DOM 的解析。</li></ol><ul><li>所以 link 标签推荐写在 head 中，尽快的下载 CSS 文件，尽快完成 CSS 的解析，以免阻塞 JS 的文件执行。</li></ul>',17)]))}const p=o(d,[["render",t]]);export{u as __pageData,p as default};
