import{_ as e,c as o,o as t,ag as l}from"./chunks/framework.BDwTZuFy.js";const m=JSON.parse('{"title":"依赖预构建","description":"","frontmatter":{},"headers":[],"relativePath":"docs/前端工程化/Vite/依赖预构建.md","filePath":"docs/前端工程化/Vite/依赖预构建.md","lastUpdated":1757412909000}'),r={name:"docs/前端工程化/Vite/依赖预构建.md"};function i(d,a,n,s,h,c){return t(),o("div",null,a[0]||(a[0]=[l('<h1 id="依赖预构建" tabindex="-1">依赖预构建 <a class="header-anchor" href="#依赖预构建" aria-label="Permalink to &quot;依赖预构建&quot;">​</a></h1><h2 id="一、依赖预构建原因" tabindex="-1">一、依赖预构建原因 <a class="header-anchor" href="#一、依赖预构建原因" aria-label="Permalink to &quot;一、依赖预构建原因&quot;">​</a></h2><h3 id="_1-1-commonjs-和-umd-兼容性" tabindex="-1">1.1 CommonJS 和 UMD 兼容性 <a class="header-anchor" href="#_1-1-commonjs-和-umd-兼容性" aria-label="Permalink to &quot;1.1 CommonJS 和 UMD 兼容性&quot;">​</a></h3><ul><li>将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块</li></ul><h3 id="_1-2-性能" tabindex="-1">1.2 性能 <a class="header-anchor" href="#_1-2-性能" aria-label="Permalink to &quot;1.2 性能&quot;">​</a></h3><ul><li>将那些具有许多内部模块的 ESM 依赖项转换为单个模块。例如: lodash-es 有超过 600 个内置模块，如果不处理，浏览器会同时发出 600 多个 HTTP 请求</li></ul><h2 id="二、缓存" tabindex="-1">二、缓存 <a class="header-anchor" href="#二、缓存" aria-label="Permalink to &quot;二、缓存&quot;">​</a></h2><h3 id="_2-1-文件系统缓存" tabindex="-1">2.1 文件系统缓存 <a class="header-anchor" href="#_2-1-文件系统缓存" aria-label="Permalink to &quot;2.1 文件系统缓存&quot;">​</a></h3><ul><li>将预构建的依赖项缓存到 <code>node_modules/.vite</code> 目录下</li></ul><h3 id="_2-2-浏览器储存" tabindex="-1">2.2 浏览器储存 <a class="header-anchor" href="#_2-2-浏览器储存" aria-label="Permalink to &quot;2.2 浏览器储存&quot;">​</a></h3><ul><li>已预构建的依赖请求使用 HTTP 头 <code>max-age=31536000, immutable</code> 进行强缓存</li></ul>',11)]))}const u=e(r,[["render",i]]);export{m as __pageData,u as default};
