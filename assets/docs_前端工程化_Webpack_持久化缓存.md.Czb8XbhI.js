import{_ as s,c as e,o as n,ag as l}from"./chunks/framework.BDwTZuFy.js";const h=JSON.parse('{"title":"持久化缓存","description":"","frontmatter":{},"headers":[],"relativePath":"docs/前端工程化/Webpack/持久化缓存.md","filePath":"docs/前端工程化/Webpack/持久化缓存.md","lastUpdated":1756707094000}'),p={name:"docs/前端工程化/Webpack/持久化缓存.md"};function t(o,a,c,r,d,i){return n(),e("div",null,a[0]||(a[0]=[l(`<h1 id="持久化缓存" tabindex="-1">持久化缓存 <a class="header-anchor" href="#持久化缓存" aria-label="Permalink to &quot;持久化缓存&quot;">​</a></h1><blockquote><p>Webpack 5 的持久化缓存是一个内置的、智能的、全局性的缓存系统。它的目标是：在保持构建结果正确性的前提下，最大限度地重用上一次构建的成果，从而极大地提升二次构建（或多次构建）的速度</p></blockquote><h2 id="基本配置" tabindex="-1">基本配置 <a class="header-anchor" href="#基本配置" aria-label="Permalink to &quot;基本配置&quot;">​</a></h2><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// webpack5 持久化缓存配置</span></span>
<span class="line"><span style="color:#6F42C1;">cache</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#6F42C1;">  type</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&#39;filesystem&#39;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 使用文件系统缓存</span></span>
<span class="line"><span style="color:#6F42C1;">  cacheDirectory</span><span style="color:#24292E;">: path.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(__dirname, </span><span style="color:#032F62;">&#39;node_modules/.cache/webpack&#39;</span><span style="color:#24292E;">), </span><span style="color:#6A737D;">// 缓存目录</span></span>
<span class="line"><span style="color:#6F42C1;">  buildDependencies</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#6A737D;">    // 当配置文件发生变化时，缓存失效</span></span>
<span class="line"><span style="color:#6F42C1;">    config</span><span style="color:#24292E;">: [__filename],</span></span>
<span class="line"><span style="color:#6A737D;">    // 当这些文件发生变化时，缓存失效</span></span>
<span class="line"><span style="color:#6F42C1;">    tsconfig</span><span style="color:#24292E;">: [path.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(__dirname, </span><span style="color:#032F62;">&#39;tsconfig.json&#39;</span><span style="color:#24292E;">)],</span></span>
<span class="line"><span style="color:#6F42C1;">    postcss</span><span style="color:#24292E;">: [path.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(__dirname, </span><span style="color:#032F62;">&#39;postcss.config.js&#39;</span><span style="color:#24292E;">)],</span></span>
<span class="line"><span style="color:#6F42C1;">    project</span><span style="color:#24292E;">: [path.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(__dirname, </span><span style="color:#032F62;">&#39;project.config.js&#39;</span><span style="color:#24292E;">)]</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">},</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="工作流程" tabindex="-1">工作流程 <a class="header-anchor" href="#工作流程" aria-label="Permalink to &quot;工作流程&quot;">​</a></h2><ol><li><p>首次构建（冷启动）：</p><ul><li>当你第一次运行 Webpack 构建时，缓存是空的。</li><li>Webpack 会正常执行所有编译步骤：解析模块、运行 loader、分析依赖、优化代码、生成 chunk。</li><li>在构建的最后阶段，Webpack 会将这些辛辛苦苦计算出来的中间结果——比如每个模块处理后的代码、模块间的依赖关系、chunk 的构成等——序列化后写入到文件系统中（通常是 node_modules/.cache/webpack 目录下）。</li></ul></li><li><p>二次构建（热启动）：</p><ul><li>你再次运行 Webpack 构建。</li><li>Webpack 启动后，首先会去检查缓存是否存在。</li><li>缓存验证（最智能的部分）：Webpack 会快速检查项目文件。它会对比文件的修改时间戳 (mtime) 和内容哈希 (content hash)，来判断一个文件自上次构建以来是否发生了变化。</li><li>缓存命中 (Cache Hit)：如果一个模块和它的所有依赖都没有变化，Webpack 会直接跳过**“读取 -&gt; loader 转换 -&gt; 解析”**这一系列昂贵的步骤，直接从磁盘缓存中读取上次处理好的结果。</li><li>缓存未命中 (Cache Miss)：如果一个模块发生了变化，Webpack 只会重新处理这一个发生变化的模块以及受它影响的模块，而其他未变化的模块仍然会使用缓存。</li></ul></li></ol><h2 id="和-cache-loader-的对比" tabindex="-1">和 cache-loader 的对比 <a class="header-anchor" href="#和-cache-loader-的对比" aria-label="Permalink to &quot;和 cache-loader 的对比&quot;">​</a></h2><table tabindex="0"><thead><tr><th>对比项</th><th>cache-loader（Webpack 4）</th><th>Webpack 5 持久化缓存（内置）</th></tr></thead><tbody><tr><td>缓存级别</td><td>Loader 层面</td><td>编译器层面</td></tr><tr><td>详细解释</td><td>它只关心某个特定 loader 链的输入和输出。它不知道 Webpack 的全局依赖关系。</td><td>它在 Webpack 的核心工作流中，理解整个项目的依赖图，缓存的是模块对象本身，而不仅仅是 loader 的输出字符串。</td></tr><tr><td>缓存内容</td><td>缓存 loader 转换后的代码字符串和 Source Map。</td><td>缓存经过处理后的整个模块对象，包括代码、依赖、AST 等更丰富的数据结构。</td></tr><tr><td>智能化程度</td><td>较低。它只检查输入文件的内容是否变化。对于 Webpack 配置、Node 版本等全局变化无能为力。</td><td>非常高。它能感知到文件变化、依赖关系变化、Webpack 配置变化、node_modules 变化等，并进行智能的、细粒度的缓存失效</td></tr><tr><td>性能和效率</td><td>有限提升。它只能跳过其后面的 loader，但 Webpack 仍然需要进行模块解析、依赖分析等工作。并且，读写大量小缓存文件本身也有 I/O 开销</td><td>质的飞跃。它能跳过从文件读取到依赖分析的整个漫长过程，直接复用已构建好的模块。反序列化缓存对象比重新编译整个模块快得多。</td></tr><tr><td>集成方式</td><td>手动侵入式。需要手动将其添加到每个需要缓存的 loader 链中。rules: [{ use: [&#39;cache-loader&#39;, &#39;babel-loader&#39;, ...] }]</td><td>非侵入式。一个顶层配置 cache: { type: &#39;filesystem&#39; } 即可全局开启，对所有模块和 loader 生效。</td></tr></tbody></table>`,8)]))}const y=s(p,[["render",t]]);export{h as __pageData,y as default};
