import{_ as e,c as t,o,ag as s}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"hash 策略","description":"","frontmatter":{},"headers":[],"relativePath":"docs/前端工程化/Vite/Hash策略.md","filePath":"docs/前端工程化/Vite/Hash策略.md","lastUpdated":1756718412000}'),h={name:"docs/前端工程化/Vite/Hash策略.md"};function l(i,a,r,n,c,d){return o(),t("div",null,a[0]||(a[0]=[s('<h1 id="hash-策略" tabindex="-1">hash 策略 <a class="header-anchor" href="#hash-策略" aria-label="Permalink to &quot;hash 策略&quot;">​</a></h1><blockquote><p>[ contenthash ] 文件级别的 hash</p></blockquote><h2 id="一、js-文件" tabindex="-1">一、JS 文件 <a class="header-anchor" href="#一、js-文件" aria-label="Permalink to &quot;一、JS 文件&quot;">​</a></h2><ol><li>模块自身的内容: 这是最直接的因素</li><li>其依赖模块的内容: 一个最终的 JS Chunk 文件可能包含了多个模块，其中任何一个源模块发生变化，这个 Chunk 文件的 hash 值就会发生变化</li><li>依赖关系图（import Graph）：依赖项发生变化，这个 Chunk 文件的 hash 值就会发生变化</li></ol><h2 id="二、css-文件" tabindex="-1">二、CSS 文件 <a class="header-anchor" href="#二、css-文件" aria-label="Permalink to &quot;二、CSS 文件&quot;">​</a></h2><ol><li>模块自身的内容</li><li>@import 的依赖内容</li><li>PostCSS 等处理器的配置</li></ol><h2 id="三、静态资源" tabindex="-1">三、静态资源 <a class="header-anchor" href="#三、静态资源" aria-label="Permalink to &quot;三、静态资源&quot;">​</a></h2><ul><li>文件自身的二进制内容</li></ul>',8)]))}const p=e(h,[["render",l]]);export{u as __pageData,p as default};
