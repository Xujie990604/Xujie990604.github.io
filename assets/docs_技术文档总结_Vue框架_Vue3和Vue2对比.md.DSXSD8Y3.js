import{_ as a,c as i,o as l,ag as o}from"./chunks/framework.BDwTZuFy.js";const r="/assets/%E9%80%89%E5%9E%8B%E5%BC%8FAPI%E5%92%8C%E7%BB%84%E5%90%88%E5%BC%8FAPI.DZ5P-6yz.png",b=JSON.parse('{"title":"Vue3 和 Vue2 对比","description":"","frontmatter":{},"headers":[],"relativePath":"docs/技术文档总结/Vue框架/Vue3和Vue2对比.md","filePath":"docs/技术文档总结/Vue框架/Vue3和Vue2对比.md","lastUpdated":1734874907000}'),u={name:"docs/技术文档总结/Vue框架/Vue3和Vue2对比.md"};function t(h,e,n,d,c,s){return l(),i("div",null,e[0]||(e[0]=[o('<h1 id="vue3-和-vue2-对比" tabindex="-1">Vue3 和 Vue2 对比 <a class="header-anchor" href="#vue3-和-vue2-对比" aria-label="Permalink to &quot;Vue3 和 Vue2 对比&quot;">​</a></h1><h2 id="一、响应式原理" tabindex="-1">一、响应式原理 <a class="header-anchor" href="#一、响应式原理" aria-label="Permalink to &quot;一、响应式原理&quot;">​</a></h2><h3 id="vue2" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2" aria-label="Permalink to &quot;Vue2&quot;">​</a></h3><ul><li>Vue2 使用 <code>Object.defineProperty</code> 来拦截对象属性的改变</li></ul><h4 id="vue2-响应式缺点" tabindex="-1">Vue2 响应式缺点 <a class="header-anchor" href="#vue2-响应式缺点" aria-label="Permalink to &quot;Vue2 响应式缺点&quot;">​</a></h4><ol><li>只有在一开始就存在 data 中的数据才是响应式的</li><li>无法响应式的为对象添加属性( Vue2 提供 <code>Vue.set(object, &#39;key&#39;, &#39;value&#39;)</code> 来解决缺陷)</li></ol><h3 id="vue3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;Vue3&quot;">​</a></h3><ul><li>Vue3 使用 proxy 来对整个对象进行代理</li></ul><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ol><li>性能上更加优秀，因为代理的是整个对象。不需要递归的给每个响应式属性都添加一个 Observer 类</li><li>直接对整个对象进行劫持，不需要做额外的考虑(相比于 Vue2 来说)</li></ol><p>TODO：为何性能更加优秀？</p><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ol><li>不支持 IE 浏览器(因为 babel 无法转换 Proxy)</li><li>如果使用<code>组合式API</code>的写法，需要注意的地方比较多。使用 reactive 时解构可能会丢失响应式</li></ol><h2 id="二、书写方式的对比" tabindex="-1">二、书写方式的对比 <a class="header-anchor" href="#二、书写方式的对比" aria-label="Permalink to &quot;二、书写方式的对比&quot;">​</a></h2><h3 id="vue2-代码" tabindex="-1">Vue2 代码 <a class="header-anchor" href="#vue2-代码" aria-label="Permalink to &quot;Vue2 代码&quot;">​</a></h3><ul><li>仅支持选项式编写代码</li></ul><h3 id="vue3-代码" tabindex="-1">Vue3 代码 <a class="header-anchor" href="#vue3-代码" aria-label="Permalink to &quot;Vue3 代码&quot;">​</a></h3><ul><li>同时支持选项式 API 和 组合式 API</li></ul><h4 id="组合式-api-的特点" tabindex="-1">组合式 API 的特点 <a class="header-anchor" href="#组合式-api-的特点" aria-label="Permalink to &quot;组合式 API 的特点&quot;">​</a></h4><ul><li>代码的写法更加简洁，同一个逻辑关注点相关的代码被归为了一组：我们无需再为了一个逻辑关注点在不同的选项块间来回滚动切换</li></ul><p><img src="'+r+'" alt="选项式API与组合式API"></p><ul><li>可以方便的将一组代码移动到一个外部文件中(组合函数的形式，不依赖 this)，能够实现更加简洁高效的逻辑复用。不在需要为了抽象而重新组织代码，降低了重构的成本。</li><li>可以更好的支持类型推导(TS)</li><li>选项式 API 将开发者锁定在规定的代码组织模式中，组合式 API 允许开发者在编写代码时运用上 javaScript 代码组织的最佳实践</li></ul><h2 id="三、vue3-的浏览器兼容性" tabindex="-1">三、Vue3 的浏览器兼容性 <a class="header-anchor" href="#三、vue3-的浏览器兼容性" aria-label="Permalink to &quot;三、Vue3 的浏览器兼容性&quot;">​</a></h2><ul><li>Vue3 不再支持 IE 浏览器</li></ul><h2 id="四、mixin-和-组合式函数的对比" tabindex="-1">四、Mixin 和 组合式函数的对比 <a class="header-anchor" href="#四、mixin-和-组合式函数的对比" aria-label="Permalink to &quot;四、Mixin 和 组合式函数的对比&quot;">​</a></h2><ul><li>在 Vue3 中不推荐使用 Mixin 进行代码的逻辑复用，推荐使用组合式函数来代替 Mixin(组合式函数中可以使用 Vue 的所有 API)，组合式函数 + Ref + 解构的模式可以解决 Mixin 的所有问题</li></ul><h3 id="mixin-的缺点" tabindex="-1">Mixin 的缺点 <a class="header-anchor" href="#mixin-的缺点" aria-label="Permalink to &quot;Mixin 的缺点&quot;">​</a></h3><ol><li>不清晰的数据来源：使用多个 Mixin 时，实例上的数据来自哪里变得不清晰。</li><li>命名空间冲突: 多个 Mixin 会造成命名冲突</li><li>隐式的 Mixin 交流：多个 Mixin 依赖相同属性时，会使得它们隐形的耦合在一起(并没有显式的使用参数)</li></ol><h2 id="五、细小变化" tabindex="-1">五、细小变化 <a class="header-anchor" href="#五、细小变化" aria-label="Permalink to &quot;五、细小变化&quot;">​</a></h2><ol><li>Vue3 支持碎片，一个组件可以拥有多个根节点(能有效地减少很多无用的 div)</li><li>Vue3 的设计模式给予开发者<code>按需引入</code>API 的能力。可以减少不必要的引用导致性能或者体积问题、</li><li>Vue3 将声明周期 beforeCreate() created() 合并为 setup(), 开发者在 setup() 函数中编写代码并且注册其他的声明周期函数</li><li>V-if 和 v-for 的优先级不同</li><li>Vue3 中开始广泛使用 provide/inject 来进行跨层级的组件通信</li><li>父组件想要获取子组件的属性/方法，需要使用 defineExpose 来暴露属性/方法</li></ol><h2 id="六、渲染性能提升" tabindex="-1">六、渲染性能提升 <a class="header-anchor" href="#六、渲染性能提升" aria-label="Permalink to &quot;六、渲染性能提升&quot;">​</a></h2><ol><li>静态树提升</li><li>patch Flag 标记</li></ol>',32)]))}const x=a(u,[["render",t]]);export{b as __pageData,x as default};
