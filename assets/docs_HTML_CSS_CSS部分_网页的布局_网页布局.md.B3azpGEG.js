import{_ as i,c as l,o as e,ag as t}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"网页的布局","description":"","frontmatter":{},"headers":[],"relativePath":"docs/HTML+CSS/CSS部分/网页的布局/网页布局.md","filePath":"docs/HTML+CSS/CSS部分/网页的布局/网页布局.md","lastUpdated":1712646874000}'),o={name:"docs/HTML+CSS/CSS部分/网页的布局/网页布局.md"};function n(h,a,s,r,d,c){return e(),l("div",null,a[0]||(a[0]=[t(`<h1 id="网页的布局" tabindex="-1">网页的布局 <a class="header-anchor" href="#网页的布局" aria-label="Permalink to &quot;网页的布局&quot;">​</a></h1><h2 id="css值" tabindex="-1">css值 <a class="header-anchor" href="#css值" aria-label="Permalink to &quot;css值&quot;">​</a></h2><h3 id="绝对长度单位" tabindex="-1">绝对长度单位 <a class="header-anchor" href="#绝对长度单位" aria-label="Permalink to &quot;绝对长度单位&quot;">​</a></h3><ul><li>px</li></ul><h3 id="相对长度单位" tabindex="-1">相对长度单位 <a class="header-anchor" href="#相对长度单位" aria-label="Permalink to &quot;相对长度单位&quot;">​</a></h3><ul><li><p>em 是基于继承的大小进行缩放，所以可以通过父元素的 font-size 来控制子元素的大小，但是 em 会有多次继承的问题，孙元素的font-size 为 <code>1.34 * 1.34 *父元素的 font-size</code>(假如都是1.34em的话)</p></li><li><p>em 用于计算盒模型的大小时，是基于本身的 font-size 的大小进行缩放的。</p></li><li><p>百分数和使用 em 没有区别</p></li><li><p>rem 是基于 html 的 font-size 的大小进行计算的</p></li></ul><h3 id="vh-vm-vw" tabindex="-1">vh，vm，vw <a class="header-anchor" href="#vh-vm-vw" aria-label="Permalink to &quot;vh，vm，vw&quot;">​</a></h3><ul><li>vh 相对于视口的高度，视口被均分成 100 的单位的vh</li><li>vw 相对于视口的宽度，视口被分成 100 单位的vw</li><li>vm 相对于视口的高度或者宽度中最小的那一个，其中最小的那一个被均分为 100 个单位的 vm</li><li>视口的定义是浏览器内部的可视区域的大小，不包含任务栏标题栏，以及底部的工具栏的浏览器区域大小</li></ul><h2 id="字体" tabindex="-1">字体 <a class="header-anchor" href="#字体" aria-label="Permalink to &quot;字体&quot;">​</a></h2><h3 id="font-family" tabindex="-1">font-family <a class="header-anchor" href="#font-family" aria-label="Permalink to &quot;font-family&quot;">​</a></h3><ul><li>是一个备选的字体的列表</li><li>是一个可继承属性</li></ul><h3 id="font-style" tabindex="-1">font-style <a class="header-anchor" href="#font-style" aria-label="Permalink to &quot;font-style&quot;">​</a></h3><ul><li>指的不是字体类型而只是字体的一种形态，比如斜体font-style：italic；</li><li>i标签因为只有css的行为被弃用，不在表示斜体，而是用来别的用途，比如实物名。</li></ul><h3 id="web字体" tabindex="-1">web字体 <a class="header-anchor" href="#web字体" aria-label="Permalink to &quot;web字体&quot;">​</a></h3><ul><li>使用font-face来定义web字体的规则，包括字体的样式和下载的链接。iconfont的css文件中就是这样定义的</li><li>使用font-face定义完之后，就可以使用font-family应用到元素标签上。</li><li>因为各大浏览器的竞争，所以导致他们对字体文件的格式支持不统一。woff和woff2的格式是被广泛接受的。</li><li>但是为了兼容早期Ie浏览器和一些手机浏览器，需要在定义font-face的时候，多编写几种样式。(svg eot ttf)</li></ul><p>@font-face { font-family: iconfont; src:url(&#39;xxx&#39;) format(&#39;woff&#39;), url(&#39;yyy&#39;) format(&#39;woff2&#39;), ......; font-weight:bold; }</p><ul><li>需要注意的是，font-face中的font的东西并不是用来规定字体样式的属性，而是字体描述符。</li><li>在使用时，在font-family和font-weight都匹配的情况下才会正确的引用。(不过主流浏览器在font-family匹配的情况下就可以使用)，</li><li>这也就意味着不同的web字体需要根据不同的font-weight和font-style来引入多次(下载多次不同的文件)</li><li>常见的误区就是，在定义font-face时font-weight定义为normal，在使用的时候属性写bold。、、、、、、、</li></ul><h2 id="min-width-max-width" tabindex="-1">min-width max-width <a class="header-anchor" href="#min-width-max-width" aria-label="Permalink to &quot;min-width max-width&quot;">​</a></h2><h3 id="min-width" tabindex="-1">min-width <a class="header-anchor" href="#min-width" aria-label="Permalink to &quot;min-width&quot;">​</a></h3><ol><li>正常情况下，min-width 设置盒子宽度的最小值</li><li>在 fle x布局情况下 <ol><li>子元素总和小于父元素的时候，width 设置盒子的基本宽度，min-width设置盒子的宽度最小值</li><li>子元素总和大于父元素的时候，width 设置的盒子会被压缩，按照比例压缩，min-width 的盒子不会被压缩，最小宽度为 min-width</li></ol></li></ol><h3 id="max-width" tabindex="-1">max-width <a class="header-anchor" href="#max-width" aria-label="Permalink to &quot;max-width&quot;">​</a></h3><ol><li>设置盒子的宽度最大值，width 和 max-width 同时设置的话，在满足宽度不大于 max-width 数值的情况下遵循 width。</li></ol><h3 id="max-height-min-height" tabindex="-1">max-height min-height <a class="header-anchor" href="#max-height-min-height" aria-label="Permalink to &quot;max-height min-height&quot;">​</a></h3><ul><li>在 css 中设置任何高度值的时候，都要慎重，因为元素的高度通常由文本数量决定。</li><li>如果明确的设定高度，最好也是使用 min-height 因为这个属性，允许元素盒子随内容扩展。</li></ul><h2 id="网页的适配调整" tabindex="-1">网页的适配调整 <a class="header-anchor" href="#网页的适配调整" aria-label="Permalink to &quot;网页的适配调整&quot;">​</a></h2><h3 id="viewport-属性定义在-meta-标签中" tabindex="-1">viewport 属性定义在 meta 标签中 <a class="header-anchor" href="#viewport-属性定义在-meta-标签中" aria-label="Permalink to &quot;viewport 属性定义在 meta 标签中&quot;">​</a></h3><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code> (在PC端中不需要定义这条语句，只有在移动端可平板中才需要设置这条语句)</p><ul><li>width=device-width 希望使用当前设备的理想视口作为视口宽度的基准</li><li>initial-scale=1.0&quot; 设置理想视口(就是接近于设备自身大小的视口)的缩放比例级别。</li><li>不要通过设置 meta 来禁止缩放，网页的使用性会变差。</li></ul><h3 id="viewport-属性定义在-css-语句中" tabindex="-1">viewport 属性定义在 CSS 语句中 <a class="header-anchor" href="#viewport-属性定义在-css-语句中" aria-label="Permalink to &quot;viewport 属性定义在 CSS 语句中&quot;">​</a></h3><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">@viewport</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#005CC5;">    width</span><span style="color:#24292E;">: device-width;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>css 也可以做到设备适配，不过一定要把这条属性放到 body 前的 style 标签中</li><li>因为在 css 加载之前必须知道视口大小。</li></ul><h3 id="视口" tabindex="-1">视口 <a class="header-anchor" href="#视口" aria-label="Permalink to &quot;视口&quot;">​</a></h3><ul><li>视口就是浏览器显示网页的矩形区域</li></ul><h4 id="默认视口" tabindex="-1">默认视口 <a class="header-anchor" href="#默认视口" aria-label="Permalink to &quot;默认视口&quot;">​</a></h4><ul><li>在没有针对移动端开发的时代，就是直接把PC的网页，缩小之后放到移动端上使用</li><li>模拟一个窗口的大小，这个大小就叫做默认视口。</li></ul><h4 id="理想视口" tabindex="-1">理想视口 <a class="header-anchor" href="#理想视口" aria-label="Permalink to &quot;理想视口&quot;">​</a></h4><ul><li>就是与设备自身尺寸接近的视口</li></ul><h4 id="可见视口和布局视口" tabindex="-1">可见视口和布局视口 <a class="header-anchor" href="#可见视口和布局视口" aria-label="Permalink to &quot;可见视口和布局视口&quot;">​</a></h4><ul><li>可见视口就是显示出来的实际网页的大小。布局视口是真实的网页的大小。</li><li>PC 端的理想视口就是默认视口。但是移动端和平板中需要设置 meta 元素。</li></ul>`,39)]))}const f=i(o,[["render",n]]);export{u as __pageData,f as default};
