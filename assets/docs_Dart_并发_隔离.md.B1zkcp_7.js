import{_ as e,c as t,o as l,ag as o}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"隔离","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Dart/并发/隔离.md","filePath":"docs/Dart/并发/隔离.md","lastUpdated":1749559081000}'),r={name:"docs/Dart/并发/隔离.md"};function i(d,a,s,c,n,_){return l(),t("div",null,a[0]||(a[0]=[o('<h1 id="隔离" tabindex="-1">隔离 <a class="header-anchor" href="#隔离" aria-label="Permalink to &quot;隔离&quot;">​</a></h1><ul><li>隔离类似于线程或者进程，但每个隔离都有自己的<code>内存</code>和一个<code>运行事件循环的单线程</code></li><li>隔离只能通过<code>消息传递</code>互相通信。隔离之间没有共享状态、也没有互斥锁和数据竞争</li></ul><h2 id="隔离的生命周期" tabindex="-1">隔离的生命周期 <a class="header-anchor" href="#隔离的生命周期" aria-label="Permalink to &quot;隔离的生命周期&quot;">​</a></h2><ul><li>当隔离的初始函数返回，并且处理完事件(如果有)后，隔离退出</li></ul><h2 id="使用隔离" tabindex="-1">使用隔离 <a class="header-anchor" href="#使用隔离" aria-label="Permalink to &quot;使用隔离&quot;">​</a></h2><ul><li>Isolate.run() 在单独的线程上执行单个计算</li><li>Isolate.spawn() 创建一个隔离区，该隔离区将随着时间的推移处理多个消息，或者创建一个后台工作器</li></ul><h2 id="隔离通信" tabindex="-1">隔离通信 <a class="header-anchor" href="#隔离通信" aria-label="Permalink to &quot;隔离通信&quot;">​</a></h2><ul><li>隔离只能通过消息进行通信</li></ul><p>TODO：新建一个隔离，然后进行运算，运算结束后将数据返回给主隔离。这个数据的返回，包括隔离之间消息的通信。是如何进行的？是基于复制还是内存地址传递。</p>',9)]))}const p=e(r,[["render",i]]);export{u as __pageData,p as default};
