import{_ as i,c as t,o as a,ag as e}from"./chunks/framework.BDwTZuFy.js";const c=JSON.parse('{"title":"基础概念","description":"","frontmatter":{},"headers":[],"relativePath":"docs/计算机网络/计算机网络/HTTP协议/HTTP相关的问题.md","filePath":"docs/计算机网络/计算机网络/HTTP协议/HTTP相关的问题.md","lastUpdated":1736933386000}'),r={name:"docs/计算机网络/计算机网络/HTTP协议/HTTP相关的问题.md"};function o(p,l,s,h,d,u){return a(),t("div",null,l[0]||(l[0]=[e('<h1 id="基础概念" tabindex="-1">基础概念 <a class="header-anchor" href="#基础概念" aria-label="Permalink to &quot;基础概念&quot;">​</a></h1><h2 id="url-和-uri" tabindex="-1">URL 和 URI <a class="header-anchor" href="#url-和-uri" aria-label="Permalink to &quot;URL 和 URI&quot;">​</a></h2><h3 id="uri-和-url-的区别" tabindex="-1">URI 和 URL 的区别 <a class="header-anchor" href="#uri-和-url-的区别" aria-label="Permalink to &quot;URI 和 URL 的区别&quot;">​</a></h3><ul><li>URL 是 URI 的子集，URL 是 URI 的一种</li><li>URI 是统一资源标识符，统一资源标识符用于标示一个抽象或者物理资源。是以一种抽象的，高层次概念定义统一资源标识。</li><li>URL 是统一资源定位符，也是能够标识唯一的一个资源，不过是标识资源的地址。通过 URL 能够找到这个资源</li><li>URI 像是身份证号，唯一标识一个人，但是通过身份证号你找不到这个人。URL 像是身份证里面的地址。也唯一标识了你这个人，并且能根据 URL 去找你。</li></ul><h3 id="uri-的格式" tabindex="-1">URI 的格式 <a class="header-anchor" href="#uri-的格式" aria-label="Permalink to &quot;URI 的格式&quot;">​</a></h3><p><code>http://user:pass@www.example.jp:80/dir/index.html?uid=1#ch1</code></p><ul><li>协议 http 不区别大小写</li><li>登录认证 user：pass 可选项</li><li>服务器地址 www.example.jp 可以是域名，也可以是 IPV4 IPV6 必选项</li><li>服务器端口号 80 默认端口号</li><li>带层次的文件路径 /dir/index.html</li><li>查询字符串 ?uid=1 可选</li><li>片段标识符 ch1 可选</li></ul><h2 id="get-和-post-的区别" tabindex="-1">get 和 post 的区别 <a class="header-anchor" href="#get-和-post-的区别" aria-label="Permalink to &quot;get 和 post 的区别&quot;">​</a></h2><ul><li>谈到 get 和 post 的区别时，一定要从两个方面。一是浏览器的 http 协议方面。二是经过了一些库的封装。</li></ul><h3 id="get" tabindex="-1">get <a class="header-anchor" href="#get" aria-label="Permalink to &quot;get&quot;">​</a></h3><ul><li><p>读取一个资源。比如 Get 到一个 html 文件。反复读取不应该对访问的数据有副作用。比如 GET 一下，用户就下单了，返回订单已受理，这是不可接受的。没有副作用被称为幂等。因为 GET 因为是读取，就可以对 GET 请求的数据做缓存。这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如 nginx），或者做到 server 端</p></li><li><p>可以被收藏为收藏夹</p></li><li><p>能被缓存</p></li><li><p>参数保留在浏览器历史中</p></li><li><p>对 URL 的长度有限制</p></li><li><p>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</p></li><li><p>数据在 URL 中对所有人都是可见的。</p></li></ul><h3 id="post" tabindex="-1">post <a class="header-anchor" href="#post" aria-label="Permalink to &quot;post&quot;">​</a></h3><ul><li><p>在页面里 form 标签会定义一个表单。点击其中的 submit 元素会发出一个 POST 请求让服务器做一件事。这件事往往是有副作用的，不幂等的。不幂等也就意味着不能随意多次执行。因此也就不能缓存。比如通过 POST 下一个单，服务器创建了新的订单，然后返回订单成功的界面。这个页面不能被缓存。试想一下，如果 POST 请求的结果被浏览器缓存了，那么下单请求就可以不向服务器发请求，而直接返回本地缓存的下单成功界面，却又没有真的在服务器下单。那是一件多么滑稽的事情。因为 POST 可能有副作用，所以浏览器实现为不能把 POST 请求保存为书签。想想，如果点一下书签就下一个单，是不是很恐怖？。此外如果尝试重新执行 POST 请求，浏览器也会弹一个框提示下这个刷新可能会有副作用，询问要不要继续。post 的幂等问题也需要根据实际情况来定制。</p></li><li><p>不能被收藏为收藏夹</p></li><li><p>不能缓存</p></li><li><p>参数不会保留在浏览器历史中</p></li><li><p>URL 长度没有限制</p></li><li><p>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中</p></li><li><p>数据不会显示在 URL 中</p></li></ul><h3 id="对比讲解" tabindex="-1">对比讲解 <a class="header-anchor" href="#对比讲解" aria-label="Permalink to &quot;对比讲解&quot;">​</a></h3><ul><li>本质上 get 和 post 的底层都是使用 tcp 传输的。get 和 post 本质上没有区别，只是报文格式不同。</li><li>在服务器支持的情况下，get 和 post 的格式可以混着来。但是在原生的 http 协议中 GEt 请求没有 body，只有 url，请求数据放在 url 中，post 的请求数据放在 body 中。</li><li>其实 post 和 get 都是不安全的，因为 http 是明文传输。想要安全就必须要使用 https</li><li>get 的长度限制问题不是 http 协议的内容，大多都是服务器和及客户端添加的限制，避免恶意输入长 URL 来攻击，占用性能。</li><li>http 协议中并没有说明，post 时 header 和 body 分开发送，产生两个 tcp，应该是框架的请求方式。并不是 post 的必然行为。</li></ul>',15)]))}const T=i(r,[["render",o]]);export{c as __pageData,T as default};
