import{_ as a,c as n,o as e,ag as l}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"函数作用域(词法环境)","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/函数&作用域/函数作用域.md","filePath":"docs/JavaScript/函数&作用域/函数作用域.md","lastUpdated":1735478813000}'),t={name:"docs/JavaScript/函数&作用域/函数作用域.md"};function o(p,s,r,c,i,d){return e(),n("div",null,s[0]||(s[0]=[l(`<h1 id="函数作用域-词法环境" tabindex="-1">函数作用域(词法环境) <a class="header-anchor" href="#函数作用域-词法环境" aria-label="Permalink to &quot;函数作用域(词法环境)&quot;">​</a></h1><h2 id="一、作用域" tabindex="-1">一、作用域 <a class="header-anchor" href="#一、作用域" aria-label="Permalink to &quot;一、作用域&quot;">​</a></h2><ul><li>作用域：全局作用域、局部作用域(也称函数作用域、词法作用域)、块级作用域</li><li>作用域链([[scope]]属性仅供 JS 引擎读取): 代码执行流每进入一个新的上下文，都会创建一个作用域链，其中存储了<code>执行上下文</code>的集合。</li><li>作用域链: 本质上是一个指向 <code>执行上下文</code> 的 <code>指针列表</code> ，它只包含 <code>执行上下文的引用</code>。</li></ul><h2 id="二、执行上下文-简称上下文" tabindex="-1">二、执行上下文(简称上下文) <a class="header-anchor" href="#二、执行上下文-简称上下文" aria-label="Permalink to &quot;二、执行上下文(简称上下文)&quot;">​</a></h2><h3 id="_2-1-执行上下文定义" tabindex="-1">2.1 执行上下文定义 <a class="header-anchor" href="#_2-1-执行上下文定义" aria-label="Permalink to &quot;2.1 执行上下文定义&quot;">​</a></h3><ul><li>上下文分类：全局上下文、函数上下文、块级上下文</li><li>变量或者函数的上下文决定了它们能访问哪些数据，每个上下文中都有一个关联的 <code>变量对象</code>，变量对象中是它们能够访问到的所有变量和函数</li></ul><h3 id="_2-2-以函数上下文为例来分析" tabindex="-1">2.2 以函数上下文为例来分析 <a class="header-anchor" href="#_2-2-以函数上下文为例来分析" aria-label="Permalink to &quot;2.2 以函数上下文为例来分析&quot;">​</a></h3><h3 id="_1-函数被定义时" tabindex="-1">(1) 函数被定义时 <a class="header-anchor" href="#_1-函数被定义时" aria-label="Permalink to &quot;(1) 函数被定义时&quot;">​</a></h3><ol><li>函数被定义时的作用域链中，有所处位置(代码书写层级)的执行上下文</li><li>定义在父函数中的子函数，能通过<code>作用域链的形式</code>来访问父函数的执行上下文。父子函数访问的执行上下文引用地址一致，也就是数据公用，可以一起更改数据。(闭包产生的基础)</li></ol><h2 id="_2-函数被执行时" tabindex="-1">(2) 函数被执行时 <a class="header-anchor" href="#_2-函数被执行时" aria-label="Permalink to &quot;(2) 函数被执行时&quot;">​</a></h2><ul><li>执行上下文: 当函数<code>执行</code>时，会创建一个称为执行上下文的对象(预编译产生)。当函数执行完毕时, 函数自己创建的执行上下文被销毁，但是函数的作用域链中仍保留所处位置的执行上下文</li><li>函数每次执行时对应的执行期上下文都是<code>独一无二</code>的，所以多次调用同一个函数会创建多个执行期上下文(这就是为什么函数多次调用时，前一次调用对函数内部值的修改，不会影响下一次函数的执行)</li></ul><h3 id="_2-3-执行上下文的代码示例" tabindex="-1">2.3 执行上下文的代码示例 <a class="header-anchor" href="#_2-3-执行上下文的代码示例" aria-label="Permalink to &quot;2.3 执行上下文的代码示例&quot;">​</a></h3><div class="language-JS line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">JS</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> son</span><span style="color:#24292E;"> () {}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>GO{} 是全局上下文，SO 是 son 函数上下文，FO 是 father 函数上下文</li></ul><table tabindex="0"><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">作用域链</th></tr></thead><tbody><tr><td style="text-align:center;">son 函数被定义时</td><td style="text-align:center;">[[scope]] --&gt; [GO{}]</td></tr><tr><td style="text-align:center;">son 函数被执行时</td><td style="text-align:center;">[[scope]] --&gt; [GO{}, SO{}]</td></tr></tbody></table><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> father</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  function</span><span style="color:#6F42C1;"> son</span><span style="color:#24292E;">() {}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><table tabindex="0"><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">作用域链</th></tr></thead><tbody><tr><td style="text-align:center;">father 函数被定义时</td><td style="text-align:center;">[[scope]] --&gt; [GO{}]</td></tr><tr><td style="text-align:center;">son 函数被定义时</td><td style="text-align:center;">[[scope]] --&gt; [GO{}, FO{}]</td></tr><tr><td style="text-align:center;">father 函数被执行时</td><td style="text-align:center;">[[scope]] --&gt; [GO{}, FO{}]</td></tr><tr><td style="text-align:center;">son 函数被执行时</td><td style="text-align:center;">[[scope]] --&gt; [GO{}, FO{}, SO{}]</td></tr></tbody></table><ol><li>son 执行时，作用域链中的 <code>FO{}</code>。就是 father 函数被定义时，作用域链中的 <code>FO{}</code></li><li>son 函数执行完毕后，会将 <code>SO{}</code> 销毁，下次再调用时重新创建新的 <code>SO{}</code></li></ol><blockquote><p>理解以上两点，是搞懂 (1.闭包如何产生、2.函数每次调用，不受上一次函数调用时值的修改的影响) 这两个问题的关键</p></blockquote><h2 id="三、延长作用域链" tabindex="-1">三、延长作用域链 <a class="header-anchor" href="#三、延长作用域链" aria-label="Permalink to &quot;三、延长作用域链&quot;">​</a></h2><ol><li>with() 把指定的对象添加到作用域链的前端。<code>!不推荐使用</code></li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> temp</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  name: </span><span style="color:#032F62;">&quot;bar&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> test</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> name </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &quot;foo&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">  with</span><span style="color:#24292E;"> (temp) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(name); </span><span style="color:#6A737D;">// bar</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ol start="2"><li>catch 语句，会把要抛出的错误对象添加到作用域链的前端</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> userInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {};</span></span>
<span class="line"><span style="color:#D73A49;">  let</span><span style="color:#24292E;"> length </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> userInfo.name.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (error) {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;err:&quot;</span><span style="color:#24292E;">, error.message);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div>`,24)]))}const h=a(t,[["render",o]]);export{u as __pageData,h as default};
