import{_ as l,c as e,o as i,ag as t}from"./chunks/framework.BDwTZuFy.js";const f=JSON.parse('{"title":"事件","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/事件/事件.md","filePath":"docs/JavaScript/事件/事件.md","lastUpdated":1712646874000}'),r={name:"docs/JavaScript/事件/事件.md"};function o(n,a,h,u,s,c){return i(),e("div",null,a[0]||(a[0]=[t('<h1 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h1><h2 id="事件流" tabindex="-1">事件流 <a class="header-anchor" href="#事件流" aria-label="Permalink to &quot;事件流&quot;">​</a></h2><h3 id="事件流的过程" tabindex="-1">事件流的过程 <a class="header-anchor" href="#事件流的过程" aria-label="Permalink to &quot;事件流的过程&quot;">​</a></h3><ul><li>个人理解 一个事件会触发一个事件流，事件流的过程需要访问好多的元素，执行涉及到的元素身上对应事件(比如是一个 click 事件的事件流那么事件过程中执行的就是 click 的事件处理函数)的事件处理函数。</li><li>先是从最大的范围进行捕获，为截获事件提供了机会，然后是处于<strong>目标阶段</strong>，然后是事件冒泡对事件进行响应。</li><li>在层级嵌套的 DOM 结构中， 一次点击事件(事件流), 会从顶部元素捕获到<strong>目标元素</strong>，等到达目标元素之后转化为冒泡阶段，从目标元素冒泡到顶部元素。</li></ul><h3 id="冒泡和捕获" tabindex="-1">冒泡和捕获 <a class="header-anchor" href="#冒泡和捕获" aria-label="Permalink to &quot;冒泡和捕获&quot;">​</a></h3><h4 id="事件冒泡" tabindex="-1">事件冒泡 <a class="header-anchor" href="#事件冒泡" aria-label="Permalink to &quot;事件冒泡&quot;">​</a></h4><ul><li>结构上(非视觉上)嵌套关系的元素，会存在事件冒泡功能，即同一个事件，自子元素冒泡向父元素。(自底向上)</li></ul><h4 id="事件捕获" tabindex="-1">事件捕获 <a class="header-anchor" href="#事件捕获" aria-label="Permalink to &quot;事件捕获&quot;">​</a></h4><ul><li><p>结构上(非视觉上)嵌套的元素，会存在事件捕获的功能，即同一个事件，自父元素，捕获至子元素(事件源元素)(自顶向下)</p></li><li><p>一个对象的一个事件类型(的某一个函数)只能选择一种事件模型（冒泡或者捕获）</p></li><li><p>触发顺序：先捕获后冒泡。但是被点击的元素执行时，不是冒泡也不是捕获。他就是自己的事件执行。如果同时具有冒泡和捕获。按照绑定的顺序来执行。</p></li><li><p>focus,blur,change,submit,reset,select 等事件没有冒泡</p></li></ul><h4 id="取消冒泡和捕获" tabindex="-1">取消冒泡和捕获 <a class="header-anchor" href="#取消冒泡和捕获" aria-label="Permalink to &quot;取消冒泡和捕获&quot;">​</a></h4><ul><li>事件对象上的取消冒泡方法 e.stopPropagation()</li><li>取消冒泡 类似于在该元素的上面设置一层屏障， father 设置了取消冒泡的话，事件能冒泡到 father，但是 father 上面的 DOM 都冒泡不到了。要是点击的目标是 father 的父级元素，不会受到 father 的取消冒泡的影响。屏障设置在我的下面，关我父辈什么事情。</li></ul><h2 id="性能的优化" tabindex="-1">性能的优化 <a class="header-anchor" href="#性能的优化" aria-label="Permalink to &quot;性能的优化&quot;">​</a></h2><h3 id="事件委托" tabindex="-1">事件委托 <a class="header-anchor" href="#事件委托" aria-label="Permalink to &quot;事件委托&quot;">​</a></h3><ul><li>例如一个列表中，不给每一个 li 单独添加事件，而是直接给 ul 一个事件，根据 event 的 target 的属性来确定目标元素是谁，配合着事件的冒泡。(个人理解 元素的事件一直都有，只不过事件有没有对应的执行函数，决定这触发事件后有没有表现，比如事件委托中，li 元素并没有定义事件处理函数，但是它依旧可以被点击，并且以 li 为目标节点触发事件流，并且在冒泡的过程中，触发了 ul 上定义的事件)</li><li>减少事件处理程序的定义</li></ul><h3 id="移出事件处理程序" tabindex="-1">移出事件处理程序 <a class="header-anchor" href="#移出事件处理程序" aria-label="Permalink to &quot;移出事件处理程序&quot;">​</a></h3><ul><li>使用 innerHtml 替换和删除元素时极有可能不会删除元素中带有的事件处理程序。</li><li>使用 removeChild(),replaceChild()这种纯粹的 DOM 方法应该会删除带有的事件处理程序吧？</li><li>最好是在页面被卸载之前移出所有的事件处理程序。使用 unload 事件。</li></ul><h2 id="事件-事件处理程序" tabindex="-1">事件，事件处理程序 <a class="header-anchor" href="#事件-事件处理程序" aria-label="Permalink to &quot;事件，事件处理程序&quot;">​</a></h2><ul><li>事件是指用户或者浏览器的动作比如 click，load</li><li>响应某个事件的函数就叫做事件处理程序(事件侦听器) click 事件的事件处理程序就是 onclick</li></ul><h2 id="书写" tabindex="-1">书写 <a class="header-anchor" href="#书写" aria-label="Permalink to &quot;书写&quot;">​</a></h2><ul><li>event = &quot;javascript statement(s)&quot;</li><li>js 的代码包含在一对引号当中。可以添加任意数量的 js 语句，只需要使用分号隔开。 onClick = &quot;test();return false;&quot;</li></ul><h2 id="事件处理程序的机制" tabindex="-1">事件处理程序的机制 <a class="header-anchor" href="#事件处理程序的机制" aria-label="Permalink to &quot;事件处理程序的机制&quot;">​</a></h2><ul><li>一个元素的事件被触发时，就会执行相应的代码。这些代码可以返回值。如果返回 true，认为事件被完成了，如果返回 false，那么认为事件没有被完成。onClick = &quot;test();return false;&quot;通过这种形式可以用来阻止事件的默认行为。</li></ul><h3 id="阻止事件默认行为" tabindex="-1">阻止事件默认行为 <a class="header-anchor" href="#阻止事件默认行为" aria-label="Permalink to &quot;阻止事件默认行为&quot;">​</a></h3><ul><li>return false; 只有以句柄的方式定义才能取消</li><li>event.preventDefault() w3c 标准，IE9 以下不兼容</li><li>event.returnValue = false; 兼容 IE</li><li>取消 a 标签的默认事件，执行空的 js 代码 <code>&lt;a href=&quot;javascript:void(0)&quot;&gt;demo&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;demo&lt;/a&gt;</code></li></ul><h2 id="页面加载完毕之后的事件" tabindex="-1">页面加载完毕之后的事件 <a class="header-anchor" href="#页面加载完毕之后的事件" aria-label="Permalink to &quot;页面加载完毕之后的事件&quot;">​</a></h2><ul><li>window.onload 只能添加一个函数，后添加的函数会覆盖前面添加的函数</li></ul><h2 id="事件处理函数的绑定" tabindex="-1">事件处理函数的绑定 <a class="header-anchor" href="#事件处理函数的绑定" aria-label="Permalink to &quot;事件处理函数的绑定&quot;">​</a></h2><ul><li>onclick 是句柄事件(DOM0 级方法)。 只能每个事件绑定一个函数。</li><li>Element.addEventListener(DOM2 级方法)(&quot;事件类型 --&gt; click&quot;，处理函数，false)能给一个事件触发多个处理函数。一起触发，按照绑定顺序执行。传入 true 的时候在捕获阶段调用事件处理程序，传入 false 的时候在冒泡阶段调用事件处理程序。大多数情况下我们都是将事件处理程序添加到事件的冒泡阶段</li><li>用 for 循环绑定事件，容易出现闭包问题</li></ul><h2 id="解除事件函数" tabindex="-1">解除事件函数 <a class="header-anchor" href="#解除事件函数" aria-label="Permalink to &quot;解除事件函数&quot;">​</a></h2><ul><li>ele.onclick = null/false;</li><li>ele.removeEventListener(type,function,false) function 内使用另一个函数引用。不然清除的时候找不到。</li></ul>',30)]))}const q=l(r,[["render",o]]);export{f as __pageData,q as default};
