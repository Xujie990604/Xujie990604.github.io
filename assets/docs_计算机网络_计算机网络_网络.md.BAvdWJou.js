import{_ as l,c as i,o as e,ag as t}from"./chunks/framework.BDwTZuFy.js";const c=JSON.parse('{"title":"网络资料","description":"","frontmatter":{},"headers":[],"relativePath":"docs/计算机网络/计算机网络/网络.md","filePath":"docs/计算机网络/计算机网络/网络.md","lastUpdated":1712646874000}'),o={name:"docs/计算机网络/计算机网络/网络.md"};function r(n,a,A,h,P,d){return e(),i("div",null,a[0]||(a[0]=[t('<h1 id="网络资料" tabindex="-1">网络资料 <a class="header-anchor" href="#网络资料" aria-label="Permalink to &quot;网络资料&quot;">​</a></h1><h2 id="转发的基础知识" tabindex="-1">转发的基础知识 <a class="header-anchor" href="#转发的基础知识" aria-label="Permalink to &quot;转发的基础知识&quot;">​</a></h2><h3 id="二层转发-常见的二层转发设备-网桥" tabindex="-1">二层转发(常见的二层转发设备：网桥) <a class="header-anchor" href="#二层转发-常见的二层转发设备-网桥" aria-label="Permalink to &quot;二层转发(常见的二层转发设备：网桥)&quot;">​</a></h3><ol><li>二层转发，物理层，链路层。</li><li>通过MAC地址转发，广播域是所有的端口</li><li>根据接收到的数据帧的目的MAC地址，把报文从相应的端口转发出去</li><li>为了限制广播范围。进行VLAN划分。</li></ol><h4 id="二层转发的一般流程" tabindex="-1">二层转发的一般流程 <a class="header-anchor" href="#二层转发的一般流程" aria-label="Permalink to &quot;二层转发的一般流程&quot;">​</a></h4><ol><li>读取MAC地址(学到MAC表中)</li><li>读取目的MAC地址，然后查MAC表转发(源目的MAC同一端口则丢弃)</li><li>如果MAC表无此表项，则广播（？？？每个二层转发的设备都要保留所有设备的MAC地址吗）</li><li>等目的主机回应后，将目的主机MAC（即回应报文的源MAC）学到MAC表中(后续数据不再广播)</li></ol><h4 id="vlav" tabindex="-1">VLAV <a class="header-anchor" href="#vlav" aria-label="Permalink to &quot;VLAV&quot;">​</a></h4><ul><li>为了限制广播域的大小，对网络进行了划分(每个网络都是一个VLAN)，只在当前VLAN中广播</li><li>缺点是不同的VLAN无法二层通信</li></ul><h3 id="三层转发-常见的三层转发设备-路由器" tabindex="-1">三层转发(常见的三层转发设备： 路由器) <a class="header-anchor" href="#三层转发-常见的三层转发设备-路由器" aria-label="Permalink to &quot;三层转发(常见的三层转发设备： 路由器)&quot;">​</a></h3><ol><li>三层转发，物理层，链路层，网络层</li><li>转发方式： 按照IP地址寻找路由，转发数据</li><li>有效隔离广播域。一个端口就是一个广播域</li></ol><h4 id="a-ping-b" tabindex="-1">A ping B <a class="header-anchor" href="#a-ping-b" aria-label="Permalink to &quot;A ping B&quot;">​</a></h4><ol><li>A检查报文的目的IP地址（B），发现不再同一个网段 (如果在同一个网段的话就是二层转发了)</li><li>A查找ARP地址表获得网关（R）的MAC地址。(网关就是一个网络连接另一个网络的设备)</li><li>A向路由器R发送报文(1.目的MAC： 路由器连接A的口的MAC 2.源MAC：A的MAC 3. 目的ip是B，源IP是A)</li><li>路由器R收到之后，进行IP转发处理，获取下一跳到B的IP地址</li><li>R查找ARP获得B的MAC地址</li><li>R向B转发A的请求报文（1.目的MAC： 下一跳B的MAC 2.源MAC： R连接B的口的MAC 3.目的IP是B，源IP是A）</li></ol><h2 id="tcp-ip协议" tabindex="-1">TCP/IP协议 <a class="header-anchor" href="#tcp-ip协议" aria-label="Permalink to &quot;TCP/IP协议&quot;">​</a></h2><ul><li>MAC地址： 物理地址，二层地址</li><li>IP地址： 逻辑地址，三层地址</li><li>ARP协议（属于数据链路层的协议）： 地址解析协议 IP -- &gt; MAC</li><li>RARP协议（属于数据链路层的协议）： 地址解析协议 MAC -- &gt; IP</li><li>ping程序：是对两个TCP/IP系统连通性进行测试的基本工具</li></ul><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><ul><li>公网IP： 例如百度的IP地址就是一个公网IP。公网IP可以被直接访问。</li><li>私网IP： 因为公网IP不够用，所以好多设备共有一个公网IP，由路由器进行私网IP的分配。私网IP不能被(不是同一个网段)的设备直接访问。(我们平时使用的PC不能直接被当做服务器使用就是因为家用PC没有自己的公网IP)</li></ul>',16)]))}const C=l(o,[["render",r]]);export{c as __pageData,C as default};
