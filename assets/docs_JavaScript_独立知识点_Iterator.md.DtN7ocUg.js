import{_ as n,c as a,o as l,ag as p}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"Iterator(迭代器)","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/独立知识点/Iterator.md","filePath":"docs/JavaScript/独立知识点/Iterator.md","lastUpdated":1712646874000}'),e={name:"docs/JavaScript/独立知识点/Iterator.md"};function o(r,s,c,t,i,y){return l(),a("div",null,s[0]||(s[0]=[p(`<h1 id="iterator-迭代器" tabindex="-1">Iterator(迭代器) <a class="header-anchor" href="#iterator-迭代器" aria-label="Permalink to &quot;Iterator(迭代器)&quot;">​</a></h1><blockquote><p>循环是迭代的基础，每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的</p></blockquote><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#005CC5;"> 10</span><span style="color:#24292E;">; </span><span style="color:#D73A49;">++</span><span style="color:#24292E;">i) {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="一、介绍" tabindex="-1">一、介绍 <a class="header-anchor" href="#一、介绍" aria-label="Permalink to &quot;一、介绍&quot;">​</a></h2><ol><li>通用性：是为各种数据结构，提供一个统一的、简便的访问接口</li><li>有序性：是使得数据结构的成员能够按某种次序排列</li><li>ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 一个对象如果要具备可被 for...of 循环调用的 Iterator 接口，就必须在 Symbol.iterator 的属性上部署遍历器生成方法(原型链上的对象具有该方法也可)</span></span>
<span class="line"><span style="color:#6A737D;">// 遍历器属性是一个方法</span></span>
<span class="line"><span style="color:#6A737D;">// 执行这个方法会返回一个对象，对象里面包含 next 方法</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> obj</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  [Symbol.iterator]: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6F42C1;">      next</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#D73A49;">        return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">          value: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">          done: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">        };</span></span>
<span class="line"><span style="color:#24292E;">      },</span></span>
<span class="line"><span style="color:#24292E;">    };</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="二、iterator-接口" tabindex="-1">二、Iterator 接口 <a class="header-anchor" href="#二、iterator-接口" aria-label="Permalink to &quot;二、Iterator 接口&quot;">​</a></h2><ul><li>原生具备 Iterator 接口的数据结构如下(<code>!没有 Object</code>)</li></ul><ol><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性</span></span>
<span class="line"><span style="color:#6A737D;">// 可迭代对象</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> arr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#6A737D;">// 迭代器工厂函数</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> iter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> arr[Symbol.iterator];</span></span>
<span class="line"><span style="color:#6A737D;">// 迭代器</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> iter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> arr[Symbol.iterator]();</span></span>
<span class="line"><span style="color:#6A737D;">// 执行迭代</span></span>
<span class="line"><span style="color:#24292E;">iter.</span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">//{value: 1, done: false}</span></span>
<span class="line"><span style="color:#24292E;">iter.</span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">//{value: 2, done: false}</span></span>
<span class="line"><span style="color:#24292E;">iter.</span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">//{value: 3, done: false}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="三、调用-iterator-的场合" tabindex="-1">三、调用 Iterator 的场合 <a class="header-anchor" href="#三、调用-iterator-的场合" aria-label="Permalink to &quot;三、调用 Iterator 的场合&quot;">​</a></h2><ol><li>解构赋值</li><li>使用 ... 扩展运算符</li><li><code>yield*</code></li><li>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口(例如: <code>for...of</code> <code>Array.from()</code> <code>Map()</code> <code>Set()</code> <code>Promise.all()</code> <code>Promise.race()</code>)</li></ol><h2 id="四、几种遍历方法的对比" tabindex="-1">四、几种遍历方法的对比 <a class="header-anchor" href="#四、几种遍历方法的对比" aria-label="Permalink to &quot;四、几种遍历方法的对比&quot;">​</a></h2><p>TODO：总结几种遍历方式的异同点，以及 forEach 不能使用 break 的解决方案 TODO： for-of 解决了 for-in 的哪些缺点？原型？顺序？</p><h3 id="_4-1-for-循环" tabindex="-1">4.1 for 循环 <a class="header-anchor" href="#_4-1-for-循环" aria-label="Permalink to &quot;4.1 for 循环&quot;">​</a></h3><ul><li>最原始的遍历方式，写起来比较麻烦(1. 需要单独记录索引 2. 需要使用特定语法([] 或 get())读值)</li><li>迭代中止: 可以使用 continue break 来终止循环</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> arr</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> 0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> arr.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">  if</span><span style="color:#24292E;"> (arr[i] </span><span style="color:#D73A49;">==</span><span style="color:#005CC5;"> 4</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">    break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(arr[i]); </span><span style="color:#6A737D;">// 1 2 3</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_4-2-foreach" tabindex="-1">4.2 forEach <a class="header-anchor" href="#_4-2-foreach" aria-label="Permalink to &quot;4.2 forEach&quot;">​</a></h3><ul><li>与 for 对比，略有改善(1.不需要单独记录索引 2. 不需要使用特定语法([] 或 get())读值)</li><li>通用性受限：只能用于数组的数据类型</li><li>迭代中止受限：无法使用 continue break 来终止循环</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> arr</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">arr.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">((</span><span style="color:#E36209;">item</span><span style="color:#24292E;">, </span><span style="color:#E36209;">index</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(item); </span><span style="color:#6A737D;">// 1 2 3 4 5</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_4-3-for-in" tabindex="-1">4.3 for in <a class="header-anchor" href="#_4-3-for-in" aria-label="Permalink to &quot;4.3 for in&quot;">​</a></h3><ul><li>如果是数组和字符串的话，只能得到下标值，并不实用。只适合遍历对象</li><li>在遍历数组的过程中会访问到原型链上的数据</li><li>无序性: 对象的 key 是无序的，所以 for...in 遍历对象时并不能保证输出的顺序</li><li>迭代中止： 可以使用 break continue 来中止循环</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 输出原型上的数据</span></span>
<span class="line"><span style="color:#6A737D;">// 遍历数组时，得到的是下标值</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> arr</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> [</span><span style="color:#032F62;">&quot;a&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;b&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;c&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;d&quot;</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">arr.</span><span style="color:#005CC5;">__proto__</span><span style="color:#24292E;">.sss </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &quot;sss&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> key</span><span style="color:#D73A49;"> in</span><span style="color:#24292E;"> arr) {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(key); </span><span style="color:#6A737D;">// 0 1 2 3 sss</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 遍历对象时，为了避免原型上数据的干扰，一般都搭配 hasOwnProperty 使用</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> obj</span><span style="color:#D73A49;"> =</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  name: </span><span style="color:#032F62;">&quot;foo&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  age: </span><span style="color:#005CC5;">18</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  sex: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#24292E;">obj.</span><span style="color:#005CC5;">__proto__</span><span style="color:#24292E;">.sss </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &quot;sss&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">const</span><span style="color:#005CC5;"> key</span><span style="color:#D73A49;"> in</span><span style="color:#24292E;"> obj) {</span></span>
<span class="line"><span style="color:#D73A49;">  if</span><span style="color:#24292E;"> (Object.hasOwnProperty.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(obj, key)) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(key); </span><span style="color:#6A737D;">// name age sex</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="_4-4-for-of" tabindex="-1">4.4 for of <a class="header-anchor" href="#_4-4-for-of" aria-label="Permalink to &quot;4.4 for of&quot;">​</a></h3><ul><li>通用性: 任何实现了 Iterator 的数据结构都能使用此方法进行遍历</li><li>语法简洁: 1.不需要单独记录索引 2. 不需要使用特定语法([] 或 get())读值</li><li>迭代中止: 可以使用 break continue 来中止循环</li><li>有序性: 迭代元素的顺序是确定的</li><li>不会像 for...in 一样，访问原型上的数据</li></ul>`,25)]))}const d=n(e,[["render",o]]);export{u as __pageData,d as default};
