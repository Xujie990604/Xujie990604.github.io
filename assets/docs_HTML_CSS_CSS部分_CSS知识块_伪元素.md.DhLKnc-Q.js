import{_ as a,c as e,o as i,ag as t}from"./chunks/framework.BDwTZuFy.js";const f=JSON.parse('{"title":"伪元素","description":"","frontmatter":{},"headers":[],"relativePath":"docs/HTML+CSS/CSS部分/CSS知识块/伪元素.md","filePath":"docs/HTML+CSS/CSS部分/CSS知识块/伪元素.md","lastUpdated":1724407856000}'),o={name:"docs/HTML+CSS/CSS部分/CSS知识块/伪元素.md"};function r(s,l,c,n,d,S){return i(),e("div",null,l[0]||(l[0]=[t('<h1 id="伪元素" tabindex="-1">伪元素 <a class="header-anchor" href="#伪元素" aria-label="Permalink to &quot;伪元素&quot;">​</a></h1><ul><li>css 的伪元素，之所以被称为伪元素，是因为他们不是真正的页面元素，html 没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的 css 样式，表面上看上去貌似是页面的某些元素来展现，实际上是 css 样式展现的行为，因此被称为伪元素</li><li>p::after 伪元素使用定位时它的直接父元素就是这个 p 元素</li><li>伪元素 ::before 和 ::after 添加的内容默认是 inline 元素</li><li>::before 和 ::after 时必须设置其 content 属性，否则伪元素就不起作用</li><li>伪元素是通过样式来达到元素效果的，也就是说伪元素不占用 dom 元素节点。</li></ul><h2 id="伪元素的特点" tabindex="-1">伪元素的特点 <a class="header-anchor" href="#伪元素的特点" aria-label="Permalink to &quot;伪元素的特点&quot;">​</a></h2><ol><li>伪元素不属于文档，所以 js 无法操作它</li><li>伪元素属于主元素的一部分，因此点击伪元素触发的是主元素的 click 事件</li><li>原文说块级元素才能有 ::before, ::after，其实是不妥的，大部分行级元素也可以设置伪元素，但是像 img 可替换元素，因为其外观和尺寸由外部资源决定，那么如果外部资源正确加载，就会替换掉其内部内容，这时伪元素也会被替换掉，但是当外部资源加载失败时，设置的伪元素是可以起作用的。</li></ol><h2 id="基于伪元素的特点可以知道其优缺点" tabindex="-1">基于伪元素的特点可以知道其优缺点 <a class="header-anchor" href="#基于伪元素的特点可以知道其优缺点" aria-label="Permalink to &quot;基于伪元素的特点可以知道其优缺点&quot;">​</a></h2><ul><li>优点</li></ul><ol><li>减少 dom 节点数</li><li>让 css 帮助解决部分 js 问题，让问题变得简单</li></ol><ul><li>缺点</li></ul><ol><li>不利于 SEO</li><li>无法审查元素，不利于调试</li></ol>',9)]))}const h=a(o,[["render",r]]);export{f as __pageData,h as default};
