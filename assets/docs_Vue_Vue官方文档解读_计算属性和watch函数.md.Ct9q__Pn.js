import{_ as s,c as n,o as e,ag as l}from"./chunks/framework.BDwTZuFy.js";const h=JSON.parse('{"title":"计算属性 && watch","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Vue/Vue官方文档解读/计算属性和watch函数.md","filePath":"docs/Vue/Vue官方文档解读/计算属性和watch函数.md","lastUpdated":1734874907000}'),p={name:"docs/Vue/Vue官方文档解读/计算属性和watch函数.md"};function c(o,a,t,r,i,d){return e(),n("div",null,a[0]||(a[0]=[l(`<h1 id="计算属性-watch" tabindex="-1">计算属性 &amp;&amp; watch <a class="header-anchor" href="#计算属性-watch" aria-label="Permalink to &quot;计算属性 &amp;&amp; watch&quot;">​</a></h1><h2 id="一、computed" tabindex="-1">一、computed <a class="header-anchor" href="#一、computed" aria-label="Permalink to &quot;一、computed&quot;">​</a></h2><ul><li><code>减少</code>模板中<code>表达式的使用</code></li><li>当计算属性在模板中使用，并且计算属性的<code>依赖值发生改变</code>的时候就会<code>触发它的更改</code>。如果不发生变化，使用的就是<code>缓存</code>的属性值</li><li>computed 中使用 <code>dirty</code> 来标识是否需要重新计算，computed 中使用 value 变量<code>缓存</code>上一次计算结果的值，如果连续调用同一个计算属性会返回缓存的值</li><li>计算属性中的 getter 函数要求是<code>没有副作用</code>的</li></ul><h3 id="_1-1-计算属性-vs-方法" tabindex="-1">1.1 计算属性 VS 方法 <a class="header-anchor" href="#_1-1-计算属性-vs-方法" aria-label="Permalink to &quot;1.1 计算属性 VS 方法&quot;">​</a></h3><ul><li>计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。</li><li>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</li></ul><h2 id="二、watch-侦听器" tabindex="-1">二、watch 侦听器 <a class="header-anchor" href="#二、watch-侦听器" aria-label="Permalink to &quot;二、watch 侦听器&quot;">​</a></h2><ul><li>适合在调试的时候使用</li><li>watch 是在属性有改变的时候调用对应的方法</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 想要监听一个对象的深层变化时，需要加上 deep 关键字</span></span>
<span class="line"><span style="color:#6F42C1;">watch</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#6A737D;">  // 监听的变量只接受以 . 为分隔的路径(obj.person.name)</span></span>
<span class="line"><span style="color:#6F42C1;">  combo</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#6F42C1;">    handler</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#D73A49;">      ......</span></span>
<span class="line"><span style="color:#24292E;">    },</span></span>
<span class="line"><span style="color:#6A737D;">    // 想要监听对象内部值的变化，需要指定 deep 为 true(值得注意的是，监听数组的变化不需要这样做)</span></span>
<span class="line"><span style="color:#6F42C1;">    deep</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_1-2-侦听器vs计算属性" tabindex="-1">1.2 侦听器VS计算属性 <a class="header-anchor" href="#_1-2-侦听器vs计算属性" aria-label="Permalink to &quot;1.2 侦听器VS计算属性&quot;">​</a></h3><ul><li>计算属性是依赖的属性发生变化时，计算属性跟着变化，并且主要得到的是一个属性。</li><li>侦听器不是为了得到一个属性，而是期望在某些属性变化的时候能触发一些函数或者语句</li></ul>`,10)]))}const b=s(p,[["render",c]]);export{h as __pageData,b as default};
