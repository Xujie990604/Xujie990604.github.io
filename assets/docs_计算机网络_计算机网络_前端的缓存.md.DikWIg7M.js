import{_ as i,c as a,o as e,ag as o}from"./chunks/framework.BDwTZuFy.js";const m=JSON.parse('{"title":"缓存","description":"","frontmatter":{},"headers":[],"relativePath":"docs/计算机网络/计算机网络/前端的缓存.md","filePath":"docs/计算机网络/计算机网络/前端的缓存.md","lastUpdated":1756980074000}'),t={name:"docs/计算机网络/计算机网络/前端的缓存.md"};function r(c,l,d,h,n,p){return e(),a("div",null,l[0]||(l[0]=[o('<h1 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h1><h2 id="一、浏览器的缓存" tabindex="-1">一、浏览器的缓存 <a class="header-anchor" href="#一、浏览器的缓存" aria-label="Permalink to &quot;一、浏览器的缓存&quot;">​</a></h2><h3 id="_1-1-强缓存" tabindex="-1">1.1 强缓存 <a class="header-anchor" href="#_1-1-强缓存" aria-label="Permalink to &quot;1.1 强缓存&quot;">​</a></h3><ul><li><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</p></li><li><p>强制缓存优先于协商缓存，强制缓存由本地的缓存结果决定是否生效，协商缓存由服务器决定决定是否生效。</p></li><li><p>Cache-Control(HTTP1.1/现代首选)</p><ol><li>public：该资源不仅能被客户端缓存，还能被代理服务器缓存</li><li>private(默认值)：该资源只能被客户端缓存</li><li>no-cache：该资源会被客户端缓存，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：该资源不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age=xxx 该资源将在 xxx 秒后失效(使用的是<code>相对时间</code>)</li></ol></li><li><p>Expires(HTTP1.0/现代废弃)</p><ol><li>表示缓存的到期时间，是一个绝对的时间。</li><li>缺点就是写法复杂容易错误</li><li>可能由于时差等因素导致服务器和客户端时间不一致。出现问题。</li></ol></li></ul><h3 id="_1-2-协商缓存" tabindex="-1">1.2 协商缓存 <a class="header-anchor" href="#_1-2-协商缓存" aria-label="Permalink to &quot;1.2 协商缓存&quot;">​</a></h3><ul><li>协商缓存在请求次数上和没有缓存是一致的，但是协商缓存成功只返回一个状态码 <code>304</code>。减少了响应报文的体积</li></ul><ol><li><p>ETag / If-None-Match(基于内容通哈希，现代首选)</p><ul><li>判断的依据是文件的唯一标识符(哈希值或指纹, HTTP 1.1)</li><li>不受文件修改时间的影响</li></ul></li><li><p>Last-Modified / If-Modified-Since(基于文件修改时间, HTTP 1.0)</p><ul><li>判断的依据是文件最后修改时间戳</li><li>精度只能到秒、分布式系统受限</li></ul></li></ol><h2 id="二、内存缓存和硬盘缓存" tabindex="-1">二、内存缓存和硬盘缓存 <a class="header-anchor" href="#二、内存缓存和硬盘缓存" aria-label="Permalink to &quot;二、内存缓存和硬盘缓存&quot;">​</a></h2><h3 id="_2-1-内存缓存-from-memory-cache" tabindex="-1">2.1 内存缓存(from memory cache) <a class="header-anchor" href="#_2-1-内存缓存-from-memory-cache" aria-label="Permalink to &quot;2.1 内存缓存(from memory cache)&quot;">​</a></h3><ol><li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li><li>时效性：一旦该进程关闭，则该进程的内存则会清空(页面关闭一次后就不会再有内存缓存)</li><li>先读内存，在读硬盘。内存的优先等级高。</li></ol><h3 id="_2-2-硬盘缓存-from-disk-cache" tabindex="-1">2.2 硬盘缓存(from disk cache) <a class="header-anchor" href="#_2-2-硬盘缓存-from-disk-cache" aria-label="Permalink to &quot;2.2 硬盘缓存(from disk cache)&quot;">​</a></h3><ol><li>硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行 I/O 操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li></ol><h2 id="三、nginx-最佳配置" tabindex="-1">三、Nginx 最佳配置 <a class="header-anchor" href="#三、nginx-最佳配置" aria-label="Permalink to &quot;三、Nginx 最佳配置&quot;">​</a></h2><blockquote><p>如何才能既利用浏览器的缓存机制，又能让用户在不强制刷新的情况下，也能自动加载到最新的资源。</p></blockquote><p>最佳策略：将<code>缓存策略</code>与<code>前端工程化打包</code>相结合</p><ol><li><p>HTML 入口文件：使用协商缓存</p><ul><li>对 index.html 这类入口文件，设置 Cache-Control: no-cache。</li><li>目的：这强制浏览器每次都向服务器验证 index.html 是否有更新。因为 HTML 文件通常很小，这个验证请求开销不大，但能确保用户总能拿到最新的页面“骨架”。</li></ul></li><li><p>静态资源（JS, CSS, 图片等）：使用强缓存 + 内容哈希</p><ul><li>对JS、CSS、图片、字体等不经常变动的静态资源，设置 长期强缓存，例如 Cache-Control: public, max-age=31536000 (一年)。</li><li>目的：让浏览器将这些资源“永久”地缓存下来，极大提升加载速度。</li><li>关键：在文件名中加入根据文件内容生成的哈希值（Hash）。例如，app.js -&gt; app.a1b2c3d4.js。</li><li>工作流程： <ul><li>a. 当你修改了 app.js 的代码后，现代打包工具（如Webpack, Vite）会自动生成一个新的哈希值，文件名会变成 app.e5f6g7h8.js。</li><li>b. 因为你已经将 index.html 设置为 no-cache，浏览器会获取到最新的 index.html。</li><li>c. 最新的 index.html 中引用的JS文件名已经从 app.a1b2c3d4.js 变成了 app.e5f6g7h8.js。</li><li>d. 对浏览器来说，app.e5f6g7h8.js 是一个全新的URL，本地缓存中没有，它会立刻向服务器发起请求下载这个新文件。</li><li>e. 未改变的资源（如 vendor.b9c8d7e6.js）文件名不变，浏览器会继续使用它的长期强缓存。</li></ul></li></ul></li></ol><p>这样，每次部署新版本时，只有 index.html 和内容有变化的静态资源会被更新，用户无需任何手动刷新操作，就能无缝体验到最新版本。这就是目前所有主流前端框架和项目的标准做法</p>',17)]))}const u=i(t,[["render",r]]);export{m as __pageData,u as default};
