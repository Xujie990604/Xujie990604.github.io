import{_ as o,c,o as d,ag as a}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"模式和环境变量","description":"","frontmatter":{},"headers":[],"relativePath":"docs/前端工程化/Webpack/模式&环境变量.md","filePath":"docs/前端工程化/Webpack/模式&环境变量.md","lastUpdated":1756707094000}'),l={name:"docs/前端工程化/Webpack/模式&环境变量.md"};function i(n,e,t,r,s,_){return d(),c("div",null,e[0]||(e[0]=[a('<h1 id="模式和环境变量" tabindex="-1">模式和环境变量 <a class="header-anchor" href="#模式和环境变量" aria-label="Permalink to &quot;模式和环境变量&quot;">​</a></h1><ul><li>可以通过指定不同的模式，来查看本地开发和生产环境生成的代码有哪些差异(打包时分别指定两种不同的模式，便能看到两种模式下的真实目录有什么差别)</li></ul><h2 id="一、模式-webpack-中的概念" tabindex="-1">一、模式(webpack 中的概念) <a class="header-anchor" href="#一、模式-webpack-中的概念" aria-label="Permalink to &quot;一、模式(webpack 中的概念)&quot;">​</a></h2><ul><li>供 <code>mode</code> 配置选项，告知 <code>webpack</code> 使用<code>相应模式的内置优化</code>，默认值为 production，另外还有 development、none</li><li>如果 webpack 配置文件的导出内容为函数的话，函数的第二个参数的 mode 属性为　<code>模式</code>，便可以根据不同的模式来加载不同的 webpack <code>配置文件</code></li><li>如果 mode 未通过配置或 CLI 赋值，CLI 将使用可能有效的 <code>NODE_ENV</code> 值作为 mode</li></ul><h3 id="_1-1-模式的区别" tabindex="-1">1.1 模式的区别 <a class="header-anchor" href="#_1-1-模式的区别" aria-label="Permalink to &quot;1.1 模式的区别&quot;">​</a></h3><ol><li>development 开发模式：打包更加<code>快速</code>，省了代码优化步骤，不会删除未使用的变量或者文件，不会压缩文件，生成良好的source map, 有利于<code>开发中的调试</code></li><li>production 生产模式: 打包比较慢，会删除未使用的变量或者文件，会开启 <code>tree-shaking</code> 和 <code>压缩代码</code>，减少体积，提升性能，适合发布到<code>生产环境</code>。</li><li>none: <code>不会应用任何默认优化</code>，输出的代码将保持原样，适用于<code>自定义</code>打包配置的特殊需求。</li></ol><h2 id="二、环境变量-node-中的概念" tabindex="-1">二、环境变量(node 中的概念) <a class="header-anchor" href="#二、环境变量-node-中的概念" aria-label="Permalink to &quot;二、环境变量(node 中的概念)&quot;">​</a></h2><ul><li><code>process.env.NODE_ENV</code> 是在 <code>package.json</code> 的 <code>scripts</code> 命令中 通过 <code>cross-env</code> 插件来注入的, 也就是说 NODE_ENV 并不是 node 自带的，而是由用户显式定义的。</li><li>因为 NODE_ENV 属性是被注入到 <code>node</code> 的 process.env 中，所以只能在<code>工程文件中</code>使用该变量，WEB<code>业务代码</code>中是无法使用的。需要借用 <code>DefinePlugin</code> 插件将它注入到浏览器的全局变量中</li><li>Webpack 项目不会自动根据<code>当前的环境变量</code>来加载<code>对应的环境变量文件</code>， 需要使用 <code>dotenv</code> 插件读取对应文件并将变量注入到 <code>process.env</code> 中，再使用 <code>DefinePlugin</code> 插件将变量注入到浏览器的全局变量中</li></ul>',8)]))}const h=o(l,[["render",i]]);export{u as __pageData,h as default};
