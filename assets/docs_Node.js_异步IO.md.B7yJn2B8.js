import{_ as a,c as o,o as i,ag as l}from"./chunks/framework.BDwTZuFy.js";const I=JSON.parse('{"title":"异步模型","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Node.js/异步IO.md","filePath":"docs/Node.js/异步IO.md","lastUpdated":1712646874000}'),t={name:"docs/Node.js/异步IO.md"};function d(r,e,c,s,n,h){return i(),o("div",null,e[0]||(e[0]=[l('<h1 id="异步模型" tabindex="-1">异步模型 <a class="header-anchor" href="#异步模型" aria-label="Permalink to &quot;异步模型&quot;">​</a></h1><h2 id="异步-i-o" tabindex="-1">异步 I/O <a class="header-anchor" href="#异步-i-o" aria-label="Permalink to &quot;异步 I/O&quot;">​</a></h2><ul><li>基于事件驱动的非阻塞 I/O 架构(非阻塞 I/O 的设计使得 CPU 不必等待 I/O 的结果)</li><li>Node 的单线程指的是 JS 的执行是单线程的， I/O 操作由单独的 I/O 线程控制</li><li>Node 中的事件主要来自于 1. 文件 I/O 2. 网络 I/O</li></ul><h3 id="非-i-o-的异步-api" tabindex="-1">非 I/O 的异步 API <a class="header-anchor" href="#非-i-o-的异步-api" aria-label="Permalink to &quot;非 I/O 的异步 API&quot;">​</a></h3><ol><li>setTimeout()</li><li>process.nextTick() 回调函数存储在<code>数组</code>中，每次 <code>Tick</code> 过后会将数组中<code>所有的回调函数</code>执行完毕(类似于微任务)(process.nextTick() 中的回调函数执行的优先级要<code>高于</code> setImmediate())</li><li>setImmediate() 回调函数存储在<code>链表</code>中，每次 <code>Tick</code> 之后只会将链表中的<code>第一个</code>回调函数执行，然后等待下一轮(类似于宏任务)</li></ol><h2 id="node-的优点" tabindex="-1">Node 的优点 <a class="header-anchor" href="#node-的优点" aria-label="Permalink to &quot;Node 的优点&quot;">​</a></h2><ul><li>处理多任务时无需创建新的线程或进程，上下文切换的代价小也不需要关注多线程带来的锁问题。</li><li>充分利用 CPU 资源，使得 CPU 无需等待 I/O 等耗时的操作。对于 I/O 密集型系统具有较高的性能。</li></ul><h2 id="node-的缺点" tabindex="-1">Node 的缺点 <a class="header-anchor" href="#node-的缺点" aria-label="Permalink to &quot;Node 的缺点&quot;">​</a></h2><ul><li>在面对大量的 CPU 计算时 Node 的计算能力并不差，主要的挑战在于长时间的运算会导致 CPU 时间片无法被释放，使得 Node 无法发起后续的 I/O 任务(情况类似于浏览器中 JS 长时间执行导致无法通知 UI 进行渲染)(解决方案：适当的将大任务进行拆分，使得运算能够及时释放，不长时间阻塞后续 I/O 任务调用(类似于浏览器中使用 setTimeout 拆分任务))</li></ul><ol><li>无法利用多核 CPU</li><li>错误会引起整个应用的退出</li><li>大量计算占用 CPU 导致无法继续调用异步 I/0</li></ol><h2 id="异步编程" tabindex="-1">异步编程 <a class="header-anchor" href="#异步编程" aria-label="Permalink to &quot;异步编程&quot;">​</a></h2><h3 id="无法捕获回调函数中的异常" tabindex="-1">无法捕获回调函数中的异常 <a class="header-anchor" href="#无法捕获回调函数中的异常" aria-label="Permalink to &quot;无法捕获回调函数中的异常&quot;">​</a></h3><ul><li>Node 在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出</li></ul><h3 id="函数嵌套层级太深" tabindex="-1">函数嵌套层级太深 <a class="header-anchor" href="#函数嵌套层级太深" aria-label="Permalink to &quot;函数嵌套层级太深&quot;">​</a></h3><ul><li>使用 async/await 来完美解决回调函数嵌套层级太深的问题</li></ul><h3 id="无多线程编程" tabindex="-1">无多线程编程 <a class="header-anchor" href="#无多线程编程" aria-label="Permalink to &quot;无多线程编程&quot;">​</a></h3>',16)]))}const m=a(t,[["render",d]]);export{I as __pageData,m as default};
