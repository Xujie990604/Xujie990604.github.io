import{_ as a,c as n,o as l,ag as e}from"./chunks/framework.BDwTZuFy.js";const b=JSON.parse('{"title":"函数","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/函数&作用域/函数.md","filePath":"docs/JavaScript/函数&作用域/函数.md","lastUpdated":1735478813000}'),o={name:"docs/JavaScript/函数&作用域/函数.md"};function p(r,s,t,c,i,u){return l(),n("div",null,s[0]||(s[0]=[e(`<h1 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h1><ul><li>在 JS 中函数是一等公民 TODO：一等公民的解释</li></ul><h2 id="一、函数声明" tabindex="-1">一、函数声明 <a class="header-anchor" href="#一、函数声明" aria-label="Permalink to &quot;一、函数声明&quot;">​</a></h2><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> test</span><span style="color:#24292E;">() {}</span></span>
<span class="line"><span style="color:#6F42C1;">test</span><span style="color:#24292E;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="二、函数表达式" tabindex="-1">二、函数表达式 <a class="header-anchor" href="#二、函数表达式" aria-label="Permalink to &quot;二、函数表达式&quot;">​</a></h2><ol><li>命名函数表达式</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 通过函数表达式声明函数时，函数原有的名称(foo)会失效</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#6F42C1;"> bar</span><span style="color:#D73A49;"> =</span><span style="color:#D73A49;"> function</span><span style="color:#6F42C1;"> foo</span><span style="color:#24292E;">() {};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="2"><li>匿名函数表达式 --- 函数表达式</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#6F42C1;"> bar</span><span style="color:#D73A49;"> =</span><span style="color:#D73A49;"> function</span><span style="color:#24292E;"> () {};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="三、参数传递" tabindex="-1">三、参数传递 <a class="header-anchor" href="#三、参数传递" aria-label="Permalink to &quot;三、参数传递&quot;">​</a></h2><ol><li>所有函数的参数都是按值传递的(原始类型值：传值的是数据本身， 引用类型值：传递的是数据的引用)</li><li>原始类型值当做参数传递：就和复制时一样，函数的 arguments 新开一个栈内存，拷贝过来外面变量的值，arguments 中变量的值和外面的变量指向<code>不是同一个栈地址</code>，函数内部修改 arguments 的值，<code>不会影响</code>外面的变量。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> addTen</span><span style="color:#24292E;">(</span><span style="color:#E36209;">num</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  num </span><span style="color:#D73A49;">+=</span><span style="color:#005CC5;"> 10</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#24292E;"> num;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> count </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> 20</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> result </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> addTen</span><span style="color:#24292E;">(count);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(count); </span><span style="color:#6A737D;">// 20，没有变化</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(result); </span><span style="color:#6A737D;">// 30</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="3"><li>引用类型值当做参数传递：也和复制一样，函数的 argument 新开一个栈内存存储外面<code>引用类型值的地址</code>。在函数内部修改参数时，外面的变量也会<code>跟着变化</code>，arguments 中的变量和外面的变量指向的<code>不是同一个栈地址</code>，但是<code>都指向同一个堆上的数据</code>。要是为参数重新赋值一个引用类型值的话，外面的变量不会受影响，因为新的引用类型不再指向原来的堆内存。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 1. 函数内部修改参数，外部的引用值也会跟着变</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> setName</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  obj.name </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &quot;Nicholas&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> person </span><span style="color:#D73A49;">=</span><span style="color:#D73A49;"> new</span><span style="color:#6F42C1;"> Object</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6F42C1;">setName</span><span style="color:#24292E;">(person);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(person.name); </span><span style="color:#6A737D;">// &quot;Nicholas&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 2. 为参数重新赋值一个引用类型值， 外部引用值不会跟着变化(证明 JS 不是按引用传递)</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> setName</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  obj.name </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &quot;Nicholas&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  obj </span><span style="color:#D73A49;">=</span><span style="color:#6F42C1;"> newObject</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  obj.name </span><span style="color:#D73A49;">=</span><span style="color:#032F62;"> &quot;Greg&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> person </span><span style="color:#D73A49;">=</span><span style="color:#D73A49;"> new</span><span style="color:#6F42C1;"> Object</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6F42C1;">setName</span><span style="color:#24292E;">(person);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(person.name); </span><span style="color:#6A737D;">// &quot;Nicholas&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ol start="4"><li><code>function(a, b){}</code> 会隐式的在函数里 var a，var b</li><li>总结：函数的参数就是一个<code>局部变量</code>，函数执行完就销毁了。</li></ol><h2 id="四、函数作为值使用" tabindex="-1">四、函数作为值使用 <a class="header-anchor" href="#四、函数作为值使用" aria-label="Permalink to &quot;四、函数作为值使用&quot;">​</a></h2><ul><li>因为函数名本身就是变量，因此函数名可以当做值来使用。</li><li>要访问函数的指针而不是执行函数的话。只需要使用变量名，不需要使用执行符号(加了()是执行函数)</li><li>函数能够作为值来使用，是 JS <code>灵活性的最重要体现</code></li></ul><h2 id="五、函数中的两个默认参数" tabindex="-1">五、函数中的两个默认参数 <a class="header-anchor" href="#五、函数中的两个默认参数" aria-label="Permalink to &quot;五、函数中的两个默认参数&quot;">​</a></h2><h3 id="_5-1-arguments" tabindex="-1">5.1 arguments <a class="header-anchor" href="#_5-1-arguments" aria-label="Permalink to &quot;5.1 arguments&quot;">​</a></h3><ul><li>arguments 是一个类数组对象，这个对象有一个 callee 的属性。该属性是个指针，指向拥有这个 arguments 对象的函数。</li><li>函数名只是一个变量，函数体是一个对象，在使用递归算法时，函数体内的代码执行与函数变量名耦合。为了解耦合使用 arguments.callee 来代替使用函数的变量名。</li></ul><h3 id="_5-2-this" tabindex="-1">5.2 this <a class="header-anchor" href="#_5-2-this" aria-label="Permalink to &quot;5.2 this&quot;">​</a></h3><ul><li>指向的是函数执行的环境(环境一定是一个对象)</li><li>将函数作为方法来调用对于实现 JS 的面向对象编程至关重要</li><li>可以通过 this 来引用方法的宿主对象。这是面向对象编程的基本概念。</li></ul><h2 id="六、不定参" tabindex="-1">六、不定参 <a class="header-anchor" href="#六、不定参" aria-label="Permalink to &quot;六、不定参&quot;">​</a></h2><ul><li>函数不定参，定义的函数和调用函数时参数数量不一样的话，解析器不会有任何怨言。</li><li>因为函数接收到的参数是通过一个 arguments 数组进行表示的。arguments[] 用于接收实参列表。函数名.length 表示形参的长度。arguments.length 表示实参的长度</li><li>函数内的形参和实参列表(arguments)有一种映射关系，他们两个都会跟着对方变，但是并不是说他们两个具有相同的内存空间，内存空间是独立的，但是值会同步。不推荐使用 arguments[] 来修改函数内部的实参，代码可读性太差。</li><li>实参列表(arguments)传参时有几个就是几个。如果函数调用时传入的实参就比形参少，函数内再去给 arguments 列表内缺少的形参赋值。arguments[] 不会再跟着变了。</li></ul><h2 id="七、没有重载" tabindex="-1">七、没有重载 <a class="header-anchor" href="#七、没有重载" aria-label="Permalink to &quot;七、没有重载&quot;">​</a></h2><ul><li>JS 不向 Java 一样，可以进行函数的重载。但是可以通过不定参来实现类似重载的效果。</li><li>因为函数名只是一个指针，在想要进行函数重载时，两个同名的函数，相当于后面的函数覆盖了前面的函数体。</li></ul>`,26)]))}const y=a(o,[["render",p]]);export{b as __pageData,y as default};
