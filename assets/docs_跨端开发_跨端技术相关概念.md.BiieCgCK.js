import{_ as e,c as o,o as i,ag as l}from"./chunks/framework.BDwTZuFy.js";const m=JSON.parse('{"title":"跨端技术中涉及到的概念","description":"","frontmatter":{},"headers":[],"relativePath":"docs/跨端开发/跨端技术相关概念.md","filePath":"docs/跨端开发/跨端技术相关概念.md","lastUpdated":1739805207000}'),t={name:"docs/跨端开发/跨端技术相关概念.md"};function d(c,a,r,h,n,s){return i(),o("div",null,a[0]||(a[0]=[l('<h1 id="跨端技术中涉及到的概念" tabindex="-1">跨端技术中涉及到的概念 <a class="header-anchor" href="#跨端技术中涉及到的概念" aria-label="Permalink to &quot;跨端技术中涉及到的概念&quot;">​</a></h1><h2 id="字节码-bytecode" tabindex="-1">字节码（Bytecode） <a class="header-anchor" href="#字节码-bytecode" aria-label="Permalink to &quot;字节码（Bytecode）&quot;">​</a></h2><p>字节码是一种<code>中间代码</code>，它是由编译器将高级语言编译成的一种中间表示形式。字节码是一种抽象的代码，它可以在<code>不同的平台上运行</code>，而不需要重新编译。</p><h3 id="字节码特点" tabindex="-1">字节码特点 <a class="header-anchor" href="#字节码特点" aria-label="Permalink to &quot;字节码特点&quot;">​</a></h3><ul><li><code>较高的可移植性</code>，字节码不依赖于特定的硬件平台，只需要有相应的<code>解释器或虚拟机</code>即可运行。</li><li>执行效率相对较低。字节码需要虚拟机<code>解释执行</code>或者<code>即时编译 (JIT)</code></li></ul><h2 id="机器码-machine-code" tabindex="-1">机器码（Machine code） <a class="header-anchor" href="#机器码-machine-code" aria-label="Permalink to &quot;机器码（Machine code）&quot;">​</a></h2><p>机器码是<code>计算机中央处理器 (CPU)</code> 能够<code>直接理解和执行</code>的<code>指令</code>集合，它是由<code>二进制代码</code>组成的。机器码是由硬件直接执行的，因此它的执行速度非常快。</p><h3 id="机器码特点" tabindex="-1">机器码特点 <a class="header-anchor" href="#机器码特点" aria-label="Permalink to &quot;机器码特点&quot;">​</a></h3><ul><li><code>可移植性较差</code>。不同的 CPU 架构有不同的<code>机器码指令集</code>，因此为一种 CPU 架构生成的机器码通常不能在另一种 CPU 架构上直接运行</li></ul><h2 id="提前编译-aot-ahead-of-time-compilation" tabindex="-1">提前编译 AOT（Ahead-of-Time Compilation） <a class="header-anchor" href="#提前编译-aot-ahead-of-time-compilation" aria-label="Permalink to &quot;提前编译 AOT（Ahead-of-Time Compilation）&quot;">​</a></h2><ul><li>AOT 是一种编译技术，它在程序<code>运行之前</code>将源代码编译成<code>机器码</code>，而不是在运行时动态编译。</li><li>AOT 通常用于嵌入式系统和移动设备等资源受限的环境中，因为它可以减少运行时的编译时间和内存占用。</li><li>例如，C、C++、Java 的 GraalVM 虚拟机(早期 JAVA 虚拟机)</li></ul><h2 id="即时编译-jit-just-in-time-compilation" tabindex="-1">即时编译 JIT（Just-in-Time Compilation） <a class="header-anchor" href="#即时编译-jit-just-in-time-compilation" aria-label="Permalink to &quot;即时编译 JIT（Just-in-Time Compilation）&quot;">​</a></h2><ul><li>JIT 是一种编译技术，它在程序<code>运行时</code>将源代码编译成<code>机器码</code>。</li><li>JIT 通常用于解释型语言和动态语言中，因为它可以在<code>运行时根据程序的需要进行优化和调整</code>。当发现某些代码段（如热点代码，即被频繁执行的代码）时，JIT 编译器会将这些代码段动态地编译成机器码，之后再执行这些代码时就可以直接运行编译好的机器码</li><li>例如，JavaScript、Python、Java 的 HotSpot 虚拟机(现代 JAVA 虚拟机)</li></ul><h2 id="aot-与-jit-对比" tabindex="-1">AOT 与 JIT 对比 <a class="header-anchor" href="#aot-与-jit-对比" aria-label="Permalink to &quot;AOT 与 JIT 对比&quot;">​</a></h2><h3 id="启动速度" tabindex="-1">启动速度 <a class="header-anchor" href="#启动速度" aria-label="Permalink to &quot;启动速度&quot;">​</a></h3><ul><li>AOT 编译的程序在启动时速度更快，因为它不需要在运行时进行动态编译。</li><li>JIT 编译的程序在启动时速度相对较慢，因为它需要在运行时进行动态编译。</li></ul><h3 id="运行速度" tabindex="-1">运行速度 <a class="header-anchor" href="#运行速度" aria-label="Permalink to &quot;运行速度&quot;">​</a></h3><ul><li>AOT 编译时无法获取程序运行时的具体信息，只能基于一些通用的假设进行优化，因此生成的机器码可能不是针对特定运行环境的最优代码。在<code>某些情况</code>下，AOT 编译的程序运行速度可能不如 JIT 编译的程序。</li><li>JIT 可以根据程序运行时的实际情况进行优化，例如根据实际的输入数据、函数调用频率等信息生成更高效的机器码。对于热点代码，JIT 编译可以显著提高其执行速度，因此在程序长时间运行后，JIT 编译的程序往往能获得更好的性能</li></ul><h2 id="代码热更新" tabindex="-1">代码热更新 <a class="header-anchor" href="#代码热更新" aria-label="Permalink to &quot;代码热更新&quot;">​</a></h2><ul><li>热更新指的是在不重新发布应用安装包、无需用户重新下载安装应用的情况下，对应用的代码、资源等进行更新的技术</li></ul><h2 id="应用热重载" tabindex="-1">应用热重载 <a class="header-anchor" href="#应用热重载" aria-label="Permalink to &quot;应用热重载&quot;">​</a></h2><ul><li>热重载是一种允许开发者在不重新启动应用的前提下，将代码的更改快速应用到正在运行的应用中的技术。当开发者修改了代码后，只需触发热重载操作，应用就能在保持当前状态（如界面展示、用户输入内容、变量值等）的情况下，更新界面和功能，让开发者立即看到代码修改后的效果</li></ul>',22)]))}const T=e(t,[["render",d]]);export{m as __pageData,T as default};
