import{_ as a,c as i,o as t,ag as l}from"./chunks/framework.BDwTZuFy.js";const o="/assets/webpack%E6%89%93%E5%8C%85.BmW4DsJr.png",c="/assets/Esbuild%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6.vZrR8zNs.png",r="/assets/vite%E8%BF%90%E8%A1%8C.ClnhQJ9_.png",h=JSON.parse('{"title":"Webpack 和 Vite 对比","description":"","frontmatter":{},"headers":[],"relativePath":"docs/技术文档总结/三方插件和工具/webpack和Vite对比.md","filePath":"docs/技术文档总结/三方插件和工具/webpack和Vite对比.md","lastUpdated":1758686076000}'),s={name:"docs/技术文档总结/三方插件和工具/webpack和Vite对比.md"};function d(p,e,b,n,u,k){return t(),i("div",null,e[0]||(e[0]=[l('<h1 id="webpack-和-vite-对比" tabindex="-1">Webpack 和 Vite 对比 <a class="header-anchor" href="#webpack-和-vite-对比" aria-label="Permalink to &quot;Webpack 和 Vite 对比&quot;">​</a></h1><ul><li>webpack 是一个用于<code>现代 JavaScript</code> 应用程序的 <code>静态模块</code> <code>打包工具</code>(对标 Rollup)</li><li>Vite 是一个更上层的工具链方案，对标的是 (webpack + 针对 web 的常用配置 + webpack-dev-server)</li></ul><h2 id="一、开箱即用-配置简单" tabindex="-1">一、开箱即用，配置简单 <a class="header-anchor" href="#一、开箱即用-配置简单" aria-label="Permalink to &quot;一、开箱即用，配置简单&quot;">​</a></h2><ul><li>由于 Webpack 没有预设场景，设计的十分灵活，导致配置项复杂，插件机制和内部逻辑晦涩难懂。即使是最常见的 WEB 场景也需要大量的配置。并且大量的 loader 之间虽然单独发布但是却隐藏隐式耦合(各种版本之间)。</li><li>Vite 则预设了场景 <code>WEB</code>,并且将大部分常见的 WEB 构建需求都直接做成了默认的配置(TS JS ES6 file CSS SCSS font 等)，并且 Vite 也提供了脚手架方便集成 ESlint Prettier TS Test。</li></ul><h2 id="二、构建项目的区别" tabindex="-1">二、构建项目的区别 <a class="header-anchor" href="#二、构建项目的区别" aria-label="Permalink to &quot;二、构建项目的区别&quot;">​</a></h2><h3 id="_2-1-webpack" tabindex="-1">2.1 Webpack <a class="header-anchor" href="#_2-1-webpack" aria-label="Permalink to &quot;2.1 Webpack&quot;">​</a></h3><ol><li>Webpack 在启动时，会先构建项目模块的依赖图，如果在项目中的某个地方改动了代码，Webpack 则会对相关的依赖重新打包，随着项目的增大，其打包速度也会下降。</li></ol><p><img src="'+o+'" alt="Webpack工作原理"></p><h3 id="_2-2-vite" tabindex="-1">2.2 Vite <a class="header-anchor" href="#_2-2-vite" aria-label="Permalink to &quot;2.2 Vite&quot;">​</a></h3><ul><li>Vite 其核心原理是利用浏览器现在已经支持 ES6 的 import, 碰见 import 就会发送一个 HTTP 请求去加载文件。Vite 以 原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作</li><li>Vite 启动一个 koa 服务器拦截这些请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再以 ESM 格式返回返回给浏览器。Vite 整个过程中没有对文件进行 <code>打包编译</code>，做到了真正的 <code>按需加载</code>，所以其运行速度比原始的 webpack 开发编译速度快出许多</li><li>在开发阶段使用 ESbuild 进行 <code>转译</code>。Esbuild 则选择使用 Go 语言编写能够充分利用 CPU 的多核性能。Esbuild 具有非常快的速度，打包速度却是其他工具的 10 ～ 100 倍。(快就一个字，开发时能实现秒开)</li></ul><p><img src="'+c+'" alt="Esbuild打包速度"></p><ul><li>在生产环境下使用 Rollup 进行打包。尽管 esbuild 速度更快，但 Vite 采用了 Rollup 灵活的插件 API 和基础建设，这对 Vite 在生态中的成功起到了重要作用。目前来看，我们认为 Rollup 提供了更好的性能与灵活性方面的权衡。</li></ul><p><img src="'+r+'" alt="Vite工作原理"></p><h2 id="三、vite-为什么要比-webpack-快" tabindex="-1">三、Vite 为什么要比 Webpack 快 <a class="header-anchor" href="#三、vite-为什么要比-webpack-快" aria-label="Permalink to &quot;三、Vite 为什么要比 Webpack 快&quot;">​</a></h2><ul><li>按需编译：当浏览器请求某个模块时，再根据需要对模块内容进行编译</li><li>充分利用现代浏览器 ES 特性：所以开发阶段的 babel 转化工作会省略很多</li><li>高效底层语言：ESBuild 使用 Go 语言编写，使用 ESBuild 进行转译，能够充分利用 CPU 多核的运算</li></ul>',15)]))}const E=a(s,[["render",d]]);export{h as __pageData,E as default};
