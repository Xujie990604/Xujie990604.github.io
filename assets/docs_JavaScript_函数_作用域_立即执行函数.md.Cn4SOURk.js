import{_ as a,c as o,o as t,ag as c}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"立即执行函数","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/函数&作用域/立即执行函数.md","filePath":"docs/JavaScript/函数&作用域/立即执行函数.md","lastUpdated":1735478813000}'),i={name:"docs/JavaScript/函数&作用域/立即执行函数.md"};function l(d,e,r,n,s,_){return t(),o("div",null,e[0]||(e[0]=[c('<h1 id="立即执行函数" tabindex="-1">立即执行函数 <a class="header-anchor" href="#立即执行函数" aria-label="Permalink to &quot;立即执行函数&quot;">​</a></h1><ul><li>不是专门制定发布的，而是通过 <code>()</code> 的特性研发的</li><li>在 ES6 之前主要用途是 <code>模仿块级作用域</code>，解决闭包带来的问题，在 ES6 之后，在该场景下使用 <code>块级作用域</code> 替换 <code>立即执行函数</code>，代码更加简洁</li></ul><h2 id="两种写法" tabindex="-1">两种写法 <a class="header-anchor" href="#两种写法" aria-label="Permalink to &quot;两种写法&quot;">​</a></h2><ol><li>(function(){}()) W3C建议第一种</li><li>(function(){})()</li></ol><h2 id="执行原理" tabindex="-1">执行原理 <a class="header-anchor" href="#执行原理" aria-label="Permalink to &quot;执行原理&quot;">​</a></h2><ol><li>原理就是 <code>()</code> 既可以把函数声明转化为表达式， 同时又是执行符号</li><li>不仅有 <code>()</code> 能把函数声明转化为表达式， <code>+function(){}</code> <code>-function(){}</code> 等一元运算符都能将函数声明转化为表达式</li><li>只有表达式才能被执行符号执行 <code>()</code> 叫执行符号</li><li>能被执行符号执行的函数会被忽略名字</li></ol>',6)]))}const f=a(i,[["render",l]]);export{u as __pageData,f as default};
