import{_ as e,c as a,o as t,ag as l}from"./chunks/framework.BDwTZuFy.js";const s="/assets/prototype.BhwxRRyx.png",b=JSON.parse('{"title":"原型链 原型","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/对象&原型/原型 原型链.md","filePath":"docs/JavaScript/对象&原型/原型 原型链.md","lastUpdated":1757838010000}'),n={name:"docs/JavaScript/对象&原型/原型 原型链.md"};function r(p,o,i,c,d,_){return t(),a("div",null,o[0]||(o[0]=[l('<h1 id="原型链-原型" tabindex="-1">原型链 原型 <a class="header-anchor" href="#原型链-原型" aria-label="Permalink to &quot;原型链 原型&quot;">​</a></h1><ul><li><code>__proto__</code>, <code>constructor</code> 属性是对象所独有的</li><li><code>prototype</code> 属性是函数所独有的</li><li>但是函数是对象的一种，所以函数也有 <code>__proto__</code>, <code>constructor</code>属性</li></ul><p><img src="'+s+`" alt="原型链结构"></p><ul><li><p>constructor(可以手动改变)是原型中的一个属性</p></li><li><p>[[Prototype]]是对象的隐藏私有属性，指向的就是对象的构造函数的原型。但是不能直接通过[[Prototype]]来读原型。所以目前有两种方式来读写原型。</p><ol><li>是通过 ES6 标准方法 Object.getPrototypeOf() 来获取原型，用函数 Object.setPrototypeOf() 来设置原型。</li><li>使用 JS 标准中并没有定义，但是各大浏览器厂商已经实现的 <code>__proto__</code> 属性来读写原型</li></ol></li><li><p>准则一: 构造函数的原型对象的 constructor 属性指向构造函数自身</p></li><li><p>准则二：实例的 <code>__proto__</code> 和构造函数的原型对象指向<code>同一个地方(同一个内存区域)</code></p></li></ul><ol><li>Person.prototype 本质也是一个实例(对象实例)，是由 new Object() 得到的，所以 Person.prototype.<code>__proto__</code> == Object.prototype。</li><li>function Person() 本质上是一个实例(函数实例)， 是由 new Function()得到的，所以 Person.<code>__proto__</code> == Function.prototype;</li></ol><h2 id="构造函数内部原理三段论的深入理解" tabindex="-1">构造函数内部原理三段论的深入理解 <a class="header-anchor" href="#构造函数内部原理三段论的深入理解" aria-label="Permalink to &quot;构造函数内部原理三段论的深入理解&quot;">​</a></h2><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 通过 Object.create() 创建对象</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> this </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Object.</span><span style="color:#6F42C1;">create</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">Person</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 生成对象的内部结构</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> this </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  __proto__: </span><span style="color:#005CC5;">Person</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol><li>只有第一步不一样</li><li>隐式的构造的 this 对象，并不是真的空的。里面有 <code>__proto__</code> 指向构造函数的原型</li><li>生成的对象实例从 <code>__proto__</code> 指向的空间里取值，而不是一定从 Person.prototype 地址中取数据。因为 <code>__proto__</code> 地址的指向可以人为改变，导致不指向系统自动生成的原型</li></ol><h2 id="原型链" tabindex="-1">原型链 <a class="header-anchor" href="#原型链" aria-label="Permalink to &quot;原型链&quot;">​</a></h2><ul><li>原型链：Object.prototype 是绝大多数对象( 因为 Object.create(null)的存在 )的原型链终点</li><li>Object.prototype 的 <code>__proto__</code> 是 null</li></ul><h3 id="原型链上的属性更改" tabindex="-1">原型链上的属性更改 <a class="header-anchor" href="#原型链上的属性更改" aria-label="Permalink to &quot;原型链上的属性更改&quot;">​</a></h3><ul><li>原型链上的属性一般来说都不可以通过子代来进行增删改查。</li><li>原型链可以通过子代修改父类的对象类属性。这是引用值自己的修改。这是一种调用方法的修改。</li></ul><h3 id="确定原型和实例的关系" tabindex="-1">确定原型和实例的关系 <a class="header-anchor" href="#确定原型和实例的关系" aria-label="Permalink to &quot;确定原型和实例的关系&quot;">​</a></h3><ul><li>使用 instanceof() 来测试实例的原型链中是否出现过该构造函数 (person instanceof Person)</li><li>使用 isPrototype() 来测试实例的原型链中是否出现过该原型(Person.prototype.isPrototype(person))</li></ul><h2 id="object-create" tabindex="-1">Object.create() <a class="header-anchor" href="#object-create" aria-label="Permalink to &quot;Object.create()&quot;">​</a></h2><ul><li><p>var obj1 = Object.create(原型);</p></li><li><p>就会把原型参数当做 obj1 的原型 不可以手动添加原型，但可以手动修改已有原型。</p></li><li><p>var obj = Object.create(null); 这个对象没有任何的继承下来的方法可以使用。</p></li><li><p>obj 是没有原型的，手动加上原型是没有用的。</p></li><li><p>undefined 就是一个原始值，它没有原型，所以没有 toString() 方法</p></li><li><p>null 也没有原型，也没有 toString()</p></li></ul><h2 id="tosting-方法" tabindex="-1">toSting()方法 <a class="header-anchor" href="#tosting-方法" aria-label="Permalink to &quot;toSting()方法&quot;">​</a></h2><ol><li>Object 有 toString 方法，它底下的 Number ，String，Array 等包装类都重写了 toString 方法，所以不同类型的数据调用 toString 方法输出各异。</li><li>document.write 其实隐式调用了 toString 方法</li></ol>`,18)]))}const h=e(n,[["render",r]]);export{b as __pageData,h as default};
