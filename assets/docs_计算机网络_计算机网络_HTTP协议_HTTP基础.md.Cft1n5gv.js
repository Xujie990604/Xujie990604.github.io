import{_ as i,c as a,o as t,ag as T}from"./chunks/framework.BDwTZuFy.js";const H=JSON.parse('{"title":"HTTP 基础","description":"","frontmatter":{},"headers":[],"relativePath":"docs/计算机网络/计算机网络/HTTP协议/HTTP基础.md","filePath":"docs/计算机网络/计算机网络/HTTP协议/HTTP基础.md","lastUpdated":1736933386000}'),e={name:"docs/计算机网络/计算机网络/HTTP协议/HTTP基础.md"};function o(r,l,h,P,n,d){return t(),a("div",null,l[0]||(l[0]=[T('<h1 id="http-基础" tabindex="-1">HTTP 基础 <a class="header-anchor" href="#http-基础" aria-label="Permalink to &quot;HTTP 基础&quot;">​</a></h1><h2 id="一些基础概念" tabindex="-1">一些基础概念 <a class="header-anchor" href="#一些基础概念" aria-label="Permalink to &quot;一些基础概念&quot;">​</a></h2><ul><li>HTTP 是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP 是一个无状态的协议。</li><li>HTTP 协议通常承载于 TCP 协议之上，有时也承载于 TLS 或 SSL 协议层之上，这个时候，就成了我们常说的 HTTPS</li><li>http 是要基于 TCP 连接基础上的，简单的说，TCP 就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http 是用来收发数据，即实际应用上来的。</li><li>默认 HTTP 的端口号为 80，HTTPS 的端口号为 443</li><li>HTTP 协议永远都是客户端发起请求，服务器回送响应。</li><li>HTTP 协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系</li><li>RFC 使用来制定 HTTP 协议标准的文档</li></ul><h2 id="http-协议的特点" tabindex="-1">HTTP 协议的特点 <a class="header-anchor" href="#http-协议的特点" aria-label="Permalink to &quot;HTTP 协议的特点&quot;">​</a></h2><ol><li>客户端/服务端的通信模式</li><li>无连接 通过长连接，多路复用等措施进行优化</li><li>无状态 使用 Cookie 进行优化</li></ol><h2 id="http-的状态码" tabindex="-1">http 的状态码 <a class="header-anchor" href="#http-的状态码" aria-label="Permalink to &quot;http 的状态码&quot;">​</a></h2><ul><li><p>状态码的类别</p><ol><li>1XX 信息状态码 接收的请求正在处理</li><li>2XX 成功状态码 请求正常处理完毕</li><li>3XX 重定向状态码 需要进行附加操作以完成请求</li><li>4XX 客户端错误状态码 服务器无法处理请求</li><li>5XX 服务器状态码 服务器处理请求出错</li></ol></li></ul><h3 id="比较典型的状态码" tabindex="-1">比较典型的状态码 <a class="header-anchor" href="#比较典型的状态码" aria-label="Permalink to &quot;比较典型的状态码&quot;">​</a></h3><ul><li>200 ok 表示从客户端发来的请求在服务器端被正常处理了。</li><li>204 no content 一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用</li><li>206 Partial Content 该状态码表示客户端进行了范围请求</li><li>301 Moved Permanently 永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI</li><li>302 Found 临时性重定向</li><li>303 See Other 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</li><li>304 Not Modified 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况</li><li>400 Bad Request 该状态码表示请求报文中存在语法错误</li><li>401 Unauthorized 该状态码表示发送的请求需要有通过 HTTP 认证的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。</li><li>403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由</li><li>404 Not Found 该状态码表明服务器上无法找到请求的资源</li><li>500 Internal Server Error 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</li><li>503 Service Unavailable 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li></ul><h2 id="http-https" tabindex="-1">HTTP HTTPS <a class="header-anchor" href="#http-https" aria-label="Permalink to &quot;HTTP HTTPS&quot;">​</a></h2><h3 id="http-的不足" tabindex="-1">HTTP 的不足 <a class="header-anchor" href="#http-的不足" aria-label="Permalink to &quot;HTTP 的不足&quot;">​</a></h3><ul><li>通信使用明文(不加密),内容可能会被窃听</li><li>不验证通信方的身份,因此有可能遭遇伪装</li><li>无法证明报文的完整性,所以有可能已遭篡改</li></ul><h3 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h3><ul><li>HTTP 协议中没有加密机制,但可以通过 SSL 或 TLS(的组合使用,加密 HTTP 的通信内容。属于通信加密，即在整个通信线路中加密)(SSL 和 TLS 协议是位于运输层的协议)</li><li>用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS</li><li>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</li><li>HTTPS 是身披 SSL 外壳的 HTTP</li><li>HTTPS 是应用层的安全协议，TCP 是传输层的协议，但是它不安全，因为它是明文传输的，所以 SSL 的诞生就是给 TCP 加了一层保险，使 HTTPS 和 TCP 之间使用加密传输。而 TLS 只是 SSL 的升级版，他们的作用是一样的。</li></ul>',14)]))}const S=i(e,[["render",o]]);export{H as __pageData,S as default};
