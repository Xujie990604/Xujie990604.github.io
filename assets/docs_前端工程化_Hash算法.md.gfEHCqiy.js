import{_ as e,c as l,o,ag as t}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"Hash算法","description":"","frontmatter":{},"headers":[],"relativePath":"docs/前端工程化/Hash算法.md","filePath":"docs/前端工程化/Hash算法.md","lastUpdated":1756718412000}'),h={name:"docs/前端工程化/Hash算法.md"};function s(i,a,r,d,c,n){return o(),l("div",null,a[0]||(a[0]=[t('<h1 id="hash算法" tabindex="-1">Hash算法 <a class="header-anchor" href="#hash算法" aria-label="Permalink to &quot;Hash算法&quot;">​</a></h1><h2 id="一、hash算法" tabindex="-1">一、Hash算法 <a class="header-anchor" href="#一、hash算法" aria-label="Permalink to &quot;一、Hash算法&quot;">​</a></h2><blockquote><p>能将任意长度的输入数据，通过一个数学函数，转换成一个固定长度的输出（哈希值或摘要）的算法</p></blockquote><ol><li>确定性：相同的输入数据，一定会得到相同的输出哈希值</li><li>不可逆性：从输出哈希值，无法反推出输入数据</li><li>抗碰撞性：不同的输入，极难（理论上几乎不可能）产生相同的输出</li></ol><h2 id="输入的数据是什么" tabindex="-1">输入的数据是什么？ <a class="header-anchor" href="#输入的数据是什么" aria-label="Permalink to &quot;输入的数据是什么？&quot;">​</a></h2><ul><li>hash 不是依据<code>源代码</code>计算的，而是通过最终要<code>生成到 dist 目录的文件</code>计算的</li></ul><ol><li>源文件处理后的代码</li><li>模块的依赖关系：如果 A 文件依赖 B 文件，那么 A 文件的最终内容里，会包含如何加载 B 文件的信息。所以 B 文件内容一变，B 的 Hash 变了，导致 A 的内容里引用的文件名也变了，A 的 Hash 也就跟着变了。</li><li>所有被打包进来的模块：对于一个 Chunk 文件而言，它的 hash 输入是 Chunk 包含所有模块的总和</li></ol><h2 id="常见算法" tabindex="-1">常见算法 <a class="header-anchor" href="#常见算法" aria-label="Permalink to &quot;常见算法&quot;">​</a></h2><ol><li>MD5</li></ol>',9)]))}const p=e(h,[["render",s]]);export{u as __pageData,p as default};
