import{_ as n,c as a,o as l,ag as e}from"./chunks/framework.BDwTZuFy.js";const p="/assets/Promise%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.C2wlKmzS.png",u=JSON.parse('{"title":"Promise","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/异步方案/Promise.md","filePath":"docs/JavaScript/异步方案/Promise.md","lastUpdated":1725182996000}'),o={name:"docs/JavaScript/异步方案/Promise.md"};function r(c,s,t,i,y,b){return l(),a("div",null,s[0]||(s[0]=[e('<h1 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h1><ul><li>Promise 对象是我们现在尚未得到的，但将来会得到的值的占位符。</li></ul><h2 id="一、promise-的特点" tabindex="-1">一、Promise 的特点 <a class="header-anchor" href="#一、promise-的特点" aria-label="Permalink to &quot;一、Promise 的特点&quot;">​</a></h2><p><img src="'+p+`" alt="Promise三种状态"></p><ol><li>对象的状态不受外界的影响，只有异步操作的结果可以决定当前是哪一种状态。任何其他的操作都无法改变这个状态</li><li>promise 对象只会有两种可能 1、从 pending 到 resolved 2、从 pending 到 rejected。一旦状态改变就不会再变。任何时候都会得到这个结果。</li></ol><h3 id="_1-1-缺点" tabindex="-1">1.1 缺点 <a class="header-anchor" href="#_1-1-缺点" aria-label="Permalink to &quot;1.1 缺点&quot;">​</a></h3><ol><li>无法取消 Promise, 一旦新建它就会立即执行，无法中途取消</li><li>当处于 pending 状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)</li></ol><h2 id="二、resolve-和-reject" tabindex="-1">二、resolve 和 reject <a class="header-anchor" href="#二、resolve-和-reject" aria-label="Permalink to &quot;二、resolve 和 reject&quot;">​</a></h2><h3 id="_2-1-promise-resolve" tabindex="-1">2.1 Promise.resolve() <a class="header-anchor" href="#_2-1-promise-resolve" aria-label="Permalink to &quot;2.1 Promise.resolve()&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;foo&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 等价于</span></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">((</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#6F42C1;"> resolve</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;foo&quot;</span><span style="color:#24292E;">));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="_1-参数是一个-promise-实例" tabindex="-1">(1) 参数是一个 Promise 实例 <a class="header-anchor" href="#_1-参数是一个-promise-实例" aria-label="Permalink to &quot;(1) 参数是一个 Promise 实例&quot;">​</a></h4><ul><li>Promise.resolve() 是一个幂等的方法，如果参数也是一个 Promise 实例，那么就会不做任何修改、原封不动地返回这个实例</li></ul><h4 id="_2-参数是一个-thenable-对象" tabindex="-1">(2) 参数是一个 thenable 对象 <a class="header-anchor" href="#_2-参数是一个-thenable-对象" aria-label="Permalink to &quot;(2) 参数是一个 thenable 对象&quot;">​</a></h4><p>thenable 对象指的是具有 then 方法的对象，比如下面这个对象。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> thenable </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6F42C1;">  then</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;">, </span><span style="color:#E36209;">reject</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6F42C1;">    resolve</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">42</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法。</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> thenable </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6F42C1;">  then</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;">, </span><span style="color:#E36209;">reject</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#6F42C1;">    resolve</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">42</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> p1 </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(thenable);</span></span>
<span class="line"><span style="color:#24292E;">p1.</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(value); </span><span style="color:#6A737D;">// 42</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="_3-参数不是具有-then-的对象-或者不是对象-或者没有参数" tabindex="-1">(3) 参数不是具有 then 的对象，或者不是对象，或者没有参数 <a class="header-anchor" href="#_3-参数不是具有-then-的对象-或者不是对象-或者没有参数" aria-label="Permalink to &quot;(3) 参数不是具有 then 的对象，或者不是对象，或者没有参数&quot;">​</a></h4><ul><li>Promise.resolve 方法返回一个新的 Promise 对象，状态为 resolved，并且把参数作为期约的值.</li></ul><h3 id="_2-2-promise-reject" tabindex="-1">2.2 Promise.reject() <a class="header-anchor" href="#_2-2-promise-reject" aria-label="Permalink to &quot;2.2 Promise.reject()&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">reject</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;foo&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 等价于</span></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">((</span><span style="color:#E36209;">reject</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#6F42C1;"> reject</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;foo&quot;</span><span style="color:#24292E;">));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol><li>Promise.reject() 没有实现和 Promise.resolve() 一样的幂等逻辑，Promise.reject() 方法的参数，会<code>原封不动</code>地作为 reject 的理由</li><li>Promise.reject() 返回一个 Promise 对象，并且状态为 rejected，并且把参数作为 reject 的理由。</li><li>Promise.reject() 抛出的错误是异步的，无法使用同步的 try catch{} 块来捕获异步错误</li></ol><h2 id="三、期约的实例方法" tabindex="-1">三、期约的实例方法 <a class="header-anchor" href="#三、期约的实例方法" aria-label="Permalink to &quot;三、期约的实例方法&quot;">​</a></h2><h3 id="_3-1-promise-prototype-then" tabindex="-1">3.1 Promise.prototype.then() <a class="header-anchor" href="#_3-1-promise-prototype-then" aria-label="Permalink to &quot;3.1 Promise.prototype.then()&quot;">​</a></h3><ul><li><p>其实 then 方法可以提供<code>两个回调函数</code>。第一个在上面的执行器 resolve 时执行回调，第二个在上面的执行器 reject 时执行回调</p><blockquote><p>了解 then 有两个回调函数这件事即可，不要用两个回调函数的形式来书写代码，结构会很混乱，把人搞懵</p></blockquote></li><li><p>p.then() 的返回值是一个 <code>新的 Promise 实例</code> (p 代指上面的执行器 Promise())，then 的返回值和 p 的执行状态对应的 then 中的回调有关(也就是说如果 p resolve，那么 then 的返回值就和 then 中的第一个回调有关， 如果 p reject，那么 then 的返回值就和 then 中的第二个回调有关)。</p></li></ul><ol><li>如果 then 中第一个回调函数被定义，且有返回值那么就把这个返回值通过 Promise.resolve() 包装，然后 then 的返回值就等于这个被包装过的值</li><li>如果 then 中的第一个回调函数被定义，但是没有返回值，那么 then 的返回值就是 undefined 经过 Promise.resolve() 包装</li><li>如果 then 的中的第一个回调函数没有被定义，那么 then 的返回值就是上面的 p 的解决之后的值。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">new</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">((</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;">, </span><span style="color:#E36209;">reject</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6F42C1;">  resolve</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;111&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">})</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">((</span><span style="color:#E36209;">res</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(res);</span></span>
<span class="line"><span style="color:#D73A49;">    return</span><span style="color:#032F62;"> &quot;aaa&quot;</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 有返回值，所以这个 then 的返回值就是 &#39;aaa&#39; 经过resolve()函数包装</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, (</span><span style="color:#E36209;">err</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">    // then 中第一个回调函数没有定义。所以这个 then 的返回值就是上一个 then 的返回值</span></span>
<span class="line"><span style="color:#6A737D;">    // NOTE：用另一种方式来理解，此时这就是一个 catch 方法，上面的 Promise 状态为 resolved，所以这个catch 就没有被调用</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(err);</span></span>
<span class="line"><span style="color:#D73A49;">    throw</span><span style="color:#032F62;"> &quot;bbb&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">((</span><span style="color:#E36209;">res</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(res); </span><span style="color:#6A737D;">// aaa 得到的数据是 &#39;aaa&#39;</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="_3-2-promise-prototype-catch" tabindex="-1">3.2 Promise.prototype.catch() <a class="header-anchor" href="#_3-2-promise-prototype-catch" aria-label="Permalink to &quot;3.2 Promise.prototype.catch()&quot;">​</a></h3><ul><li>本质上是一个语法糖，<code>p.catch(() =&gt; {}) === p.then(null, () =&gt; {})</code></li><li>catch 也有返回值，返回值会被 Promise.resolve() 包装</li><li>Promise 的错误会一直向后传递，直到被捕获为止</li></ul><blockquote><p>Promise 中的错误捕获</p></blockquote><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 一、Promise 中 抛出错误，会导致 Promise 的状态变成 reject</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> p </span><span style="color:#D73A49;">=</span><span style="color:#D73A49;"> new</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">((</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;">, </span><span style="color:#E36209;">reject</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  // 一般在 Promise 抛出错误的形式</span></span>
<span class="line"><span style="color:#6F42C1;">  reject</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#6F42C1;"> Error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;err&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#6A737D;">  // 使用 throw 语句同样也可以使得 Promise 的状态改变为 reject</span></span>
<span class="line"><span style="color:#D73A49;">  throw</span><span style="color:#6F42C1;"> Error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;error&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 二、then 方法回调函数如果在运行中抛出错误，也会被 catch 捕获</span></span>
<span class="line"><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;foo&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">((</span><span style="color:#E36209;">res</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">    throw</span><span style="color:#D73A49;"> new</span><span style="color:#6F42C1;"> Error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;err&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#6F42C1;">catch</span><span style="color:#24292E;">((</span><span style="color:#E36209;">err</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(err));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_3-3-promise-prototype-finally" tabindex="-1">3.3 Promise.prototype.finally() <a class="header-anchor" href="#_3-3-promise-prototype-finally" aria-label="Permalink to &quot;3.3 Promise.prototype.finally()&quot;">​</a></h3><ol><li>无论 p 的状态如何都会执行</li><li>finally 不接受任何参数。</li><li>finally 的返回值和状态无关，大多数情况下表现为父期约的传递。</li><li>主要是为了解决冗余代码问题</li></ol><h3 id="_3-4-期约连锁" tabindex="-1">3.4 期约连锁 <a class="header-anchor" href="#_3-4-期约连锁" aria-label="Permalink to &quot;3.4 期约连锁&quot;">​</a></h3><ul><li>可以使用连缀方法的调用的形式</li><li>实现的原理主要是 then，catch，finally 处理程序的返回值都是一个 Promise。</li><li>链式调用后面的内容需要等前一个调用执行完才会执行。</li></ul><h3 id="_3-5-promise-all-p-p" tabindex="-1">3.5 Promise.all([p, p]) <a class="header-anchor" href="#_3-5-promise-all-p-p" aria-label="Permalink to &quot;3.5 Promise.all([p, p])&quot;">​</a></h3><ul><li>Promise.all() 静态方法会在一组期约全部解决之后再解决, 返回 <code>一个新期约</code></li><li>有一个包含的期约待定，则合成的期约也待定。一个包含的期约拒绝，则合成的期约也拒绝(第一个拒绝的理由会成为合成期约的拒绝理由, 不等待其他 Promise 解决)</li><li>如果所有期约都成功解决，合成期约的值就是包含期约解决值的数组。并且<code>合成期约值的顺序和传入实例的顺序一致</code>。如果有期约抛出错误，则合成期约的返回值是这个被拒绝的期约。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 新期约的值是一个数组，[&quot;foo&quot;, &quot;bar&quot;]</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> p </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">all</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;foo&quot;</span><span style="color:#24292E;">), </span><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;bar&quot;</span><span style="color:#24292E;">)]);</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">all</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">]); </span><span style="color:#6A737D;">// 原始值会被Promise.resolve()包装处理</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">all</span><span style="color:#24292E;">([]); </span><span style="color:#6A737D;">// 这条语句等价于Promise.resolve()</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> d </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">all</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 无效的语法</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">all</span><span style="color:#24292E;">([</span></span>
<span class="line"><span style="color:#D73A49;">  new</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">      ...</span></span>
<span class="line"><span style="color:#24292E;">  }),</span></span>
<span class="line"><span style="color:#D73A49;">  new</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#D73A49;">      ...</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">]).</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#E36209;">results</span><span style="color:#D73A49;"> =&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  result[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#6A737D;">//里面是第一次执行的结果</span></span>
<span class="line"><span style="color:#24292E;">  result[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#6A737D;">//里面是第二次执行的结果</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_3-6-promise-race-p-p" tabindex="-1">3.6 Promise.race([p, p]) <a class="header-anchor" href="#_3-6-promise-race-p-p" aria-label="Permalink to &quot;3.6 Promise.race([p, p])&quot;">​</a></h3><ul><li>返回一个包装期约，是一组集合中最先解决或者拒绝的期约的镜像。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">race</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">]); </span><span style="color:#6A737D;">// 原始值会被Promise.resolve()包装处理</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">race</span><span style="color:#24292E;">([]); </span><span style="color:#6A737D;">// 这条语句等价于Promise.resolve()</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> d </span><span style="color:#D73A49;">=</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">race</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 无效的语法</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_3-7-promise-allsettled-p-p" tabindex="-1">3.7 Promise.allSettled([p, p]) <a class="header-anchor" href="#_3-7-promise-allsettled-p-p" aria-label="Permalink to &quot;3.7 Promise.allSettled([p, p])&quot;">​</a></h3><ul><li>返回一个包装期约，是一组集合所有 Promise 都完成(不论成功、失败只要完成就行)之后的结果</li><li>allSettled 的状态只会是 resolve，不会是 reject</li></ul><h3 id="_3-8-promise-any-p-p" tabindex="-1">3.8 Promise.any([p, p]) <a class="header-anchor" href="#_3-8-promise-any-p-p" aria-label="Permalink to &quot;3.8 Promise.any([p, p])&quot;">​</a></h3><ul><li>返回一个包装期约，如果有一个 Promise resolved，那么这个包装期约就解决，解决值就是第一个 resolved 的期约的值。如果<code>所有的 Promise 都 reject</code>，那么这个包装期约就拒绝，拒绝的值为 &quot;AggregateError: All promises were rejected&quot;</li></ul><h3 id="_3-9-promise-try" tabindex="-1">3.9 Promise.try() <a class="header-anchor" href="#_3-9-promise-try" aria-label="Permalink to &quot;3.9 Promise.try()&quot;">​</a></h3><ul><li>目前仍处于提案状态</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-light vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 一、使用 try catch 捕获 getJSON 中的同步错误</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> getJSON</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6A737D;">  // 可能抛出同步错误。例如 x is not defined</span></span>
<span class="line"><span style="color:#24292E;">  x </span><span style="color:#D73A49;">+</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#D73A49;"> new</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">((</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;">, </span><span style="color:#E36209;">reject</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6A737D;">    // 可能抛出异步错误，根据请求状态决定</span></span>
<span class="line"><span style="color:#D73A49;">    ...</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 如果想要同时捕获同步、异步错误，可以这样写</span></span>
<span class="line"><span style="color:#6A737D;">// 但是这样写比较麻烦</span></span>
<span class="line"><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6F42C1;">  getJSON</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">    .</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">((</span><span style="color:#E36209;">res</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(res);</span></span>
<span class="line"><span style="color:#24292E;">    })</span></span>
<span class="line"><span style="color:#24292E;">    .</span><span style="color:#6F42C1;">catch</span><span style="color:#24292E;">((</span><span style="color:#E36209;">err</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(err);</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (error) {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(error);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 二、使用 Promise.try() 捕获同步错误</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#6F42C1;"> getJSON</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#6A737D;">  // 抛出同步的错误</span></span>
<span class="line"><span style="color:#24292E;">  x </span><span style="color:#D73A49;">+</span><span style="color:#005CC5;"> 1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">  return</span><span style="color:#D73A49;"> new</span><span style="color:#005CC5;"> Promise</span><span style="color:#24292E;">((</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;">, </span><span style="color:#E36209;">reject</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#6F42C1;">    resolve</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;foo&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">try</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#6F42C1;"> getJSON</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">((</span><span style="color:#E36209;">res</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(res);</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#6F42C1;">catch</span><span style="color:#24292E;">((</span><span style="color:#E36209;">err</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(err);</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h2 id="四、终止-promise-终止不是中断-promise-一旦被创建就没办法被中断" tabindex="-1">四、终止 Promise(终止不是中断，Promise 一旦被创建就没办法被中断) <a class="header-anchor" href="#四、终止-promise-终止不是中断-promise-一旦被创建就没办法被中断" aria-label="Permalink to &quot;四、终止 Promise(终止不是中断，Promise 一旦被创建就没办法被中断)&quot;">​</a></h2><p>TODO：</p>`,49)]))}const E=n(o,[["render",r]]);export{u as __pageData,E as default};
