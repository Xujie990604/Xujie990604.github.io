import{_ as e,c as a,o as i,ag as o}from"./chunks/framework.BDwTZuFy.js";const h=JSON.parse('{"title":"plugin 和 loader","description":"","frontmatter":{},"headers":[],"relativePath":"docs/前端工程化/Webpack/Plugin&Loader.md","filePath":"docs/前端工程化/Webpack/Plugin&Loader.md","lastUpdated":1737533611000}'),r={name:"docs/前端工程化/Webpack/Plugin&Loader.md"};function d(t,l,c,s,n,u){return i(),a("div",null,l[0]||(l[0]=[o('<h1 id="plugin-和-loader" tabindex="-1">plugin 和 loader <a class="header-anchor" href="#plugin-和-loader" aria-label="Permalink to &quot;plugin 和 loader&quot;">​</a></h1><ul><li>主要使用 JS 来编写 Plugin 和 loader, 但是也可以通过 WEBAssembly 来编写 Plugin 和 loader</li></ul><h2 id="一、插件" tabindex="-1">一、插件 <a class="header-anchor" href="#一、插件" aria-label="Permalink to &quot;一、插件&quot;">​</a></h2><ul><li>对于 webpack 现有<code>功能的扩展</code>，可以<code>贯穿 Webpack 打包的生命周期</code>，执行不同的任务比如打包优化，文件压缩, 代码检查。</li><li>webpack 在运行的声明周期中<code>广播</code>许多事件， Plugin 可以<code>监听</code>这些事件</li></ul><h3 id="_1-1-常见-plugin" tabindex="-1">1.1 常见 plugin <a class="header-anchor" href="#_1-1-常见-plugin" aria-label="Permalink to &quot;1.1 常见 plugin&quot;">​</a></h3><ol><li>htmlWebpackPlugin 自动生成 HTML 模板并且引入资源文件</li><li>CleanWebpackPlugin 打包之前清除之前的文件</li><li>miniCssExtractPlugin 把 CSS 以外链文件的形式引入 HTML 中</li><li>copyWebpackPlugin 复制指定文件夹到 dist 目录中</li><li>speed-measure-webpack-plugin 查看 webpack 的构建费时情况</li><li>webpack-bundle-analyzer 查看打包文件的体积大小</li><li>optimize-css-assets-webpack-plugin 压缩 CSS</li><li>terser-webpack-plugin 压缩 JS(webpack 默认开启)</li><li>purgecss-webpack-plugin 清除无用的 CSS</li><li><code>EsLint</code> 很严格的 JS 代码规范</li></ol><h2 id="二、loader" tabindex="-1">二、loader <a class="header-anchor" href="#二、loader" aria-label="Permalink to &quot;二、loader&quot;">​</a></h2><ul><li>loader <code>本质上就是一个函数</code>，是一个<code>转换器</code></li><li>webpack 默认支持处理 <code>js</code> 和 <code>json</code> 文件，其他类型的处理不了，需要借助 <code>loader</code> 来转化特定类型的文件，将文件转化为 webpack 能处理的类型。</li></ul><h3 id="_2-1-常见-loader" tabindex="-1">2.1 常见 loader <a class="header-anchor" href="#_2-1-常见-loader" aria-label="Permalink to &quot;2.1 常见 loader&quot;">​</a></h3><ol><li>style-loader 把 css 语句写入 style 标签中，然后插入到 html 页面里</li><li>css-loader 识别 CSS 语法</li><li>postcss-loader 识别 postcss 语法</li><li>sass-loader 识别 scss 语法</li><li>babel-loader 识别 ES6+ 语法并转移成兼容指定浏览器的 JS 代码</li><li>cache-loader 缓存一些性能开销较大的 loader 的处理结果</li><li>thread-loader 开启多进程打包优化</li><li>url-loader 和 file-loader 类似，但是可以将较小的文件转成 base64 的 URI，然后图片可以和其他资源放在一个请求中，减少对服务器的压力</li><li>vue-loader(vue 加载) 和 vue-template-compiler(vue 模板编译)</li><li>ts-loader 识别 TS 语法</li></ol><h2 id="三、手动编写-plugin" tabindex="-1">三、手动编写 Plugin <a class="header-anchor" href="#三、手动编写-plugin" aria-label="Permalink to &quot;三、手动编写 Plugin&quot;">​</a></h2><ul><li>插件是由<code>具有 apply 方法的 prototype 对象</code> 所实例化出来的</li></ul><h3 id="事件钩子" tabindex="-1">事件钩子 <a class="header-anchor" href="#事件钩子" aria-label="Permalink to &quot;事件钩子&quot;">​</a></h3><p>TODO：补充具体的生命周期事件</p><h3 id="绑定事件的方式" tabindex="-1">绑定事件的方式 <a class="header-anchor" href="#绑定事件的方式" aria-label="Permalink to &quot;绑定事件的方式&quot;">​</a></h3><ol><li>tap: 同步钩子方法</li><li>tapAsync: 异步钩子方法</li><li>tapPromise: 异步钩子方法</li></ol><h2 id="四、手动编写-loader" tabindex="-1">四、手动编写 Loader <a class="header-anchor" href="#四、手动编写-loader" aria-label="Permalink to &quot;四、手动编写 Loader&quot;">​</a></h2><p>TODO：补充具体的实例</p>',18)]))}const b=e(r,[["render",d]]);export{h as __pageData,b as default};
