import{_ as i,c as n,o as a,ag as l}from"./chunks/framework.BDwTZuFy.js";const h=JSON.parse('{"title":"SOLID","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Nest/框架哲学/SOLID原则.md","filePath":"docs/Nest/框架哲学/SOLID原则.md","lastUpdated":1741070174000}'),r={name:"docs/Nest/框架哲学/SOLID原则.md"};function t(o,e,s,p,c,d){return a(),n("div",null,e[0]||(e[0]=[l('<h1 id="solid" tabindex="-1">SOLID <a class="header-anchor" href="#solid" aria-label="Permalink to &quot;SOLID&quot;">​</a></h1><h2 id="一、单一职责原则-single-responsibility-principle-srp" tabindex="-1">一、单一职责原则（Single Responsibility Principle，SRP） <a class="header-anchor" href="#一、单一职责原则-single-responsibility-principle-srp" aria-label="Permalink to &quot;一、单一职责原则（Single Responsibility Principle，SRP）&quot;">​</a></h2><ul><li>一个类应该只有一个引起它变化的原因。简单来说，一个类应该只负责一项职责，而不应该承担过多的功能。</li></ul><h2 id="二、开放-封闭原则-open-closed-principle-ocp" tabindex="-1">二、开放 - 封闭原则（Open - Closed Principle，OCP） <a class="header-anchor" href="#二、开放-封闭原则-open-closed-principle-ocp" aria-label="Permalink to &quot;二、开放 - 封闭原则（Open - Closed Principle，OCP）&quot;">​</a></h2><ul><li>软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。也就是说，当需要增加新功能时，应该通过扩展现有代码来实现，而不是修改已有的代码。</li></ul><h2 id="三、里氏替换原则-liskov-substitution-principle-lsp" tabindex="-1">三、里氏替换原则（Liskov Substitution Principle，LSP） <a class="header-anchor" href="#三、里氏替换原则-liskov-substitution-principle-lsp" aria-label="Permalink to &quot;三、里氏替换原则（Liskov Substitution Principle，LSP）&quot;">​</a></h2><ul><li>子类对象能够替换其父类对象，而程序的行为不会发生改变。也就是说，子类应该能够完全替代父类，并且不会破坏程序的正确性。</li></ul><h2 id="四、接口隔离原则-interface-segregation-principle-isp" tabindex="-1">四、接口隔离原则（Interface Segregation Principle，ISP） <a class="header-anchor" href="#四、接口隔离原则-interface-segregation-principle-isp" aria-label="Permalink to &quot;四、接口隔离原则（Interface Segregation Principle，ISP）&quot;">​</a></h2><ul><li>客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。也就是说，不应该强迫客户端实现它们不需要的方法</li></ul><h2 id="五、依赖倒置原则-dependency-inversion-principle-dip" tabindex="-1">五、依赖倒置原则（Dependency Inversion Principle，DIP） <a class="header-anchor" href="#五、依赖倒置原则-dependency-inversion-principle-dip" aria-label="Permalink to &quot;五、依赖倒置原则（Dependency Inversion Principle，DIP）&quot;">​</a></h2><ul><li>高层模块不应该依赖低层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。简单来说，就是要依赖于抽象接口，而不是具体实现类。</li></ul>',11)]))}const P=i(r,[["render",t]]);export{h as __pageData,P as default};
