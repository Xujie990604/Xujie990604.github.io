import{_ as a,c as t,o as i,ag as e}from"./chunks/framework.BDwTZuFy.js";const u=JSON.parse('{"title":"html标准","description":"","frontmatter":{},"headers":[],"relativePath":"docs/HTML+CSS/HTML部分/HTML标准.md","filePath":"docs/HTML+CSS/HTML部分/HTML标准.md","lastUpdated":1748668692000}'),h={name:"docs/HTML+CSS/HTML部分/HTML标准.md"};function s(r,l,o,c,d,m){return i(),t("div",null,l[0]||(l[0]=[e('<h1 id="html标准" tabindex="-1">html标准 <a class="header-anchor" href="#html标准" aria-label="Permalink to &quot;html标准&quot;">​</a></h1><h2 id="html-xhtml" tabindex="-1">html xhtml <a class="header-anchor" href="#html-xhtml" aria-label="Permalink to &quot;html xhtml&quot;">​</a></h2><ul><li>html 不区别标签的大小写，标签可以不闭合。</li><li>xhtml 要求所有的标签名和属性名都必须使用小写，标签必须闭合，哪怕是单标签也要用一个反斜线表示结束。由于标准过于严格，导致在实际环境中难以推行，目前该计划可能被放弃。</li></ul><h2 id="html5声明" tabindex="-1">html5声明 <a class="header-anchor" href="#html5声明" aria-label="Permalink to &quot;html5声明&quot;">​</a></h2><ul><li> html5 的文档类型声明，既支持 HTML 的标签也支持 XHTML 的标签。 </li><li>对应的就是标准模式</li></ul><h2 id="组织-html-和-css-代码" tabindex="-1">组织 HTML 和 CSS 代码 <a class="header-anchor" href="#组织-html-和-css-代码" aria-label="Permalink to &quot;组织 HTML 和 CSS 代码&quot;">​</a></h2><ul><li>可维护性</li><li>结构和表现分离</li><li>关注点分离：分成小块，松散结合。</li></ul><h3 id="html-和-css-的版本" tabindex="-1">HTML 和 CSS 的版本 <a class="header-anchor" href="#html-和-css-的版本" aria-label="Permalink to &quot;HTML 和 CSS 的版本&quot;">​</a></h3><ul><li>其实很多 CSS 属性在成为标准之前就可以使用了</li><li>开发者其实需要关注的并不是标准，需要关注的是哪些属性已经在浏览器中被实现，是否稳健。</li></ul><h3 id="语句和良好的结构" tabindex="-1">语句和良好的结构 <a class="header-anchor" href="#语句和良好的结构" aria-label="Permalink to &quot;语句和良好的结构&quot;">​</a></h3><ul><li>语义化标记是优秀 HTML 文档的基础，语义化标记意味着在正确的地方使用正确的标记。</li><li>使得可以使用文本终端，web 浏览器，或者必要的时候使用屏幕阅读器也能阅读他们。</li><li>良好的结构也使得爬虫能够更好的爬取你的网站，你的页面的索引和排名就会更靠前</li><li>并且有意义的 HTML 标记为添加 CSS 样式提供了方便。</li></ul><h4 id="html5的语义化标签" tabindex="-1">HTML5的语义化标签 <a class="header-anchor" href="#html5的语义化标签" aria-label="Permalink to &quot;HTML5的语义化标签&quot;">​</a></h4><ul><li>例如<code>&lt;header&gt; &lt;setion&gt; &lt;nav&gt; &lt;footer&gt;等</code></li></ul><h4 id="id-和-class" tabindex="-1">ID 和 class <a class="header-anchor" href="#id-和-class" aria-label="Permalink to &quot;ID 和 class&quot;">​</a></h4><ul><li>class 通常被用作 css 的接入点，因为可以复用，方便维护。起类名时尽量用类名表示组件的类型而不是组件的视觉效果(这样命名有利于 CSS 类名的重复利用)</li><li>id 通常被用来在文档中标识元素，而不是用来添加样式。毕竟 id 只能出现一次。</li></ul><h4 id="设立一套基础的样式" tabindex="-1">设立一套基础的样式 <a class="header-anchor" href="#设立一套基础的样式" aria-label="Permalink to &quot;设立一套基础的样式&quot;">​</a></h4><ul><li>reset.css 使工作有条不紊，不受默认样式的影响。</li><li>实际开发中不要简单粗暴的直接用通配选择符把所有的元素的 padding 和 margin 都设置为0.要使用成熟的 reset.css 库</li></ul><h3 id="渐进增强-html-和-css-属性实现了内置的渐进增强策略" tabindex="-1">渐进增强：html 和 css 属性实现了内置的渐进增强策略 <a class="header-anchor" href="#渐进增强-html-和-css-属性实现了内置的渐进增强策略" aria-label="Permalink to &quot;渐进增强：html 和 css 属性实现了内置的渐进增强策略&quot;">​</a></h3><ul><li>html渐进增强：浏览器遇到未知的元素或者属性并不会报错，比如 input 的 email 会回退为 text 类型</li><li>css 渐进增强：浏览器遇到无法识别的属性和值的话，会丢弃相应的说明。(只要为 css 属性声明合适的后备代码就行)</li></ul><h4 id="浏览器的前缀" tabindex="-1">浏览器的前缀 <a class="header-anchor" href="#浏览器的前缀" aria-label="Permalink to &quot;浏览器的前缀&quot;">​</a></h4><ul><li>浏览器只会识别带有自家前缀的CSS属性。在使用一个实验性属性时，不仅要考虑到带有各种浏览器前缀的情况，还要考虑到不带有浏览器前缀的情况。</li><li>-webkit- 是Safari，Chrome，Opera浏览器的前缀</li><li>-moz- 是火狐浏览器</li><li>-ms- 是IE浏览器</li></ul><h3 id="support-css特性" tabindex="-1">@support(CSS特性){} <a class="header-anchor" href="#support-css特性" aria-label="Permalink to &quot;@support(CSS特性){}&quot;">​</a></h3><ul><li>仅在浏览器支持CSS特性的时候，才会执行{}中的css语句</li></ul>',23)]))}const S=a(h,[["render",s]]);export{u as __pageData,S as default};
