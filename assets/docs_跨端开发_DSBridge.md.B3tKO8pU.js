import{_ as a,c as i,o as l,ag as t}from"./chunks/framework.BDwTZuFy.js";const p=JSON.parse('{"title":"混合开发技术","description":"","frontmatter":{},"headers":[],"relativePath":"docs/跨端开发/DSBridge.md","filePath":"docs/跨端开发/DSBridge.md","lastUpdated":null}'),d={name:"docs/跨端开发/DSBridge.md"};function r(o,e,c,s,n,h){return l(),i("div",null,e[0]||(e[0]=[t('<h1 id="混合开发技术" tabindex="-1">混合开发技术 <a class="header-anchor" href="#混合开发技术" aria-label="Permalink to &quot;混合开发技术&quot;">​</a></h1><h2 id="一、jsbridge" tabindex="-1">一、JSBridge <a class="header-anchor" href="#一、jsbridge" aria-label="Permalink to &quot;一、JSBridge&quot;">​</a></h2><ul><li>在 Hybrid 模式下，H5 会经常需要使用 Native 的功能，比如打开二维码扫描、调用原生页面、获取用户信息等，同时 Native 也需要向 Web 端发送推送、更新状态等，</li><li>而 JavaScript 是运行在单独的 JS Context 中（Webview容器、JSCore等），与原生有运行环境的隔离，所以需要有一种机制实现 Native 端和 Web 端的双向通信</li><li>JSBridge：以JavaScript 引擎或 Webview 容器作为媒介，通过协定协议进行通信，实现 <code>Native 端和 Web 端双向通信</code>的一种机制。</li></ul><h2 id="二、jsbridge实现原理" tabindex="-1">二、JSBridge实现原理 <a class="header-anchor" href="#二、jsbridge实现原理" aria-label="Permalink to &quot;二、JSBridge实现原理&quot;">​</a></h2><h3 id="_2-1-javascript-调用-native-端" tabindex="-1">2.1 JavaScript 调用 Native 端 <a class="header-anchor" href="#_2-1-javascript-调用-native-端" aria-label="Permalink to &quot;2.1 JavaScript 调用 Native 端&quot;">​</a></h3><ul><li>使用 URL Scheme 拦截的方式</li></ul><ol><li><p>JS 端发起调用</p><ul><li>JS 调用 <code>dsBridge.call(&#39;getUserInfo&#39;, { &#39;userId&#39;: 123 }, function(userInfo) { ... })</code></li><li>把接口调用信息编码为 URL，<code>dsbridge://call?module=default&amp;method=getUserInfo&amp;args=%7B%22userId%22%3A123%7D&amp;callback=c_1678886400000_1</code></li><li>包含重要信息：方法名、参数、回调ID</li></ul></li><li><p>创建不可见的 iframe</p><ul><li>创建一个不可见的 iframe，并设置其 src 为 URL</li></ul></li><li><p>Native 端拦截 URL</p><ul><li>Native 端拦截 <code>dsbridge://</code> 开头的URL，并解析出方法名、参数、回调ID</li></ul></li><li><p>解析 URL 并执行方法</p><ul><li>Native 端解析 URL，并执行方法</li><li>执行方法后，将结果通过回调 ID 返回给 JS 端</li></ul></li></ol><h3 id="_2-2-native-端调用-javascript-端" tabindex="-1">2.2 Native 端调用 JavaScript 端 <a class="header-anchor" href="#_2-2-native-端调用-javascript-端" aria-label="Permalink to &quot;2.2 Native 端调用 JavaScript 端&quot;">​</a></h3><ol><li><p>JavaScript 环境准备</p><ul><li>DSBridge 初始化，向 WebView 中注入一段核心的 JS 代码，定义内部方法例如 <code>_handleMessageFromNative</code></li></ul></li><li><p>Native 发起调用</p><ul><li>Native 调用 <code>webView.callHandler(&#39;updateTitle&#39;, &#39;New Title&#39;, function(response) { ... })</code></li><li>把调用信息编码为 JSON 字符串 <code>&#39;javascript:dsBridge._handleMessageFromNative(\\&#39;&#39; + jsonString + &#39;\\&#39;);&#39;</code></li><li>包含重要信息：方法名、参数、回调</li></ul></li><li><p>Native 执行 JS 方法</p><ul><li>在 Android 中是 <code>webView.evaluateJavascript(...)</code>。</li><li>在 iOS 中是 <code>webView.evaluateJavaScript(...)</code>。</li></ul></li><li><p>JS 端处理消息</p><ul><li>JS 解析 JSON 字符串，执行对应的方法</li><li>如果有回调，继续使用 URL Scheme 拦截的方式返回给 Native 端</li></ul></li></ol><h2 id="三、桥接通信" tabindex="-1">三、桥接通信 <a class="header-anchor" href="#三、桥接通信" aria-label="Permalink to &quot;三、桥接通信&quot;">​</a></h2><h3 id="_3-1-通信的性能损耗" tabindex="-1">3.1 通信的性能损耗 <a class="header-anchor" href="#_3-1-通信的性能损耗" aria-label="Permalink to &quot;3.1 通信的性能损耗&quot;">​</a></h3><ol><li><p>通信的过桥开销</p><ul><li>数据序列化和反序列化</li><li>协议编码与解码</li></ul></li><li><p>异步通信的延迟</p><ul><li>单次调用的影响不大，高频调用场景下影响较为明显</li></ul></li></ol><h3 id="通信的体积限制" tabindex="-1">通信的体积限制 <a class="header-anchor" href="#通信的体积限制" aria-label="Permalink to &quot;通信的体积限制&quot;">​</a></h3><table tabindex="0"><thead><tr><th>通信方向</th><th>DSBridge 底层机制</th><th>体积限制</th><th>限制原因</th><th>解决方案</th></tr></thead><tbody><tr><td>JS → Native</td><td>URL Scheme 拦截</td><td>有，且比较严格（约 1MB）</td><td>底层 WebView 对 URL 长度的限制</td><td>分片传输，将大数据拆分成小块多次调用</td></tr><tr><td>Native → JS</td><td>evaluateJavascript</td><td>有，但非常宽松（受限于内存）</td><td>WebView 执行 JS 字符串的能力</td><td>通常不需要特殊处理，可以直接传递</td></tr></tbody></table>',14)]))}const v=a(d,[["render",r]]);export{p as __pageData,v as default};
