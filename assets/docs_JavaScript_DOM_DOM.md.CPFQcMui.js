import{_ as l,c as i,o as t,ag as a}from"./chunks/framework.BDwTZuFy.js";const m=JSON.parse('{"title":"DOM(文档对象模型)","description":"","frontmatter":{},"headers":[],"relativePath":"docs/JavaScript/DOM/DOM.md","filePath":"docs/JavaScript/DOM/DOM.md","lastUpdated":1716123809000}'),o={name:"docs/JavaScript/DOM/DOM.md"};function d(n,e,r,u,s,c){return t(),i("div",null,e[0]||(e[0]=[a('<h1 id="dom-文档对象模型" tabindex="-1">DOM(文档对象模型) <a class="header-anchor" href="#dom-文档对象模型" aria-label="Permalink to &quot;DOM(文档对象模型)&quot;">​</a></h1><ul><li>文档对象模型(Document Object Model)，javaScript 提供了 DOM API 来操作 DOM</li><li>一份 HTML 文档就是一份节点树。</li></ul><h2 id="node-接口" tabindex="-1">Node 接口 <a class="header-anchor" href="#node-接口" aria-label="Permalink to &quot;Node 接口&quot;">​</a></h2><ul><li>DOM1 级定义了一个 Node 接口，所有 DOM 节点类型都要实现该接口。</li><li>在 JS 中这个接口是作为 Node 类型类实现的。因此所有的 DOM 结点都共享相同的基本属性(nodeName, nodeValue, childNodes, previousSibling, nextSibling 等属性)和方法(appendChild(), replaceChild(), removeChild()等方法)</li></ul><h3 id="节点的四个属性" tabindex="-1">节点的四个属性 <a class="header-anchor" href="#节点的四个属性" aria-label="Permalink to &quot;节点的四个属性&quot;">​</a></h3><ol><li><p>nodeName 元素的标签名，大写形式表示，只读。</p></li><li><p>nodeValue(用于更改元素的文本，可读可写)</p></li></ol><ul><li>想要获取一个元素的文本，不能直接使用 nodeValue，而是要使用 ele.firstChild.nodeValue;</li><li>因为元素内的文本也是一个节点(文本节点)。获取的是元素节点的子节点的 nodeValue</li></ul><ol start="3"><li>nodeType 该节点的类型，只读</li></ol><ul><li>节点的类型元素节点 1 属性节点 2 文本节点 3</li></ul><ol start="4"><li>attributes Element 节点的属性(自身的属性例如 class 和 id )集合，根据 DOM 树动态检索的集合。</li></ol><h3 id="设置和获取节点的属性-一级-dom-方法-兼容性好" tabindex="-1">设置和获取节点的属性(一级 DOM 方法，兼容性好) <a class="header-anchor" href="#设置和获取节点的属性-一级-dom-方法-兼容性好" aria-label="Permalink to &quot;设置和获取节点的属性(一级 DOM 方法，兼容性好)&quot;">​</a></h3><ul><li>getAttribute(&quot;title&quot;) 用来查询 DOM 节点的属性。</li><li>setAttribute(&quot;title&quot;,&quot;xujie&quot;) 可以用来更改或者添加属性节点的值(可以设置文档中任何一个元素的任何属性</li><li>元素的特性，都可以通过 DOM 元素本身的属性来访问(作为对象属性进行读写这种形式比较简洁方便)(class 需要使用 className 来访问)，自定义的特性不可以(需要使用 getAttribute(&#39;xxx&#39;)方法)</li><li>用来操作自定义的特性，特性的名称不区别大小写，但是根据 HTML5 规范，自定义的特性要加上 data-前缀</li><li>removeAttribute() 用来彻底删除元素的特性。</li></ul><h3 id="节点树相关属性" tabindex="-1">节点树相关属性 <a class="header-anchor" href="#节点树相关属性" aria-label="Permalink to &quot;节点树相关属性&quot;">​</a></h3><ul><li>parentNode 父节点</li><li>childNodes 子节点们</li><li>firstChild 第一个子节点</li><li>lastChild 最后一个子节点</li><li>nextSibling 下一个兄弟节点</li><li>previousSibling 前一个兄弟节点</li><li>Node.hasChildNodes()节点是否拥有子节点</li></ul><h3 id="基于元素节点树的遍历-不包含属性结点-文本结点等" tabindex="-1">基于元素节点树的遍历(不包含属性结点，文本结点等) <a class="header-anchor" href="#基于元素节点树的遍历-不包含属性结点-文本结点等" aria-label="Permalink to &quot;基于元素节点树的遍历(不包含属性结点，文本结点等)&quot;">​</a></h3><ul><li>parentElement 返回当前元素的父元素节点</li><li>children 只返回当前元素的子节点</li><li>node.childElementCount === node.children.length 当前元素节点的子节点个数</li><li>firstElementChild 返回的是第一个元素节点</li><li>lastElementChild 返回的是最后一个元素节点</li><li>nextElementSibling 返回下一个兄弟元素节点</li><li>previousElementSibling 返回前一个兄弟元素节点</li></ul><h3 id="childnodes-属性" tabindex="-1">childNodes 属性 <a class="header-anchor" href="#childnodes-属性" aria-label="Permalink to &quot;childNodes 属性&quot;">​</a></h3><ul><li>用来获取一个元素的所有子元素(不仅仅是元素节点)。</li><li>返回结果是一个 NodeList 对象.是一种类数组对象。每次访问都会运行一次基于文档的查询。所以尽量减少对于 NodeList 的访问。</li><li>并不是 Array 的实例，因为这个 NodeList 对象是基于 DOM 结构动态执行查询的结果，是有生命的呼吸的对象。</li><li>firstChild，lastChild，nextSibling，previousSibling 都是在 childNodes 的 NodeList 对象中进行遍历的。</li></ul><h2 id="获取元素的方法" tabindex="-1">获取元素的方法 <a class="header-anchor" href="#获取元素的方法" aria-label="Permalink to &quot;获取元素的方法&quot;">​</a></h2><h3 id="document-getelementbyid-id" tabindex="-1">document.getElementById(id) <a class="header-anchor" href="#document-getelementbyid-id" aria-label="Permalink to &quot;document.getElementById(id)&quot;">​</a></h3><ul><li>根据 id 获取元素</li><li>只定义在 document 对象上</li></ul><h3 id="document-getelementsbytagname" tabindex="-1">document.getElementsByTagName() <a class="header-anchor" href="#document-getelementsbytagname" aria-label="Permalink to &quot;document.getElementsByTagName()&quot;">​</a></h3><ul><li>获取一个对象数组(类数组)，数组里面存储着所有符合类型的 DOM 对象</li><li>返回的这个数组里面的数据是根据 DOM 树 动态获取的。不是静态的。</li><li>参数使用 &quot;*&quot;，通配符选择器</li><li>可以是某个 DOM 对象的方法</li></ul><h3 id="document-getelementsbyclassname" tabindex="-1">document.getElementsByClassName() <a class="header-anchor" href="#document-getelementsbyclassname" aria-label="Permalink to &quot;document.getElementsByClassName()&quot;">​</a></h3><ul><li>返回值同样是一个对象数组(类数组)。</li><li>参数可以填写 &quot;*&quot; 通配符来选择所有的元素。</li><li>参数可以有多个类名，使用空格来隔开，该方法会选择所有包含了这些类名的 DOM。参数顺序无所谓。</li><li>是 HTML5 规范中制定的</li><li>可以是某个 DOM 对象的方法</li></ul><h3 id="按照-css-的选择方式进行选择的方法" tabindex="-1">按照 css 的选择方式进行选择的方法 <a class="header-anchor" href="#按照-css-的选择方式进行选择的方法" aria-label="Permalink to &quot;按照 css 的选择方式进行选择的方法&quot;">​</a></h3><ul><li>querySelector 可以直接按照 css 选择器类型进行选择。并且选择出来的是第一个。</li><li>querySelectorAll 选择出来的是一组</li><li>返回值是一个 NodeList 对象，不过底层实现是一组元素的快照，而非不断的对文档进行搜索的动态查询，这样的实现避免因为 NodeList 的性能问题。</li><li>document 和 Element 都可以调用这两个方法</li></ul><h2 id="document-对象" tabindex="-1">document 对象 <a class="header-anchor" href="#document-对象" aria-label="Permalink to &quot;document 对象&quot;">​</a></h2><ul><li>document 代表的是整个 HTML 文档(包含的不只是页面显示的 DOM，html 文件开头的文件声明也能通过 document 属性访问到)</li><li>document.documentElement 就是 <code>&lt;html&gt;</code></li><li>document.body 就是 <code>&lt;body&gt;</code></li><li>document.head 就是 <code>&lt;head&gt;</code></li><li>document.title 获取页面标题</li><li>document.url 包含当前页面的完整 URL</li><li>document.domain 包含当前页面的域名</li><li>document.referrer 包含链接到当前页面的那个页面的 URL</li></ul><h2 id="html-attributes-与-dom-properties" tabindex="-1">HTML Attributes 与 DOM Properties <a class="header-anchor" href="#html-attributes-与-dom-properties" aria-label="Permalink to &quot;HTML Attributes 与 DOM Properties&quot;">​</a></h2><ul><li>HTML Attributes 与 DOM Properties 的关系很复杂，有些内容他俩是相同的(id、class)，有些内容 HTML 有 DOM 没有(aria-*)，有些内容 DOM 有 HTML 没有(textContent)，还有一些内容在 HTML 和 DOM 中都有，但是含义不同(value)</li><li>核心原则：HTML Attributes 的作用是设置与之对应的 DOM Properties 的初始值</li></ul>',31)]))}const b=l(o,[["render",d]]);export{m as __pageData,b as default};
