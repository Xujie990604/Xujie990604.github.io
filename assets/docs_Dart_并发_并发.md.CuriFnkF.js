import{_ as e,c as t,o as r,ag as l}from"./chunks/framework.BDwTZuFy.js";const _=JSON.parse('{"title":"并发","description":"","frontmatter":{},"headers":[],"relativePath":"docs/Dart/并发/并发.md","filePath":"docs/Dart/并发/并发.md","lastUpdated":1749559081000}'),i={name:"docs/Dart/并发/并发.md"};function o(d,a,s,c,n,u){return r(),t("div",null,a[0]||(a[0]=[l('<h1 id="并发" tabindex="-1">并发 <a class="header-anchor" href="#并发" aria-label="Permalink to &quot;并发&quot;">​</a></h1><ul><li>所有的 dart 代码都在隔离中运行，每个隔离都有自己<code>独立</code> 的<code>内存</code>和<code>事件循环</code></li></ul><h2 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h2><ul><li>事件：任何事情。例如，重绘UI、用户点击请求、磁盘IO</li><li>执行顺序：按照入队顺序一次处理一个事件</li><li>同步任务、单线程</li></ul><h2 id="异步编程" tabindex="-1">异步编程 <a class="header-anchor" href="#异步编程" aria-label="Permalink to &quot;异步编程&quot;">​</a></h2><h3 id="future" tabindex="-1">Future <a class="header-anchor" href="#future" aria-label="Permalink to &quot;Future&quot;">​</a></h3><ul><li>表示异步操作的结果，该操作最终将以值或者错误完成</li></ul><h3 id="async-await" tabindex="-1">async-await <a class="header-anchor" href="#async-await" aria-label="Permalink to &quot;async-await&quot;">​</a></h3><ul><li>声明式的方式来定义异步函数并使用它们的结果</li></ul><h3 id="streams" tabindex="-1">Streams <a class="header-anchor" href="#streams" aria-label="Permalink to &quot;Streams&quot;">​</a></h3><ul><li>以流的形式存在的异步代码，流在未来和重复的时间内提供值</li><li>await-for 用来循环遍历<code>流</code></li><li>yield 在返回值为流的函数中代替 return</li></ul>',11)]))}const m=e(i,[["render",o]]);export{_ as __pageData,m as default};
